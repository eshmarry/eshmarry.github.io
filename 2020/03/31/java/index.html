<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="http://yoursite.com">
  <title>java | D·blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="java知识一、Java 基础1. JDK  和 JRE  有什么区别？下图是它们的直观区别，可从它们的面向对象、主要作用和组成部分三方面对比。其详细如下图所示：  2.JDK就是Java Development Kit 的英文缩写。1). 主要面向开发人员。开发人员在软件开发时使用的SDK（Software Development Kit 一般指软件开发包），它提供了Java的开发环境和运行环境">
<meta property="og:type" content="article">
<meta property="og:title" content="java">
<meta property="og:url" content="http://yoursite.com/2020/03/31/java/index.html">
<meta property="og:site_name" content="D·blog">
<meta property="og:description" content="java知识一、Java 基础1. JDK  和 JRE  有什么区别？下图是它们的直观区别，可从它们的面向对象、主要作用和组成部分三方面对比。其详细如下图所示：  2.JDK就是Java Development Kit 的英文缩写。1). 主要面向开发人员。开发人员在软件开发时使用的SDK（Software Development Kit 一般指软件开发包），它提供了Java的开发环境和运行环境">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="d:%5C%E6%88%91%E7%9A%84%E6%96%87%E6%A1%A3%5C%E8%87%AA%E5%AD%A6%5C%E6%96%87%E6%A1%A3md%5Cjava%5Cimg%5C20180804194412881.png">
<meta property="og:image" content="d:%5C%E6%88%91%E7%9A%84%E6%96%87%E6%A1%A3%5C%E8%87%AA%E5%AD%A6%5C%E6%96%87%E6%A1%A3md%5Cjava%5Cimg%5C20180804204658455.png">
<meta property="og:image" content="d:%5C%E6%88%91%E7%9A%84%E6%96%87%E6%A1%A3%5C%E8%87%AA%E5%AD%A6%5C%E6%96%87%E6%A1%A3md%5Cjava%5Cimg%5C20180602183200272.png">
<meta property="og:image" content="d:%5C%E6%88%91%E7%9A%84%E6%96%87%E6%A1%A3%5C%E8%87%AA%E5%AD%A6%5C%E6%96%87%E6%A1%A3md%5Cjava%5Cimg%5C20180602183440649.png">
<meta property="og:image" content="d:%5C%E6%88%91%E7%9A%84%E6%96%87%E6%A1%A3%5C%E8%87%AA%E5%AD%A6%5C%E6%96%87%E6%A1%A3md%5Cjava%5Cimg%5C2018060218482441.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190727183756962.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NzcxMjY2,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190731133906772.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NzcxMjY2,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190731135031290.png">
<meta property="og:image" content="https://img2018.cnblogs.com/other/1408183/201911/1408183-20191119184149559-1571595668.jpg">
<meta property="og:image" content="https://iknow-pic.cdn.bcebos.com/3ac79f3df8dcd1005a9d1b7c7f8b4710b9122f6e?x-bce-process=image/resize,m_lfit,w_600,h_800,limit_1">
<meta property="og:image" content="https://ask.qcloudimg.com/http-save/yehe-2073418/v4ln6xjzff.png?imageView2/2/w/1620">
<meta property="og:image" content="https://iknow-pic.cdn.bcebos.com/c83d70cf3bc79f3d7af9e37bb7a1cd11728b2964?x-bce-process=image/resize,m_lfit,w_600,h_800,limit_1">
<meta property="og:image" content="https://images.cnitblog.com/blog/497634/201401/08000847-0a9caed4d6914485b2f56048c668251a.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190310221443337.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODQ4MTk2Mw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190311182248435.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODQ4MTk2Mw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190310224348833.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190310225911793.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODQ4MTk2Mw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdn.net/20180904143958577?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlZmVuZ2xpYW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://image-static.segmentfault.com/103/927/1039278453-5cb44799195cb_articlex">
<meta property="og:image" content="https://image-static.segmentfault.com/348/335/3483357010-5cb447fba09cc_articlex">
<meta property="og:image" content="https://image-static.segmentfault.com/321/742/3217423639-5cb4481c12383_articlex">
<meta property="og:image" content="https://image-static.segmentfault.com/823/033/82303300-5cb44834907c3_articlex">
<meta property="og:image" content="https://image-static.segmentfault.com/151/165/1511654841-5cb448978ac67_articlex">
<meta property="og:image" content="https://image-static.segmentfault.com/269/492/269492869-5cb448b648b26_articlex">
<meta property="og:image" content="https://image-static.segmentfault.com/426/020/4260200719-5cb448da74905_articlex">
<meta property="og:image" content="https://image-static.segmentfault.com/268/471/2684714099-5cb4490a24858_articlex">
<meta property="og:image" content="https://image-static.segmentfault.com/402/080/4020809164-5cb44b5159432_articlex">
<meta property="og:image" content="https://image-static.segmentfault.com/802/512/802512886-5cb44b68b2180_articlex">
<meta property="og:image" content="https://image-static.segmentfault.com/237/019/2370191236-5cb44b829ac84_articlex">
<meta property="og:image" content="https://image-static.segmentfault.com/319/476/3194760406-5cb44c6423bc6_articlex">
<meta property="og:image" content="https://image-static.segmentfault.com/237/019/2370191236-5cb44b829ac84_articlex">
<meta property="og:image" content="https://image-static.segmentfault.com/302/554/3025543906-5cb44ba3b77e0_articlex">
<meta property="og:image" content="https://image-static.segmentfault.com/128/298/1282980653-5cb44cc1013f3_articlex">
<meta property="og:image" content="https://image-static.segmentfault.com/140/473/1404730361-5cb44bd090b99_articlex">
<meta property="og:image" content="https://image-static.segmentfault.com/154/083/1540832116-5cb44d4261bfe_articlex">
<meta property="og:image" content="https://image-static.segmentfault.com/371/749/3717490699-5cb44d5a4c6ad_articlex">
<meta property="og:image" content="https://image-static.segmentfault.com/204/258/2042589382-5cb44d7b1a737_articlex">
<meta property="og:image" content="https://image-static.segmentfault.com/809/484/809484289-5cb44d922e659_articlex">
<meta property="og:image" content="https://image-static.segmentfault.com/197/586/1975863815-5cb44da68406c_articlex">
<meta property="og:image" content="https://iknow-pic.cdn.bcebos.com/6a600c338744ebf8431eb5dfd7f9d72a6159a7e7?x-bce-process=image/resize,m_lfit,w_600,h_800,limit_1">
<meta property="og:image" content="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=2169381799,1320776160&fm=173&app=49&f=JPEG?w=450&h=300&s=440A5532435E4DC80AD4B1DB0000C0B2">
<meta property="og:image" content="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=2349409144,1211092590&fm=173&app=49&f=JPEG?w=450&h=300&s=0C0A55325347434D48D5914B030060F1">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190105150030891.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTYwNTkzNw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://pics3.baidu.com/feed/e1fe9925bc315c603847d2d2fdb85817485477ce.jpeg?token=23377106bfc734a5a7e48d0827f49a41&s=8D287C32973950231C44B9DA000090B1">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/10852140-d963ba5a5de3deeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700/format/webp">
<meta property="og:image" content="https://img2018.cnblogs.com/i-beta/1751422/201912/1751422-20191224105405074-229817569.png">
<meta property="og:image" content="https://img-blog.csdn.net/20150812175720353?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="https://img-blog.csdn.net/20150812175924769?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="https://img-blog.csdn.net/20150812180232152?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="https://img-blog.csdn.net/20150812180547633?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="https://iknow-pic.cdn.bcebos.com/810a19d8bc3eb1351031fc0fab1ea8d3fc1f448b?x-bce-process=image/resize,m_lfit,w_600,h_800,limit_1">
<meta property="og:image" content="https://img-blog.csdn.net/20180208112533496">
<meta property="og:image" content="https://img-blog.csdn.net/2018091917061915?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbmd4aWFvMTk5Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180919164448658?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbmd4aWFvMTk5Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20191129144820655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbmd4aWFvMTk5Mw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20191129145350949.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbmd4aWFvMTk5Mw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20191129145434875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbmd4aWFvMTk5Mw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdn.net/20171219104402700?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzYzNTkwMjI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20171219110406861?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzYzNTkwMjI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20171219115333087?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzYzNTkwMjI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="article:published_time" content="2020-03-31T15:59:51.000Z">
<meta property="article:modified_time" content="2020-03-31T16:04:04.622Z">
<meta property="article:author" content="董晓洁">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="d:%5C%E6%88%91%E7%9A%84%E6%96%87%E6%A1%A3%5C%E8%87%AA%E5%AD%A6%5C%E6%96%87%E6%A1%A3md%5Cjava%5Cimg%5C20180804194412881.png">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" type="text/css" href="/./main.0cf68a.css">
  <style type="text/css">
  
    #container.show {
      background: linear-gradient(200deg,#a0cfe4,#e8c37e);
    }
  </style>
  

  

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container" q-class="show:isCtnShow">
    <canvas id="anm-canvas" class="anm-canvas"></canvas>
    <div class="left-col" q-class="show:isShow">
      
<div class="overlay" style="background: #4d4d4d"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1584166420575&amp;di=c528b8dd4d2404c12f7bf52adb28f53e&amp;imgtype=0&amp;src=http%3A%2F%2Fimg.qqzhi.com%2Fuploads%2F2018-12-06%2F151207950.jpg" class="js-avatar">
		</a>
		<hgroup>
		  <h1 class="header-author"><a href="/">董晓洁</a></h1>
		</hgroup>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/tags/%E9%9A%8F%E7%AC%94/">随笔</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
    		
    			
    			<a q-on="click: openSlider(e, 'innerArchive')" href="javascript:void(0)">所有文章</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'friends')" href="javascript:void(0)">友链</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'aboutme')" href="javascript:void(0)">关于我</a>
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/eshmarry" title="github"><i class="icon-github"></i></a>
		        
					<a class="weibo" target="_blank" href="https://www.weibo.com/5658951433/profile?topnav=1&wvr=6&is_all=1" title="weibo"><i class="icon-weibo"></i></a>
		        
					<a class="bilibili" target="_blank" href="https://space.bilibili.com/384827736" title="bilibili"><i class="icon-bilibili"></i></a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col" q-class="show:isShow,hide:isShow|isFalse">
      
<nav id="mobile-nav">
  	<div class="overlay js-overlay" style="background: #4d4d4d"></div>
	<div class="btnctn js-mobile-btnctn">
  		<div class="slider-trigger list" q-on="click: openSlider(e)"><i class="icon icon-sort"></i></div>
	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1584166420575&amp;di=c528b8dd4d2404c12f7bf52adb28f53e&amp;imgtype=0&amp;src=http%3A%2F%2Fimg.qqzhi.com%2Fuploads%2F2018-12-06%2F151207950.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author js-header-author">董晓洁</h1>
			</hgroup>
			
			
			
				
			
				
			
			
			
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/eshmarry" title="github"><i class="icon-github"></i></a>
			        
						<a class="weibo" target="_blank" href="https://www.weibo.com/5658951433/profile?topnav=1&wvr=6&is_all=1" title="weibo"><i class="icon-weibo"></i></a>
			        
						<a class="bilibili" target="_blank" href="https://space.bilibili.com/384827736" title="bilibili"><i class="icon-bilibili"></i></a>
			        
				</div>
			</nav>

			<nav class="header-menu js-header-menu">
				<ul style="width: 50%">
				
				
					<li style="width: 50%"><a href="/">主页</a></li>
		        
					<li style="width: 50%"><a href="/tags/%E9%9A%8F%E7%AC%94/">随笔</a></li>
		        
				</ul>
			</nav>
		</header>				
	</div>
	<div class="mobile-mask" style="display:none" q-show="isShow"></div>
</nav>

      <div id="wrapper" class="body-wrap">
        <div class="menu-l">
          <div class="canvas-wrap">
            <canvas data-colors="#eaeaea" data-sectionHeight="100" data-contentId="js-content" id="myCanvas1" class="anm-canvas"></canvas>
          </div>
          <div id="js-content" class="content-ll">
            <article id="post-java" class="article article-type-post " itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      java
    </h1>
  

        
        <a href="/2020/03/31/java/" class="archive-article-date">
  	<time datetime="2020-03-31T15:59:51.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2020-03-31</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="java知识"><a href="#java知识" class="headerlink" title="java知识"></a>java知识</h1><h2 id="一、Java-基础"><a href="#一、Java-基础" class="headerlink" title="一、Java 基础"></a><strong>一、Java 基础</strong></h2><h4 id="1-JDK-和-JRE-有什么区别？"><a href="#1-JDK-和-JRE-有什么区别？" class="headerlink" title="1. JDK  和 JRE  有什么区别？"></a>1. JDK  和 JRE  有什么区别？</h4><p>下图是它们的直观区别，可从它们的面向对象、主要作用和组成部分三方面对比。其详细如下图所示：</p>
<p><img src="D:%5C%E6%88%91%E7%9A%84%E6%96%87%E6%A1%A3%5C%E8%87%AA%E5%AD%A6%5C%E6%96%87%E6%A1%A3md%5Cjava%5Cimg%5C20180804194412881.png" alt=""></p>
<h4 id="2-JDK就是Java-Development-Kit-的英文缩写。"><a href="#2-JDK就是Java-Development-Kit-的英文缩写。" class="headerlink" title="2.JDK就是Java Development Kit 的英文缩写。"></a>2.JDK就是Java Development Kit 的英文缩写。</h4><p>1). 主要面向开发人员。开发人员在软件开发时使用的SDK（Software Development Kit 一般指软件开发包），它提供了Java的开发环境和运行环境。<br>2). 如果你电脑安装了JDK，那么你不仅可以开发<strong>Java程序，也同时拥有了运行</strong>Java程序的平台。<br>3). 是整个Java开发的核心，包括了Java运行环境，Java工具和Java基础类库。<br>3.JRE就是Java Runtime Enviroment的英文缩写。<br>1). 主要面向程序使用者。<br>2). 如果你电脑安装了JRE，那么你的电脑只能运行Java程序，不能从事Java开发。<br>3). 包含JVM标准实现及Java核心类库。它包括Java虚拟机、Java平台核心类和支持文件。它不包含开发工具(编译器、调试器等)。同时还包含了编译java源码的编译器javac，还包含了很多java程序调试和分析的工具：console，jvisualvm 等工具软件，还包含了java程序编写所需的文档和demo例子程序。 </p>
<ol start="4">
<li>补充<br>1). JRE是个运行环境，JDK是个开发环境。因此，开发程序时，写的Java程序就是在JDK上，而运行Java程序的时候，就 需要JRE。<br>2).JDK包含了JRE，但是，JRE可以独立安装的。<br>3). JDK、JRE、JVM的关系 </li>
</ol>
<p><img src="D:%5C%E6%88%91%E7%9A%84%E6%96%87%E6%A1%A3%5C%E8%87%AA%E5%AD%A6%5C%E6%96%87%E6%A1%A3md%5Cjava%5Cimg%5C20180804204658455.png" alt=""></p>
<ol start="5">
<li>例子<br>1).Java程序在执行过程中用到一套JDK工具，其中java.exe是指（B）<br>A.Java文档生成器<br>B.Java解释器<br>C.Java编译器<br>D.Java类分解器<br>2).JDK安装目录下具有多个文件夹和一些网页文件，其中为java使用者提供的一些已经编好的范例程序的文件夹是（demo）<br>JDK安装目录下主要文件夹及文件功能：<br>（1）bin文件夹：提供JDK工具程序，包括javac、java、javadoc、appletviewer等可执行程序。<br>（2）demo文件夹：Sun公司为Java使用者提供给的一些已经编写好的范例程序。<br>（3）jre文件夹：存放Jaca运行环境文件。<br>（4）lib文件夹：存放Java的类库文件，即工具程序使用的Java类库。JDK中的工具程序大多也是由Java编写而成。<br>（5）include文件夹：存放用于本地方法的文件。<br>3).（ A）称为JAVA开发包或JAVA开发工具，是一个写JAVA的Applet小程序和应用程序的程序开发环境。<br>A.JDK<br>B.JRE<br>C.JVM<br>4).(C )可以实现Java程序的跨平台运行。<br>A.JDK<br>B.JRE<br>C.JVM</li>
</ol>
<h4 id="2-和-equals-的别是什么？"><a href="#2-和-equals-的别是什么？" class="headerlink" title="2.== 和 equals 的别是什么？"></a>2.== 和 equals 的别是什么？</h4><p>​        在JVM中，内存分为堆内存跟栈内存。他们二者的区别是： 当wo们创建一个对象（new Object）时，就会调用对象的构造函数来开辟空间，将对象数据存储到<strong>堆内存</strong>中，与此同时在<strong>栈内存中生成对应的引用</strong>，当我们在后续代码中调用的时候用的都是栈内存中的引用。还需注意的一点，基本数据类型是存储在栈内存中。</p>
<p>初步认识equals与==的区别：<br>==是判断两个变量或实例是不是指向同一个<strong>内存空间</strong>，equals是判断两个变量或实例所指向的<strong>内存空间的值</strong>是不是相同<br>==是指对内存地址进行比较 ， equals()是对字符串的内容进行比较<br>==指引用是否相同， equals()指的是值是否相同<br>用一张图可以简要的表现他们之间的关系：</p>
<p><img src="D:%5C%E6%88%91%E7%9A%84%E6%96%87%E6%A1%A3%5C%E8%87%AA%E5%AD%A6%5C%E6%96%87%E6%A1%A3md%5Cjava%5Cimg%5C20180602183200272.png" alt=""></p>
<p>代码测试一：</p>
<p><img src="D:%5C%E6%88%91%E7%9A%84%E6%96%87%E6%A1%A3%5C%E8%87%AA%E5%AD%A6%5C%E6%96%87%E6%A1%A3md%5Cjava%5Cimg%5C20180602183440649.png" alt=""></p>
<p>equals与==的区别详解：</p>
<p>String s=”abcd”是一种非常特殊的形式,和new 有本质的区别。它是java中唯一不需要new 就可以产生对象的途径==比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同，即是否是指相同一个对象。比较的是真正意义上的指针操作。equals用来比较的是两个对象的内容是否相等，由于所有的类都是继承java.lang.Object类的，所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的equals方法返回的却是==的判断。String s=”abcd”是一种非常特殊的形式,和new 有本质的区别。它是java中唯一不需要new 就可以产生对象的途径。以String s=”abcd”;形式赋值在java中叫直接量,它是在常量池中而不是象new一样放在压缩堆中。 这种形式的字符串，在JVM内部发生字符串拘留，即当声明这样的一个字符串后，JVM会在常量池中先查找有有没有一个值为”abcd”的对象,如果有,就会把它赋给当前引用.即原来那个引用和现在这个引用指点向了同一对象, 如果没有,则在常量池中新创建一个”abcd”,下一次如果有String s1 = “abcd”;又会将s1指向”abcd”这个对象,即以这形式声明的字符串,只要值相等,任何多个引用都指向同一对象.</p>
<p><strong>形式赋值在 java 中叫直接量</strong></p>
<p>　　而String s = new String(“abcd”);和其它任何对象一样.每调用一次就产生一个对象只要它们调用.也可以这么理解:String str = “hello”; 先在内存中找是不是有”hello”这个对象,如果有，就让str指向那个”hello”.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果内存里没有&quot;hello&quot;，就创建一个新的对象保存&quot;hello&quot;. String str&#x3D;new String (&quot;hello&quot;) 就是不管内存里是不是已经有&quot;hello&quot;这个对象，都新建一个对象保存&quot;hello&quot;。</span><br></pre></td></tr></table></figure>

<p><strong>代码测试二：</strong></p>
<p><img src="D:%5C%E6%88%91%E7%9A%84%E6%96%87%E6%A1%A3%5C%E8%87%AA%E5%AD%A6%5C%E6%96%87%E6%A1%A3md%5Cjava%5Cimg%5C2018060218482441.png" alt=""></p>
<p>3.两个对象的 hashCode()相同，则 equals()也一定为 true, 对吗?                     </p>
<p>同时反过来equals为true，hashCode也不一定相同。  类的hashCode方法和equals方法都可以重写，返回的值完全在于自己定义。 hashCode()返回该对象的<strong>哈希码值</strong>； equals()返回两个<strong>对象是否相等</strong>。  </p>
<p>关于hashCode和equal是方法是有一些 常规协定 ：  </p>
<p>1、<strong>两个对象用equals()比较返回true，那么两个对象的hashCode()方法必须返回相同的结果</strong>。</p>
<p>2、两个对象用equals()比较返回false，不要求hashCode()方法也一定返回不同的值，但是最好返回不同值，亿提搞哈希表性能。</p>
<p>3、重写equals()方法，必须重写hashCode()方法，以保证equals方法相等时两个对象hashcode返回相同的值。</p>
<p>1，什么是序列化<br>把对象或者结构体从内存中变成可存储或传输的过程称之为序列化。序列化是将一个对象转换成字节流(byte[]，或者叫字符串，2进制串)以达到将其长期保存在内存、数据库或文件中的处理过程。它的主要目的是保存对象的状态以便以后需要的时候使用。序列化后的内容如果是为了方便以后需要的时候使用，自然是二进制序列化较好。Soap，XML，json ，protobuf序列化更多的是为了交换数据用的。</p>
<h4 id="4-final-在-java-中有什么作用？"><a href="#4-final-在-java-中有什么作用？" class="headerlink" title="4.final 在 java 中有什么作用？"></a>4.final 在 java 中有什么作用？</h4><p>​    final作为Java中的关键字可以用于三个地方。用于修饰类、类属性和类方法。</p>
<p>​          特征：凡是引用final关键字的地方皆不可修改！</p>
<p>​         (1)修饰类：表示该类不能被继承；</p>
<p>​        (2)修饰方法：表示方法不能被重写；</p>
<p>​        (3)修饰变量：表示变量只能一次赋值以后值不能被修改（常量）。</p>
<h4 id="5-java-中的-Math-round-1-5-等于多少？"><a href="#5-java-中的-Math-round-1-5-等于多少？" class="headerlink" title="5.java 中的 Math.round(-1.5) 等于多少？"></a>5.java 中的 Math.round(-1.5) 等于多少？</h4><h4 id="6-String-属于基础的数据类型吗？"><a href="#6-String-属于基础的数据类型吗？" class="headerlink" title="6.String 属于基础的数据类型吗？"></a>6.String 属于基础的数据类型吗？</h4><p>​      在Java中，数据类型分为引用类型和基本类型，基本类型分为八种</p>
<p>​      整型：byte，short，int,long</p>
<p>​      浮点型：float，double</p>
<p>​      字符型：char</p>
<p>​      Boolean型：boolean</p>
<p>​      String不是基本的数据类型，是final修饰的java类，是引用类型</p>
<h4 id="7-java-中操作字符串都有哪些类？它们之间有什么区别？"><a href="#7-java-中操作字符串都有哪些类？它们之间有什么区别？" class="headerlink" title="7.java 中操作字符串都有哪些类？它们之间有什么区别？"></a>7.java 中操作字符串都有哪些类？它们之间有什么区别？</h4><p>String : final修饰，String类的方法都是返回new String。即对String对象的任何改变都不影响到原对象，对字符串的修改操作都会生成新的对象。<br>StringBuffer : 对字符串的操作的方法都加了synchronized，保证线程安全。<br>StringBuilder : 不保证线程安全，在方法体内需要进行字符串的修改操作，可以new StringBuilder对象，调用StringBuilder对象的append、replace、delete等方法修改字符串。</p>
<h4 id="8-String-str-”i”与-String-str-new-String-“i”-一样吗？"><a href="#8-String-str-”i”与-String-str-new-String-“i”-一样吗？" class="headerlink" title="8.String str=”i”与 String str=new String(“i”)一样吗？"></a>8.String str=”i”与 String str=new String(“i”)一样吗？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先明白一个事，java存在一个常量池，可以用来存储字符串常量。</span><br></pre></td></tr></table></figure>

<p>1 创建的字符串变量在内存中的区别<br>两者看似都是创建了一个字符串对象，但在内存中确是各有各的想法。</p>
<p>String str1= “abc”； 在编译期，JVM会去常量池来查找是否存在“abc”，如果不存在，就在常量池中开辟一个空间来存储“abc”；如果存在，就不用新开辟空间。然后在栈内存中开辟一个名字为str1的空间，来存储“abc”在常量池中的地址值。</p>
<p>String str2 = new String(“abc”) ;在编译阶段JVM先去常量池中查找是否存在“abc”，如果过不存在，则在常量池中开辟一个空间存储“abc”。在运行时期，通过String类的构造器在堆内存中new了一个空间，然后将String池中的“abc”复制一份存放到该堆空间中，在栈中开辟名字为str2的空间，存放堆中new出来的这个String对象的地址值。</p>
<p>也就是说，前者在初始化的时候可能创建了一个对象，也可能一个对象也没有创建；后者因为new关键字，至少在内存中创建了一个对象，也有可能是两个对象。</p>
<p>2 String类的特性<br>String类 是final修饰的，不可以被继承。</p>
<p>String类的底层是基于char数组的。</p>
<p>3 两个方面<br>1）性能效率</p>
<p>String类被设计成不可变（immutable）类，所以它的所有对象都是不可变对象。例如：</p>
<p>String str = “hello”;</p>
<p>str = str + “world“；</p>
<p>所以当上文str指向了一个String对象（内容为“hello”），然后对str进行“+”操作，str原来指向的对象并没有变，而是str又指向了另外一个对象（“hello world”），原来的对象还在内存中。</p>
<p>由此也可以看出，频繁的对String对象进行修改，会造成很大的内存开销。此时应该用StringBuffer或StringBuilder来代替String。</p>
<p>而new String（）更加不适合，因为每一次创建对象都会调用构造器在堆中产生新的对象，性能低下且内存更加浪费。</p>
<p>2）安全性</p>
<p>对象都是只读的，所以多线程并发访问也不会有任何问题。</p>
<p>由于不可变，用来存储数据也是极为安全的。</p>
<h4 id="9-如何将字符串反转？"><a href="#9-如何将字符串反转？" class="headerlink" title="9.如何将字符串反转？"></a>9.如何将字符串反转？</h4><ol>
<li>利用 StringBuffer 或 StringBuilder 的 reverse 成员方法:</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StringBuffer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverse1</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder(str).reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>利用 String 的 toCharArray 方法先将字符串转化为 char 类型数组，然后将各个字符进行重新拼接:</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// toCharArray</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverse2</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">  String reverse = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = chars.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    reverse += chars[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> reverse；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>利用 String 的 CharAt 方法取出字符串中的各个字符:</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// charAt</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverse3</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">  String reverse = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">int</span> length = str.length();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    reverse = str.charAt(i) + reverse；</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　最后补充 main 方法中的测试代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   String s = <span class="string">"abc123"</span>;</span><br><span class="line">   System.out.println(<span class="string">"----------------"</span>);</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">     System.out.print(s.charAt(i));</span><br><span class="line">   &#125;</span><br><span class="line">   System.out.println(<span class="string">"----------------"</span>);</span><br><span class="line">   System.out.println(<span class="string">"变换前: "</span> + s);</span><br><span class="line"> System.out.println(<span class="string">"变换后: "</span> + reverse1(s));</span><br><span class="line">   System.out.println(<span class="string">"变换后: "</span> + reverse2(s));</span><br><span class="line">   System.out.println(<span class="string">"变换后: "</span> + reverse3(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="10-String-类的常用方法都有那些？"><a href="#10-String-类的常用方法都有那些？" class="headerlink" title="10.String 类的常用方法都有那些？"></a>10.String 类的常用方法都有那些？</h4><p><strong>一、String类</strong><br>String类在java.lang包中，java使用String类创建一个字符串变量，字符串变量属于对象。java把String类声明的final类，不能有类。String类对象创建后不能修改，由0或多个字符组成，包含在一对双引号之间。<br><strong>二、String类对象的创建</strong><br>字符串声明：String stringName;<br>字符串创建：stringName = new String(字符串常量);或stringName = 字符串常量;<br><strong>三、String类构造方法</strong><br>1、<strong>public String()</strong><br>无参构造方法，用来创建空字符串的String对象。<br> 1 String str1 = new String();<br>2、<strong>public String(String value)</strong><br>用已知的字符串value创建一个String对象。<br> 1 String str2 = new String(“asdf”); 2 String str3 = new String(str2);<br>3、<strong>public String(char[] value)</strong><br>用字符数组value创建一个String对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 char[] value &#x3D; &#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;&#125;;</span><br><span class="line">2 String str4 &#x3D; new String(value);&#x2F;&#x2F;相当于String str4 &#x3D; new String(&quot;abcd&quot;);</span><br></pre></td></tr></table></figure>

<p>4、<strong>public String(char chars[], int startIndex, int numChars)</strong><br>用字符数组chars的startIndex开始的numChars个字符创建一个String对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 char[] value &#x3D; &#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;&#125;;</span><br><span class="line">2 String str5 &#x3D; new String(value, 1, 2);&#x2F;&#x2F;相当于String str5 &#x3D; new String(&quot;bc&quot;);</span><br></pre></td></tr></table></figure>

<p>5、<strong>public String(byte[] values)</strong><br>用比特数组values创建一个String对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 byte[] strb &#x3D; new byte[]&#123;65,66&#125;;</span><br><span class="line">2 String str6 &#x3D; new String(strb);&#x2F;&#x2F;相当于String str6 &#x3D; new String(&quot;AB&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>四、String类常用方法</strong><br>1、求字符串长度<br><strong>public int length()</strong>//返回该字符串的长度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 String str &#x3D; new String(&quot;asdfzxc&quot;);</span><br><span class="line">2 int strlength &#x3D; str.length();&#x2F;&#x2F;strlength &#x3D; 7</span><br></pre></td></tr></table></figure>

<p>2、求字符串某一位置字符<br><strong>public char charAt(int index)</strong>//返回字符串中指定位置的字符；注意字符串中第一个字符索引是0，最后一个是length()-1。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 String str &#x3D; new String(&quot;asdfzxc&quot;);</span><br><span class="line">2 char ch &#x3D; str.charAt(4);&#x2F;&#x2F;ch &#x3D; z</span><br></pre></td></tr></table></figure>

<p>3、提取子串<br>用String类的substring方法可以提取字符串中的子串，该方法有两种常用参数:<br>1)<strong>public String substring(int beginIndex)</strong>//该方法从beginIndex位置起，从当前字符串中取出剩余的字符作为一个新的字符串返回。<br>2)<strong>public String substring(int beginIndex, int endIndex)</strong>//该方法从beginIndex位置起，从当前字符串中取出到endIndex-1位置的字符作为一个新的字符串返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 String str1 &#x3D; new String(&quot;asdfzxc&quot;);</span><br><span class="line">2 String str2 &#x3D; str1.substring(2);&#x2F;&#x2F;str2 &#x3D; &quot;dfzxc&quot;</span><br><span class="line">3 String str3 &#x3D; str1.substring(2,5);&#x2F;&#x2F;str3 &#x3D; &quot;dfz&quot;</span><br></pre></td></tr></table></figure>

<p>4、字符串比较<br>1)<strong>public int compareTo(String anotherString)</strong>//该方法是对字符串内容按字典顺序进行大小比较，通过返回的整数值指明当前字符串与参数字符串的大小关系。若当前对象比参数大则返回正整数，反之返回负整数，相等返回0。<br>2)<strong>public int compareToIgnore(String anotherString)</strong>//与compareTo方法相似，但忽略大小写。<br>3)<strong>public boolean equals(Object anotherObject)</strong>//比较当前字符串和参数字符串，在两个字符串相等的时候返回true，否则返回false。<br>4)<strong>public boolean equalsIgnoreCase(String anotherString)</strong>//与equals方法相似，但忽略大小写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 String str1 &#x3D; new String(&quot;abc&quot;);</span><br><span class="line">2 String str2 &#x3D; new String(&quot;ABC&quot;);</span><br><span class="line">3 int a &#x3D; str1.compareTo(str2);&#x2F;&#x2F;a&gt;0</span><br><span class="line">4 int b &#x3D; str1.compareToIgnoreCase(str2);&#x2F;&#x2F;b&#x3D;0</span><br><span class="line">5 boolean c &#x3D; str1.equals(str2);&#x2F;&#x2F;c&#x3D;false</span><br><span class="line">6 boolean d &#x3D; str1.equalsIgnoreCase(str2);&#x2F;&#x2F;d&#x3D;true</span><br></pre></td></tr></table></figure>



<p>5、字符串连接<br><strong>public String concat(String str)</strong>//将参数中的字符串str连接到当前字符串的后面，效果等价于”+”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 String str &#x3D; &quot;aa&quot;.concat(&quot;bb&quot;).concat(&quot;cc&quot;);</span><br><span class="line">2 相当于String str &#x3D; &quot;aa&quot;+&quot;bb&quot;+&quot;cc&quot;;</span><br></pre></td></tr></table></figure>

<p>6、字符串中单个字符查找<br>1)<strong>public int indexOf(int ch/String str)</strong>//用于查找当前字符串中字符或子串，返回字符或子串在当前字符串中从左边起首次出现的位置，若没有出现则返回-1。<br>2)<strong>public int indexOf(int ch/String str, int fromIndex)</strong>//改方法与第一种类似，区别在于该方法从fromIndex位置向后查找。<br>3)<strong>public int lastIndexOf(int ch/String str)</strong>//该方法与第一种类似，区别在于该方法从字符串的末尾位置向前查找。<br>4)<strong>public int lastIndexOf(int ch/String str, int fromIndex)</strong>//该方法与第二种方法类似，区别于该方法从fromIndex位置向前查找。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 String str &#x3D; &quot;I am a good student&quot;;</span><br><span class="line">2 int a &#x3D; str.indexOf(&#39;a&#39;);&#x2F;&#x2F;a &#x3D; 2</span><br><span class="line">3 int b &#x3D; str.indexOf(&quot;good&quot;);&#x2F;&#x2F;b &#x3D; 7</span><br><span class="line">4 int c &#x3D; str.indexOf(&quot;w&quot;,2);&#x2F;&#x2F;c &#x3D; -1</span><br><span class="line">5 int d &#x3D; str.lastIndexOf(&quot;a&quot;);&#x2F;&#x2F;d &#x3D; 5</span><br><span class="line">6 int e &#x3D; str.lastIndexOf(&quot;a&quot;,3);&#x2F;&#x2F;e &#x3D; 2</span><br></pre></td></tr></table></figure>



<p>7、字符串中字符的大小写转换<br>1)<strong>public String toLowerCase()</strong>//返回将当前字符串中所有字符转换成小写后的新串<br>2)<strong>public String toUpperCase()</strong>//返回将当前字符串中所有字符转换成大写后的新串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 String str &#x3D; new String(&quot;asDF&quot;);</span><br><span class="line">2 String str1 &#x3D; str.toLowerCase();&#x2F;&#x2F;str1 &#x3D; &quot;asdf&quot;</span><br><span class="line">3 String str2 &#x3D; str.toUpperCase();&#x2F;&#x2F;str2 &#x3D; &quot;ASDF&quot;</span><br></pre></td></tr></table></figure>

<p>8、字符串中字符的替换<br>1)<strong>public String replace(char oldChar, char newChar)</strong>//用字符newChar替换当前字符串中所有的oldChar字符，并返回一个新的字符串。<br>2)<strong>public String replaceFirst(String regex, String replacement)</strong>//该方法用字符replacement的内容替换当前字符串中遇到的第一个和字符串regex相匹配的子串，应将新的字符串返回。<br>3)<strong>public String replaceAll(String regex, String replacement)</strong>//该方法用字符replacement的内容替换当前字符串中遇到的所有和字符串regex相匹配的子串，应将新的字符串返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 String str &#x3D; &quot;asdzxcasd&quot;;</span><br><span class="line">2 String str1 &#x3D; str.replace(&#39;a&#39;,&#39;g&#39;);&#x2F;&#x2F;str1 &#x3D; &quot;gsdzxcgsd&quot;</span><br><span class="line">3 String str2 &#x3D; str.replace(&quot;asd&quot;,&quot;fgh&quot;);&#x2F;&#x2F;str2 &#x3D; &quot;fghzxcfgh&quot;</span><br><span class="line">4 String str3 &#x3D; str.replaceFirst(&quot;asd&quot;,&quot;fgh&quot;);&#x2F;&#x2F;str3 &#x3D; &quot;fghzxcasd&quot;</span><br><span class="line">5 String str4 &#x3D; str.replaceAll(&quot;asd&quot;,&quot;fgh&quot;);&#x2F;&#x2F;str4 &#x3D; &quot;fghzxcfgh&quot;</span><br></pre></td></tr></table></figure>

<p>9、其他类方法<br>1)<strong>String trim()</strong>//截去字符串两端的空格，但对于中间的空格不处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 String str &#x3D; &quot; a sd &quot;;</span><br><span class="line">2 String str1 &#x3D; str.trim();</span><br><span class="line">3 int a &#x3D; str.length();&#x2F;&#x2F;a &#x3D; 6</span><br><span class="line">4 int b &#x3D; str1.length();&#x2F;&#x2F;b &#x3D; 4</span><br></pre></td></tr></table></figure>

<p>2)<strong>boolean statWith(String prefix)</strong>或<strong>boolean endWith(String suffix)</strong>//用来比较当前字符串的起始字符或子字符串prefix和终止字符或子字符串suffix是否和当前字符串相同，重载方法中同时还可以指定比较的开始位置offset。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 String str &#x3D; &quot;asdfgh&quot;;</span><br><span class="line">2 boolean a &#x3D; str.statWith(&quot;as&quot;);&#x2F;&#x2F;a &#x3D; true</span><br><span class="line">3 boolean b &#x3D; str.endWith(&quot;gh&quot;);&#x2F;&#x2F;b &#x3D; true</span><br></pre></td></tr></table></figure>

<p>3)<strong>regionMatches(boolean b, int firstStart, String other, int otherStart, int length)</strong>//从当前字符串的firstStart位置开始比较，取长度为length的一个子字符串，other字符串从otherStart位置开始，指定另外一个长度为length的字符串，两字符串比较，当b为true时字符串不区分大小写。<br>4)<strong>contains(String</strong> <strong>str)</strong>//判断参数s是否被包含在字符串中，并返回一个布尔类型的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 String str &#x3D; &quot;student&quot;;</span><br><span class="line">2 str.contains(&quot;stu&quot;);&#x2F;&#x2F;true</span><br><span class="line">3 str.contains(&quot;ok&quot;);&#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>

<p>5)<strong>String[] split(String str)</strong>//将str作为分隔符进行字符串分解，分解后的字字符串在字符串数组中返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 String str &#x3D; &quot;asd!qwe|zxc#&quot;;</span><br><span class="line">2 String[] str1 &#x3D; str.split(&quot;!|#&quot;);&#x2F;&#x2F;str1[0] &#x3D; &quot;asd&quot;;str1[1] &#x3D; &quot;qwe&quot;;str1[2] &#x3D; &quot;zxc&quot;;</span><br></pre></td></tr></table></figure>

<p><strong>五、字符串与基本类型的转换</strong><br>1、字符串转换为基本类型<br>java.lang包中有Byte、Short、Integer、Float、Double类的调用方法：<br>1)<strong>public static byte parseByte(String s)</strong><br>2)<strong>public static short parseShort(String s)</strong><br>3)<strong>public static short parseInt(String s)</strong><br>4)<strong>public static long parseLong(String s)</strong><br>5)<strong>public static float parseFloat(String s)</strong><br>6)<strong>public static double parseDouble(String s)</strong><br>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 int n &#x3D; Integer.parseInt(&quot;12&quot;);</span><br><span class="line">2 float f &#x3D; Float.parseFloat(&quot;12.34&quot;);</span><br><span class="line">3 double d &#x3D; Double.parseDouble(&quot;1.124&quot;);</span><br></pre></td></tr></table></figure>

<p>2、基本类型转换为字符串类型<br>String类中提供了String valueOf()放法，用作基本类型转换为字符串类型。<br>1)<strong>static String valueOf(char data[])</strong><br>2)<strong>static String valueOf(char data[], int offset, int count)</strong><br>3)<strong>static String valueOf(boolean b)</strong><br>4)<strong>static String valueOf(char c)</strong><br>5)<strong>static String valueOf(int i)</strong><br>6)<strong>static String valueOf(long l)</strong><br>7)<strong>static String valueOf(float f)</strong><br>8)<strong>static String valueOf(double d)</strong><br>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 String s1 &#x3D; String.valueOf(12);</span><br><span class="line">2 String s1 &#x3D; String.valueOf(12.34);</span><br></pre></td></tr></table></figure>

<p>3、进制转换<br>使用Long类中的方法得到整数之间的各种进制转换的方法：<br>Long.toBinaryString(long l)<br>Long.toOctalString(long l)<br>Long.toHexString(long l)<br>Long.toString(long l, int p)//p作为任意进制</p>
<h3 id="11-抽象类必须要有抽象方法吗？"><a href="#11-抽象类必须要有抽象方法吗？" class="headerlink" title="11.抽象类必须要有抽象方法吗？"></a>11.抽象类必须要有抽象方法吗？</h3><p>不必须</p>
<p>这道题考察的是抽象类的知识：</p>
<ol>
<li>抽象类必须有关键字abstract来修饰。</li>
<li>抽象类可以不含有抽象方法</li>
<li>如果一个类包含抽象方法，则该类必须是抽象类</li>
</ol>
<h3 id="12-普通类和抽象类有哪些区别？"><a href="#12-普通类和抽象类有哪些区别？" class="headerlink" title="12.普通类和抽象类有哪些区别？"></a>12.普通类和抽象类有哪些区别？</h3><p>一、普通类、抽象类和接口区别：</p>
<ol>
<li>普通类可以实例化,接口都不能被实例化（它没有构造方法）,抽象类如果要实例化,抽象类必须指向实现所有抽象方法的子类对象(抽象类可以直接实例化，直接重写自己的抽象方法),接口必须指向实现所有所有接口方法的类对象。</li>
<li>抽象类要被子类继承,接口要被子类实现。</li>
<li>接口只能做方法的声明,抽象类可以做方法的声明,也可以做方法的实现。</li>
<li>接口里定义的变量只能是公共的静态常量,抽象类中定义的变量是普通变量。</li>
<li>抽象类里的抽象方法必须全部被子类所实现,如果子类不能全部实现父类的抽象方法,那么该子类只能是抽象类。同样，一个实现接口的时候，如果不能全部实现接口方法，那么该类只能是抽象类。</li>
<li>抽象方法只能声明，不能实现。接口是设计的结果，抽象类是重构的结果。</li>
<li>抽象类里可以没有抽象方法。</li>
<li>如果一个类里有抽象方法，那么该类只能是抽象类。</li>
<li>抽象方法要被实现，所以不能是静态的，也不能是私有的。</li>
<li>接口可以继承接口，并可多继承接口，但类只能单继承。（重要啊）</li>
<li>接口中的常量：有固定的修饰符-public static final（不能用private和protected修饰/本质上都是static的而且是final类型的，不管加不加static修饰）。</li>
<li>接口中的抽象方法：有固定的修饰符-public abstract 。</li>
</ol>
<p>13、接口细节：</p>
<p>​    若接口中方法或变量没有写public，static，final / public，abstract ，会自动补齐    。</p>
<p>   接口中的成员都是共有的。</p>
<p>   接口与接口之间是继承关系，而且可以多继承。</p>
<p>   接口不能被实例化</p>
<p>  一个类可以实现多个接口</p>
<p>  在java开发中，我们经常把常用的变量，定义在接口中，作为全局变量使用，访问形式：接口名.变量名。</p>
<p>  一个接口不能继承其它的类，但是可以继承别的接口</p>
<p>  一个重要的原则：当一个类实现了一个接口，要求该类把这个接口的所有方法全部实现</p>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>① 抽象类和接口都是用来抽象具体的对象的，但是接口的抽象级别更高。</p>
<p>② 抽象类可以有具体的方法和属性，接口只能有抽象方法和静态常量。</p>
<p>③ 抽象类主要用来抽象级别，接口主要用来抽象功能。</p>
<p>④ 抽象类中，且不包含任何的实现，派生类必须覆盖它们。接口中所有方法都必须是未实现的。</p>
<p>⑤ 接口方法，访问权限必须是公共的 public。</p>
<p>⑥ 接口内只能有公共方法，不能存在成员变量。</p>
<p>⑦ 接口内只能包含未被实现的方法，也叫抽象方法，但是不能用 abstract 关键字。</p>
<p>⑧ 抽象类的访问速度比接口要快，接口是稍微有点慢，因为它需要时间去寻找在类中实现的方法。</p>
<p>⑨ 抽象类，除了不能被实例化外，与普通 java 类没有任何区别。</p>
<p>⑩ 抽象类可以有 main 方法，接口没有 main 方法。</p>
<p>⑪ 抽象类可以用构造器，接口没有。</p>
<p>⑫ 抽象方法可以有 public、protected 和 default 这些修饰符，接口只能使用默认 public。</p>
<p>⑬ 抽象类，添加新方法可以提供默认的实现，不需要改变原有代码。接口添加新方法，子类必须实现。</p>
<p>⑭ 抽象类的子类用 extends 关键字继承，接口用 implements 来实现。</p>
<h3 id="13-抽象类能使用-final-修饰吗？"><a href="#13-抽象类能使用-final-修饰吗？" class="headerlink" title="13.抽象类能使用 final 修饰吗？"></a>13.抽象类能使用 final 修饰吗？</h3><p>不能，抽象类是被用于继承的，final修饰代表不可修改、不可继承的。</p>
<h3 id="14-接口和抽象类有什么区别？"><a href="#14-接口和抽象类有什么区别？" class="headerlink" title="14.接口和抽象类有什么区别？"></a>14.接口和抽象类有什么区别？</h3><p>1、抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。</p>
<p>2、抽象类要被子类继承，接口要被类实现。</p>
<p>3、接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现</p>
<p>4、接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。</p>
<p>5、抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类只能是抽象类。同样，一个实现接口的时候，如不能全部实现接口方法，那么该类也只能为抽象类。</p>
<p>6、抽象方法只能申明，不能实现，接口是设计的结果 ，抽象类是重构的结果</p>
<p>7、抽象类里可以没有抽象方法</p>
<p>8、如果一个类里有抽象方法，那么这个类只能是抽象类</p>
<p>9、抽象方法要被实现，所以不能是静态的，也不能是私有的。</p>
<p>10、接口可继承接口，并可多继承接口，但类只能单根继承。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>抽象类</th>
<th>接口</th>
</tr>
</thead>
<tbody><tr>
<td>默认的方法实现</td>
<td>它可以有默认的方法实现</td>
<td>接口完全是抽象的。它根本不存在方法的实现</td>
</tr>
<tr>
<td>实现</td>
<td>子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。</td>
<td>子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现</td>
</tr>
<tr>
<td>构造器</td>
<td>抽象类可以有构造器</td>
<td>接口不能有构造器</td>
</tr>
<tr>
<td>与正常Java类的区别</td>
<td>除了你不能实例化抽象类之外，它和普通Java类没有任何区别</td>
<td>接口是完全不同的类型</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>抽象方法可以有public、protected和default这些修饰符</td>
<td>接口方法默认修饰符是public。你不可以使用其它修饰符。</td>
</tr>
<tr>
<td>main方法</td>
<td>抽象方法可以有main方法并且我们可以运行它</td>
<td>接口没有main方法，因此我们不能运行它。（java8以后接口可以有default和static方法，所以可以运行main方法）</td>
</tr>
<tr>
<td>多继承</td>
<td>抽象方法可以继承一个类和实现多个接口</td>
<td>接口只可以继承一个或多个其它接口</td>
</tr>
<tr>
<td>速度</td>
<td>它比接口速度要快</td>
<td>接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。</td>
</tr>
<tr>
<td>添加新方法</td>
<td>如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。</td>
<td>如果你往接口中添加方法，那么你必须改变实现该接口的类。</td>
</tr>
</tbody></table>
<p>抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；<br>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；<br>接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；<br>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p>
<h3 id="15-java-中-IO-流分为几种？"><a href="#15-java-中-IO-流分为几种？" class="headerlink" title="15.java 中 IO 流分为几种？"></a>15.java 中 IO 流分为几种？</h3><p>Java中的流分为两种，一种是字节流，另一种是字符流，分别由四个抽象类来表示（每种流包括输入和输出两种所以一共四个）:InputStream，OutputStream，Reader，Writer。Java中其他多种多样变化的流均是由它们派生出来的.</p>
<p>字符流和字节流是根据处理数据的不同来区分的。字节流按照8位传输，字节流是最基本的，所有文件的储存是都是字节（byte）的储存，在磁盘上保留的并不是文件的字符而是先把字符编码成字节，再储存这些字节到磁盘。</p>
<p>1.字节流可用于任何类型的对象，包括二进制对象，而字符流只能处理字符或者字符串；</p>
<p>2.节流提供了处理任何类型的IO操作的功能，但它不能直接处理Unicode字符，而字符流就可以。</p>
<p>读文本的时候用字符流，例如txt文件。读非文本文件的时候用字节流，例如mp3。理论上任何文件都能够用字节流读取，但当读取的是文本数据时，为了能还原成文本你必须再经过一个转换的工序，相对来说字符流就省了这个麻烦，可以有方法直接读取。</p>
<p>字符流处理的单元为2个字节的Unicode字符，分别操作字符、字符数组或字符串，而字节流处理单元为1个字节， 操作字节和字节数组。所以字符流是由Java虚拟机将字节转化为2个字节的Unicode字符为单位的字符而成的，所以它对多国语言支持性比较好！</p>
<h3 id="16-BIO、NIO、AIO-有什么区别？"><a href="#16-BIO、NIO、AIO-有什么区别？" class="headerlink" title="16.BIO、NIO、AIO 有什么区别？"></a>16.BIO、NIO、AIO 有什么区别？</h3><p>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。<br>NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。<br>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</p>
<p>BIO是一个连接一个线程。<br>NIO是一个请求一个线程。<br>AIO是一个有效请求一个线程。</p>
<p>BIO：同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。<br>NIO：同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。<br>AIO：异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。<br>适用场景分析<br>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。<br>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。<br>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</p>
<p>17.Files的常用方法都有哪些？</p>
<p>Files.exists() 检测文件路径是否存在<br>Files.createFile()创建文件<br>Files.createDirectory()创建文件夹<br>Files.delete() 删除文件或者目录<br>Files.copy() 复制文件<br>Files.move() 移动文件<br>Files.size（）查看文件个数<br>Files.read() 读取文件<br>Files.write()写入文件</p>
<h2 id="二、容器"><a href="#二、容器" class="headerlink" title="二、容器"></a><strong>二、容器</strong></h2><p>18.java 容器都有哪些？</p>
<p>数组,String,java.util下的集合容器</p>
<p>数组长度限制为 Integer.Integer.MAX_VALUE;</p>
<p>String的长度限制: 底层是char 数组 长度 Integer.MAX_VALUE 线程安全的</p>
<p>java.util下的集合容器<br>————————————————</p>
<p><img src="https://img-blog.csdnimg.cn/20190727183756962.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NzcxMjY2,size_16,color_FFFFFF,t_70" alt="&lt;&gt;"></p>
<p>这一块之所以重要是因为，各个接口的特性不同。下面说一下我对这些类的理解。</p>
<p>Set下各种实现类对比</p>
<p>HashSet基于哈希表实现，有以下特点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.不允许重复</span><br><span class="line"></span><br><span class="line"> 2.允许值为null,但是只能有一个</span><br><span class="line"></span><br><span class="line"> 3.无序的。</span><br><span class="line"></span><br><span class="line"> 4.没有索引，所以不包含索引操作的方法</span><br></pre></td></tr></table></figure>

<p>LinkedHashSet跟HashSet一样都是基于哈希表实现。只不过linkedHashSet在hashSet的基础上多了一个链表，这个链表就是用来维护容器中每个元素的顺序的。有以下特点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.不允许重复</span><br><span class="line"></span><br><span class="line">2.允许值为null,但是只能有一个</span><br><span class="line"></span><br><span class="line">3.有序的。</span><br><span class="line"></span><br><span class="line">4.没有索引，所以不包含索引操作的方法</span><br></pre></td></tr></table></figure>

<p>TreeSet是SortedSet接口的唯一实现类，是基于二叉树实现的。TreeSet可以确保集合元素处于排序状态。TreeSet支持两种排序方式，自然排序 和定制排序，其中自然排序为默认的排序方式。向TreeSet中加入的应该是同一个类的对象。有以下特点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.不允许重复</span><br><span class="line"></span><br><span class="line">2.不允许null值</span><br><span class="line"></span><br><span class="line">3.没有索引，所以不包含索引操作的方法</span><br></pre></td></tr></table></figure>

<p>List下各种实现类对比。（这几个类都是有序的，允许重复的）</p>
<p>ArrayList是基于数组实现的，其特点是查询快，增删慢。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">查询快是因为数组的空间是连续的，查询时只要通过首地址和下标很快就能找到元素。</span><br><span class="line"></span><br><span class="line">增删慢是因为数组是不能扩容的，一旦增加或者删除元素，内部操作就是新开辟一个数组把元素copy到新的数组，老的数   组等待被垃圾回收。</span><br></pre></td></tr></table></figure>

<p>以元素增加为例，我们看一下内部实现的源码：</p>
<p><img src="https://img-blog.csdnimg.cn/20190731133906772.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NzcxMjY2,size_16,color_FFFFFF,t_70" alt=""></p>
<p>LinkedList是基于链表实现的。相比于ArrayList其特点是查询慢，增删快。</p>
<p>查询慢：因为链表在内存中开辟的空间不一定是连续的（基本上不可能是连续的）所以链表实现的方式是每个元素节点都会存放自己的地址，数据以及下一个节点的地址，这样把所有的元素连接起来。所以当要查询元素时只能一个一个的往下找，相比于数组的首地址加下标会慢上不少。</p>
<p>下面是链表的数据存储方式：假设有三个元素<br><img src="https://img-blog.csdnimg.cn/20190731135031290.png" alt=""></p>
<p>Vector也是基于数组实现的，相比于arrayList它是线程安全的。如果不考虑线程安全它，ArrayList性能更优。</p>
<p>Map是双列集合的超类。也就是键值对形式。</p>
<p>HashMap和Hashtable都实现了Map接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步(synchronization)，以及速度。</p>
<p>HashMap几乎可以等价于Hashtable，除了HashMap是非synchronized的，并可以接受null(HashMap可以接受为null的键值(key)和值(value)，而Hashtable则不行)。<br>HashMap是非synchronized，而Hashtable是synchronized，这意味着Hashtable是线程安全的，多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的。Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。<br>另一个区别是HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。<br>由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。<br>HashMap不能保证随着时间的推移Map中的元素次序是不变的。<br>LinkedHashMap和hashMap的区别在于多维护了一个链表，用来存储每一个元素的顺序，就跟HashSet和LinkedHashSet差不多。</p>
<p>HashMap通常比TreeMap快一点(树和哈希表的数据结构使然)，建议多使用HashMap，在需要排序的Map时候才用TreeMap。</p>
<h3 id="19-Collection-和-Collections-有什么区别？"><a href="#19-Collection-和-Collections-有什么区别？" class="headerlink" title="19.Collection 和 Collections 有什么区别？"></a>19.Collection 和 Collections 有什么区别？</h3><p>1、java.util.Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。</p>
<p>List，Set，Queue接口都继承Collection。<br>直接实现该接口的类只有AbstractCollection类，该类也只是一个抽象类，提供了对集合类操作的一些基本实现。List和Set的具体实现类基本上都直接或间接的继承了该类。</p>
<p>2、java.util.Collections 是一个包装类。它包含有各种有关集合操作的静态方法（对集合的搜索、排序、线程安全化等），大多数方法都是用来处理线性表的。此类不能实例化，就像一个工具类，服务于Java的Collection框架。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionsTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ArrayList nums = <span class="keyword">new</span> ArrayList();</span><br><span class="line">		nums.add(<span class="number">8</span>);</span><br><span class="line">		nums.add(-<span class="number">3</span>);</span><br><span class="line">		nums.add(<span class="number">2</span>);</span><br><span class="line">		nums.add(<span class="number">9</span>);</span><br><span class="line">		nums.add(-<span class="number">2</span>);</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"集合是否为空："</span> + nums.isEmpty());</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"默认顺序："</span> + nums);</span><br><span class="line">		Collections.reverse(nums);</span><br><span class="line">		System.out.println(<span class="string">"反转后顺序："</span> + nums);</span><br><span class="line">		</span><br><span class="line">		Collections.sort(nums);</span><br><span class="line">		System.out.println(<span class="string">"排序后顺序："</span> + nums);</span><br><span class="line">		</span><br><span class="line">		Collections.shuffle(nums);</span><br><span class="line">		System.out.println(<span class="string">"混淆后顺序："</span> + nums);</span><br><span class="line">		<span class="comment">// 下面只是为了演示定制排序的用法，将int类型转成string进行比较</span></span><br><span class="line">		Collections.sort(nums, <span class="keyword">new</span> Comparator() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">				String s1 = String.valueOf(o1);</span><br><span class="line">				String s2 = String.valueOf(o2);</span><br><span class="line">				<span class="keyword">return</span> s1.compareTo(s2);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;);</span><br><span class="line">		System.out.println(<span class="string">"指定排序后顺序："</span> + nums);</span><br><span class="line">		System.out.println(<span class="string">"最大的值是："</span> + Collections.max(nums));</span><br><span class="line">		System.out.println(<span class="string">"最小的值是："</span> + Collections.min(nums));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="20-List、Set、Map-之间的区别是什么？"><a href="#20-List、Set、Map-之间的区别是什么？" class="headerlink" title="20.List、Set、Map 之间的区别是什么？"></a>20.List、Set、Map 之间的区别是什么？</h3><p><img src="https://img2018.cnblogs.com/other/1408183/201911/1408183-20191119184149559-1571595668.jpg" alt=""></p>
<ul>
<li>List：有序集合，元素可重复</li>
<li>Set：不重复集合，LinkedHashSet按照插入排序，SortedSet可排序，HashSet无序</li>
<li>Map：键值对集合，存储键、值和之间的映射；Key无序，唯一；value 不要求有序，允许重复</li>
</ul>
<h3 id="21-HashMap-和-Hashtable-有什么区别？"><a href="#21-HashMap-和-Hashtable-有什么区别？" class="headerlink" title="21.HashMap 和 Hashtable 有什么区别？"></a>21.HashMap 和 Hashtable 有什么区别？</h3><p>两者最主要的区别在于Hashtable是<a href="https://www.baidu.com/s?wd=%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">线程安全</a>，而HashMap则非<a href="https://www.baidu.com/s?wd=%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">线程安全</a>。</p>
<p>拓展资料：</p>
<p>Hashtable的实现方法里面都添加了synchronized关键字来确保线程同步，因此相对而言HashMap性能会高一些，我们平时使用时若无特殊需求建议使用HashMap，在多线程环境下若使用HashMap需要使用Collections.synchronizedMap()方法来获取一个<a href="https://www.baidu.com/s?wd=%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">线程安全</a>的集合（Collections.synchronizedMap()实现原理是Collections定义了一个SynchronizedMap的内部类，这个类实现了<a href="https://www.baidu.com/s?wd=Map%E6%8E%A5%E5%8F%A3&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">Map接口</a>，在调用方法时使用synchronized来保证线程同步,当然了实际上操作的还是我们传入的HashMap实例，简单的说就是Collections.synchronizedMap方法帮我们在操作HashMap时自动添加了synchronized来实现线程同步，类似的其它Collections.synchronizedXX方法也是类似原理。</p>
<p>HashMap可以使用null作为key，不过建议还是尽量避免这样使用。HashMap以null作为key时，总是存储在table数组的第一个节点上。而Hashtable则不允许null作为key。</p>
<p>HashMap继承了AbstractMap，HashTable继承Dictionary抽象类，两者均实现<a href="https://www.baidu.com/s?wd=Map%E6%8E%A5%E5%8F%A3&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">Map接口</a>。</p>
<p>HashMap的初始容量为16，Hashtable初始容量为11，两者的填充因子默认都是0.75。</p>
<p>HashMap扩容时是当前容量翻倍即:capacity<em>2，Hashtable扩容时是容量翻倍+1即:capacity</em>2+1。</p>
<p>HashMap和Hashtable的底层实现都是数组+链表结构实现。</p>
<h3 id="22-如何决定使用-HashMap-还是-TreeMap？"><a href="#22-如何决定使用-HashMap-还是-TreeMap？" class="headerlink" title="22.如何决定使用 HashMap 还是 TreeMap？"></a>22.如何决定使用 HashMap 还是 TreeMap？</h3><p>介绍</p>
<p><code>TreeMap&lt;K,V&gt;</code>的Key值是要求实现<code>java.lang.Comparable</code>，所以迭代的时候TreeMap默认是按照Key值升序排序的；TreeMap的实现是基于红黑树结构。适用于按自然顺序或自定义顺序遍历键（key）。</p>
<p><code>HashMap&lt;K,V&gt;</code>的Key值实现散列<code>hashCode()</code>，分布是散列的、均匀的，不支持排序；数据结构主要是桶(数组)，链表或红黑树。适用于在Map中插入、删除和定位元素。</p>
<p>结论</p>
<p>如果你需要得到一个有序的结果时就应该使用TreeMap（因为HashMap中元素的排列顺序是不固定的）。除此之外，由于HashMap有更好的性能，所以大多不需要排序的时候我们会使用HashMap。</p>
<p>拓展</p>
<p><strong>1、HashMap 和 TreeMap 的实现</strong></p>
<p><strong>HashMap：</strong>基于哈希表实现。使用HashMap要求添加的键类明确定义了<code>hashCode()</code>和<code>equals()</code>[可以重写<code>hashCode()</code>和<code>equals()</code>]，为了优化HashMap空间的使用，您可以调优初始容量和负载因子。</p>
<ul>
<li>HashMap(): 构建一个空的哈希映像</li>
<li>HashMap(Map m): 构建一个哈希映像，并且添加映像m的所有映射</li>
<li>HashMap(int initialCapacity): 构建一个拥有特定容量的空的哈希映像</li>
<li>HashMap(int initialCapacity, float loadFactor): 构建一个拥有特定容量和加载因子的空的哈希映像</li>
</ul>
<p><strong>TreeMap：</strong>基于红黑树实现。TreeMap没有调优选项，因为该树总处于平衡状态。</p>
<ul>
<li>TreeMap()：构建一个空的映像树</li>
<li>TreeMap(Map m): 构建一个映像树，并且添加映像m中所有元素</li>
<li>TreeMap(Comparator c): 构建一个映像树，并且使用特定的比较器对关键字进行排序</li>
<li>TreeMap(SortedMap s): 构建一个映像树，添加映像树s中所有映射，并且使用与有序映像s相同的比较器排序</li>
</ul>
<p><strong>2、HashMap 和 TreeMap 都是非线程安全</strong></p>
<p>HashMap继承AbstractMap抽象类，TreeMap继承自SortedMap接口。</p>
<p><strong>AbstractMap抽象类：</strong>覆盖了equals()和hashCode()方法以确保两个相等映射返回相同的哈希码。如果两个映射大小相等、包含同样的键且每个键在这两个映射中对应的值都相同，则这两个映射相等。映射的哈希码是映射元素哈希码的总和，其中每个元素是Map.Entry接口的一个实现。因此，不论映射内部顺序如何，两个相等映射会报告相同的哈希码。</p>
<p><strong>SortedMap接口：</strong>它用来保持键的有序顺序。SortedMap接口为映像的视图(子集)，包括两个端点提供了访问方法。除了排序是作用于映射的键以外，处理SortedMap和处理SortedSet一样。添加到SortedMap实现类的元素必须实现Comparable接口，否则您必须给它的构造函数提供一个Comparator接口的实现。TreeMap类是它的唯一一个实现。</p>
<p><strong>3、TreeMap中默认是按照升序进行排序的，如何让他降序</strong></p>
<p>通过自定义的比较器来实现</p>
<p>定义一个比较器类，实现Comparator接口，重写compare方法，有两个参数，这两个参数通过调用compareTo进行比较，而compareTo默认规则是：</p>
<blockquote>
<ul>
<li>如果参数字符串等于此字符串，则返回 0 值；</li>
<li>如果此字符串小于字符串参数，则返回一个小于 0 的值；</li>
<li>如果此字符串大于字符串参数，则返回一个大于 0 的值。</li>
</ul>
</blockquote>
<p>自定义比较器时，在返回时多添加了个负号，就将比较的结果以相反的形式返回，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        String param1 = (String)o1;</span><br><span class="line">        String param2 = (String)o2;</span><br><span class="line">        <span class="keyword">return</span> -param1.compareTo(param2);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后，通过MyComparator类初始化一个比较器实例，将其作为参数传进TreeMap的构造方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyComparator comparator = <span class="keyword">new</span> MyComparator();</span><br><span class="line"></span><br><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> TreeMap&lt;String,String&gt;(comparator);</span><br></pre></td></tr></table></figure>

<p>这样，我们就可以使用自定义的比较器实现降序了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化自定义比较器</span></span><br><span class="line">        MyComparator comparator = <span class="keyword">new</span> MyComparator();</span><br><span class="line">        <span class="comment">//初始化一个map集合</span></span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> TreeMap&lt;String,String&gt;(comparator);</span><br><span class="line">        <span class="comment">//存入数据</span></span><br><span class="line">        map.put(<span class="string">"a"</span>, <span class="string">"a"</span>);</span><br><span class="line">        map.put(<span class="string">"b"</span>, <span class="string">"b"</span>);</span><br><span class="line">        map.put(<span class="string">"f"</span>, <span class="string">"f"</span>);</span><br><span class="line">        map.put(<span class="string">"d"</span>, <span class="string">"d"</span>);</span><br><span class="line">        map.put(<span class="string">"c"</span>, <span class="string">"c"</span>);</span><br><span class="line">        map.put(<span class="string">"g"</span>, <span class="string">"g"</span>);</span><br><span class="line">        <span class="comment">//遍历输出</span></span><br><span class="line">        Iterator iterator = map.keySet().iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            String key = (String)iterator.next();</span><br><span class="line">            System.out.println(map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">            String param1 = (String)o1;</span><br><span class="line">            String param2 = (String)o2;</span><br><span class="line">            <span class="keyword">return</span> -param1.compareTo(param2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="23-说一下-HashMap-的实现原理？"><a href="#23-说一下-HashMap-的实现原理？" class="headerlink" title="23.说一下 HashMap 的实现原理？"></a>23.说一下 HashMap 的实现原理？</h3><p>HashMap使用数组加链表实现。每个数组中储存着链表。</p>
<p>当使用put方法储存key-value键值对时，会先调用key的hashCode方法，得到此key经特定哈希运算后的值，然后将此值通过其他运算（？）得到一个值，将这个值与(length-1)做或操作(&amp;)，相当于对数组长度做取余操作。最终得到一个值作为此key在数组中的索引值，然后将key-value键值对储存进去。通过这种方法将储存的不同key-value键值对“散列”到数组的不同位置。</p>
<p>在储存的时候，如果索引位置尚无元素，那么直接储存。如果有元素，那么就调用此key的equals方法与原有的元素的Key进行比较。如果返回true，说明在这个equals定义的规则上，这两个Key相同，那么将原有的key保留，用新的value代替原来的value。如果返回false，那么就说明这两个key在equals定义的规则下是不同元素，那么就与此链表的下一个结点进行比较，知道最后一个结点都没有相同元素，再下一个是null的时候，就用头插法将此key-value添加到链表上。</p>
<p>HashMap对重复元素的处理方法是：key不变，value覆盖。</p>
<p>当使用get方法获取key对应的value时，会和储存key-value时用同样的方法，得到key在数组中的索引值，如果此索引值上没有元素，就返回null。如果此索引值上有元素，那么就拿此key的equals方法与此位置元素上的key进行比较，如果返回true。就返回此位置元素对应的value。如果返回false，就一直按链表往下比较，如果都是返回false，那么就返回null。</p>
<p>另外：HashMap在JDK1.8之后引入红黑树结构。HashMap是线程不安全的，线程安全的是CurrentHashMap，不过此集合在多线程下效率低。</p>
<h3 id="24-说一下-HashSet-的实现原理？"><a href="#24-说一下-HashSet-的实现原理？" class="headerlink" title="24.说一下 HashSet 的实现原理？"></a>24.说一下 HashSet 的实现原理？</h3><p>HashMap 的实现原理：<br>HashMap是基于Hash算法实现的，<br>我们通过put（key，value）存储数据，通过get（key）来获取数据</p>
<p>当传入key时，HashMap会根据Key.hashCode()计算出Hash值，根据Hash值将value保存在bucket里 ，。</p>
<p>当计算出相同的Hash值时，我们称之为Hash冲突，HashMap 的做法是用链表和红黑树存储相同Hash值的value，<br>当hash冲突的个数比较少时，使用链表存储，<br>否则使用红黑树。</p>
<p>HashSet 的实现原理：<br>HashSet是基于HashMap实现的，HashSet 底层使用HashMap来保存所有元素，<br>因此HashSet 的实现比较简单，相关HashSet 的操作，基本上都是直接调用底层HashMap的相关方法来完成，HashSet不允许有重复的值，并且元素是无序的</p>
<h3 id="25-ArrayList-和-LinkedList-的区别是什么？"><a href="#25-ArrayList-和-LinkedList-的区别是什么？" class="headerlink" title="25.ArrayList 和 LinkedList 的区别是什么？"></a>25.ArrayList 和 LinkedList 的区别是什么？</h3><p><strong>共性：</strong>ArrayList与LinkedList都是List接口的实现类，因此都实现了List的所有未实现的方法，只是实现的方式有所不同。</p>
<p><strong>区别：</strong>List接口的实现方式不同</p>
<p>ArrayList实现了List接口，以数组的方式来实现的，因此对于快速的随机取得对象的需求，使用ArrayList实现执行效率上会比较好。</p>
<p>LinkedList是采用链表的方式来实现List接口的，因此在进行insert和remove动作时效率要比ArrayList高。适合用来实现Stack(堆栈)与Queue(队列)。</p>
<p><img src="https://iknow-pic.cdn.bcebos.com/3ac79f3df8dcd1005a9d1b7c7f8b4710b9122f6e?x-bce-process=image/resize,m_lfit,w_600,h_800,limit_1" alt=""></p>
<h3 id="26-如何实现数组和-List-之间的转换？"><a href="#26-如何实现数组和-List-之间的转换？" class="headerlink" title="26.如何实现数组和 List 之间的转换？"></a>26.如何实现数组和 List 之间的转换？</h3><p><strong>数组转List</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> listtoArray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayToList</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//数组转list</span></span><br><span class="line">		String[] str=<span class="keyword">new</span> String[] &#123;<span class="string">"hello"</span>,<span class="string">"world"</span>&#125;;</span><br><span class="line">		<span class="comment">//方式一：使用for循环把数组元素加进list</span></span><br><span class="line">		List&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		<span class="keyword">for</span> (String string : str) &#123;</span><br><span class="line">			list.add(string);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(list);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//方式二：</span></span><br><span class="line">		List&lt;String&gt; list2=<span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(str));</span><br><span class="line">		System.out.println(list2);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//方式三：</span></span><br><span class="line">		<span class="comment">//同方法二一样使用了asList()方法。这不是最好的，</span></span><br><span class="line">		<span class="comment">//因为asList()返回的列表的大小是固定的。</span></span><br><span class="line">		<span class="comment">//事实上，返回的列表不是java.util.ArrayList类，而是定义在java.util.Arrays中一个私有静态类java.util.Arrays.ArrayList</span></span><br><span class="line">		<span class="comment">//我们知道ArrayList的实现本质上是一个数组，而asList()返回的列表是由原始数组支持的固定大小的列表。</span></span><br><span class="line">		<span class="comment">//这种情况下，如果添加或删除列表中的元素，程序会抛出异常UnsupportedOperationException。</span></span><br><span class="line">		<span class="comment">//java.util.Arrays.ArrayList类具有 set()，get()，contains()等方法，但是不具有添加add()或删除remove()方法,所以调用add()方法会报错。</span></span><br><span class="line">		List&lt;String&gt; list3 = Arrays.asList(str);</span><br><span class="line">		<span class="comment">//list3.remove(1);</span></span><br><span class="line">		<span class="comment">//boolean contains = list3.contains("s");</span></span><br><span class="line">		<span class="comment">//System.out.println(contains);</span></span><br><span class="line">		System.out.println(list3);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//方式四：使用Collections.addAll()</span></span><br><span class="line">		List&lt;String&gt; list4=<span class="keyword">new</span> ArrayList&lt;String&gt;(str.length);</span><br><span class="line">		Collections.addAll(list4, str);</span><br><span class="line">		System.out.println(list4);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//方式五：使用Stream中的Collector收集器</span></span><br><span class="line">		<span class="comment">//转换后的List 属于 java.util.ArrayList 能进行正常的增删查操作</span></span><br><span class="line">		List&lt;String&gt; list5=Stream.of(str).collect(Collectors.toList());</span><br><span class="line">		System.out.println(list5);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>List转数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> listtoArray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListToArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//list转数组</span></span><br><span class="line">		List&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		list.add(<span class="string">"hello"</span>);</span><br><span class="line">		list.add(<span class="string">"world"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//方式一：使用for循环</span></span><br><span class="line">		String[] str1=<span class="keyword">new</span> String[list.size()];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++) &#123;</span><br><span class="line">			str1[i]=list.get(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (String string : str1) &#123;</span><br><span class="line">			System.out.println(string);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//方式二：使用toArray()方法</span></span><br><span class="line">		<span class="comment">//list.toArray(T[]  a); 将list转化为你所需要类型的数组</span></span><br><span class="line">		String[] str2=list.toArray(<span class="keyword">new</span> String[list.size()]);</span><br><span class="line">		<span class="keyword">for</span> (String string : str2) &#123;</span><br><span class="line">			System.out.println(string);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//错误方式：易错   list.toArray()返回的是Object[]数组，怎么可以转型为String</span></span><br><span class="line">		<span class="comment">//ArrayList&lt;String&gt; list3=new ArrayList&lt;String&gt;();</span></span><br><span class="line">		<span class="comment">//String strings[]=(String [])list.toArray();</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="27-ArrayList-和-Vector-的区别是什么？"><a href="#27-ArrayList-和-Vector-的区别是什么？" class="headerlink" title="27.ArrayList 和 Vector 的区别是什么？"></a>27.ArrayList 和 Vector 的区别是什么？</h3><p>Vector和ArrayList在使用上非常相似,都可用来表示一组数量可变的对象应用的集合,并且可以随机地访问其中的元素。<br>1 Vector的方法都是同步的(Synchronized),是<a href="https://www.baidu.com/s?wd=%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">线程安全</a>的(thread-safe)，而ArrayList的方法不是，由于线程的同步必然要影响性能，因此,ArrayList的性能比Vector好。<br>2 当Vector或ArrayList中的元素超过它的初始大小时,Vector会将它的容量翻倍,而ArrayList只增加50%的大小，这样,ArrayList就有利于节约内存空间。</p>
<h3 id="28-Array-和-ArrayList-有何区别？"><a href="#28-Array-和-ArrayList-有何区别？" class="headerlink" title="28.Array 和 ArrayList 有何区别？"></a>28.Array 和 ArrayList 有何区别？</h3><p>一、Array和ArrayList的区别</p>
<ol>
<li>Array类型的变量在声明的同时必须进行实例化(至少得初始化数组的大小)，而ArrayList可以只是先声明。<br>如：<br>int[] array = new array[3];<br>或 int[] array = {1,2,3};<br>或 ArrayList myList = new ArrayList();<br>这些都是合法的，而直接使用 int[] array;是不行的。</li>
<li>Array只能存储同构的对象，而ArrayList可以存储异构的对象。<br>同构的对象是指类型相同的对象，若声明为int[]的数组就只能存放整形数据,string[]只能存放字符型数据,但声明为object[]的数组除外。<br>而ArrayList可以存放任何不同类型的数据（因为它里面存放的都是被装箱了的Object型对象，实际上ArrayList内部就是使用”object[] _items;”这样一个私有字段来封装对象的）</li>
<li>在CLR托管对中的存放方式<br>Array是始终是连续存放的，而ArrayList的存放不一定连续。</li>
<li>初始化大小<br>Array对象的初始化必须只定指定大小，且创建后的数组大小是固定的，而ArrayList的大小可以动态指定，其大小可以在初始化时指定，也可以不指定，也就是说该对象的空间可以任意增加。</li>
<li>Array不能够随意添加和删除其中的项，而ArrayList可以在任意位置插入和删除项。</li>
</ol>
<p>二、Array和ArrayList的相似点</p>
<ol>
<li>都具有索引(index),即可以通过index来直接获取和修改任意项。</li>
<li>他们所创建的对象都放在托管堆中。</li>
<li>都能够对自身进行枚举(因为都实现了IEnumerable接口)。</li>
</ol>
<p>注：<br>在C#2.0中，建议大家尽量使用范型版的ArrayList，即System.Collection.Generics命名空间下的List<T>，这样不但保证了类型安全，而且由于没有了装箱和拆箱的过程，从而提高了对象处理的效率。</p>
<h3 id="29-在-Queue-中-poll-和-remove-有什么区别？"><a href="#29-在-Queue-中-poll-和-remove-有什么区别？" class="headerlink" title="29.在 Queue 中 poll()和 remove()有什么区别？"></a>29.在 Queue 中 poll()和 remove()有什么区别？</h3><p>remove() ，如果队列为空的时候，则会抛出异常,而poll（）只会返回null</p>
<h3 id="30-哪些集合类是线程安全的？"><a href="#30-哪些集合类是线程安全的？" class="headerlink" title="30.哪些集合类是线程安全的？"></a>30.哪些集合类是线程安全的？</h3><p>早在jdk的1.1版本中，所有的集合都是线程安全的。但是在1.2以及之后的版本中就出现了一些线程不安全的集合，为什么版本升级会出现一些线程不安全的集合呢？因为线程不安全的集合普遍比线程安全的集合效率高的多。随着业务的发展，特别是在web应用中，为了提高用户体验减少用户的等待时间，页面响应速度(也就是效率)是优先考虑的。而且对线程不安全的集合加锁以后也能达到安全的效果(但是效率会低，因为会有锁的获取以及等待)。其实在jdk源码中相同效果的集合线程安全的比线程不安全的就多了一个同步机制，但是效率上却低了不止一点点，因为效率低，所以已经不太建议使用了。下面举一些常用的功能相同却线程安全和不安全的集合。</p>
<p>Vector：就比Arraylist多了个同步化机制（线程安全）。</p>
<p>Hashtable：就比Hashmap多了个线程安全。</p>
<p>ConcurrentHashMap:是一种高效但是线程安全的集合。</p>
<p>Stack：栈，也是线程安全的，继承于Vector。</p>
<h3 id="31-迭代器-Iterator-是什么？"><a href="#31-迭代器-Iterator-是什么？" class="headerlink" title="31.迭代器 Iterator 是什么？"></a>31.迭代器 Iterator 是什么？</h3><p>为了方便的处理集合中的元素,Java中出现了一个对象,该对象提供了一些方法专门处理集合中的元素.例如删除和获取集合中的元素.该对象就叫做迭代器(Iterator).</p>
<p>对 Collection 进行迭代的类，称其为迭代器。还是面向对象的思想，专业对象做专业的事情，迭代器就是专门取出集合元素的对象。但是该对象比较特殊，不能直接创建对象（通过new），该对象是以内部类的形式存在于每个集合类的内部。</p>
<p>如何获取迭代器？Collection接口中定义了获取集合类迭代器的方法（iterator（）），所以所有的Collection体系集合都可以获取自身的迭代器。</p>
<p>1.Iterable</p>
<p>正是由于每一个容器都有取出元素的功能。这些功能定义都一样，只不过实现的具体方式不同（因为每一个容器的数据结构不一样）所以对共性的取出功能进行了抽取，从而出现了Iterator接口。而每一个容器都在其内部对该接口进行了内部类的实现。也就是将取出方式的细节进行封装。</p>
<h3 id="32-Iterator-怎么使用？有什么特点？"><a href="#32-Iterator-怎么使用？有什么特点？" class="headerlink" title="32.Iterator 怎么使用？有什么特点？"></a>32.Iterator 怎么使用？有什么特点？</h3><p><strong>Iterator 接口源码中的方法</strong></p>
<ul>
<li>java.lang.Iterable 接口被 java.util.Collection 接口继承，java.util.Collection 接口的 iterator() 方法返回一个 Iterator 对象</li>
<li>next() 方法获得集合中的下一个元素</li>
<li>hasNext() 检查集合中是否还有元素</li>
<li>remove() 方法将迭代器新返回的元素删除</li>
<li>forEachRemaining(Consumer&lt;? super E&gt; action) 方法，遍历所有元素</li>
</ul>
<p>JDK 1.8 源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是否有下一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//下一个元素</span></span><br><span class="line"><span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//从迭代器指向的集合中删除迭代器返回的最后一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"remove"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//遍历所有元素</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">while</span> (hasNext())</span><br><span class="line">        action.accept(next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Iterator 的使用示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestIterator</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        list.add(<span class="string">"111"</span>);</span><br><span class="line">        list.add(<span class="string">"222"</span>);</span><br><span class="line">        list.add(<span class="string">"333"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testIteratorNext();</span><br><span class="line">        System.out.println();</span><br><span class="line">        </span><br><span class="line">        testForEachRemaining();</span><br><span class="line">        System.out.println();</span><br><span class="line">        </span><br><span class="line">        testIteratorRemove();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用 hasNext 和 next遍历 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testIteratorNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            String str = iterator.next();</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用 Iterator 删除元素 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testIteratorRemove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            String str = iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"222"</span>.equals(str)) &#123;</span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用 forEachRemaining 遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testForEachRemaining</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">        iterator.forEachRemaining(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String t)</span> </span>&#123;</span><br><span class="line">                System.out.println(t);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong></p>
<ul>
<li>在迭代过程中调用集合的 remove(Object o) 可能会报 java.util.ConcurrentModificationException 异常</li>
<li>forEachRemaining 方法中 调用Iterator 的 remove 方法会报 java.lang.IllegalStateException 异常</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用迭代器遍历元素过程中，调用集合的 remove(Object obj) 方法可能会报 java.util.ConcurrentModificationException 异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testListRevome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         ArrayList&lt;String&gt; aList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">         aList.add(<span class="string">"111"</span>);</span><br><span class="line">         aList.add(<span class="string">"333"</span>);</span><br><span class="line">         aList.add(<span class="string">"222"</span>);</span><br><span class="line">         System.out.println(<span class="string">"移除前："</span>+aList);</span><br><span class="line">         </span><br><span class="line">         Iterator&lt;String&gt; iterator = aList.iterator();</span><br><span class="line">         <span class="keyword">while</span>(iterator.hasNext())</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">if</span>(<span class="string">"222"</span>.equals(iterator.next()))</span><br><span class="line">             &#123;</span><br><span class="line">                aList.remove(<span class="string">"222"</span>);          </span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.println(<span class="string">"移除后："</span>+aList);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//JDK 1.8 Iterator forEachRemaining 方法中 调用Iterator 的 remove 方法会报 java.lang.IllegalStateException 异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testForEachRemainingIteRemove</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">        iterator.forEachRemaining(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String t)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"222"</span>.equals(t)) &#123;</span><br><span class="line">                    iterator.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="33-Iterator-和-ListIterator-有什么区别？"><a href="#33-Iterator-和-ListIterator-有什么区别？" class="headerlink" title="33.Iterator 和 ListIterator 有什么区别？"></a>33.Iterator 和 ListIterator 有什么区别？</h3><p>我们在使用List,Set的时候，为了实现对其数据的遍历，我们经常使用到了Iterator(迭代器)。使用迭代器，你不需要干涉其遍历的过程，只需要每次取出一个你想要的数据进行处理就可以了。</p>
<p>但是在使用的时候也是有不同的。List和Set都有iterator()来取得其迭代器。对List来说，你也可以通过listIterator()取得其迭代器，两种迭代器在有些时候是不能通用的，Iterator和ListIterator主要区别在以下方面：</p>
<ol>
<li>ListIterator有add()方法，可以向List中添加对象，而Iterator不能</li>
<li>ListIterator和Iterator都有hasNext()和next()方法，可以实现顺序向后遍历，但是ListIterator有hasPrevious()和previous()方法，可以实现逆向（顺序向前）遍历。Iterator就不可以。</li>
<li>ListIterator可以定位当前的索引位置，nextIndex()和previousIndex()可以实现。Iterator没有此功能。</li>
<li>都可实现删除对象，但是ListIterator可以实现对象的修改，set()方法可以实现。Iierator仅能遍历，不能修改。</li>
</ol>
<p>因为ListIterator的这些功能，可以实现对LinkedList等List数据结构的操作。其实，数组对象也可以用迭代器来实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"> <span class="number">2</span> <span class="keyword">import</span> java.util.List;</span><br><span class="line"> <span class="number">3</span> <span class="keyword">import</span> java.util.ListIterator;</span><br><span class="line"> <span class="number">4</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestListIterator</span></span></span><br><span class="line"><span class="class"> 5 </span>&#123;</span><br><span class="line"> <span class="number">6</span>  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function"> 7  </span>&#123;</span><br><span class="line"> <span class="number">8</span>   TestListIterator tliterator=<span class="keyword">new</span> TestListIterator();</span><br><span class="line"> <span class="number">9</span>   List&lt;String&gt; list=<span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line"><span class="number">10</span>   tliterator.initial(list);<span class="comment">//初始化这个链接表</span></span><br><span class="line"><span class="number">11</span>   ListIterator&lt;String&gt;  li=list.listIterator();<span class="comment">//将该链接表转化为ListIterator</span></span><br><span class="line"><span class="number">12</span>   <span class="comment">//下面的代码进行ListIterator对象li的各种功能检测</span></span><br><span class="line"><span class="number">13</span>   <span class="comment">//顺序输出迭代器中的元素</span></span><br><span class="line"><span class="number">14</span>   <span class="keyword">while</span>(li.hasNext())</span><br><span class="line"><span class="number">15</span>   &#123;System.out.print(li.next().toString()+<span class="string">" "</span>);&#125;</span><br><span class="line"><span class="number">16</span>   <span class="comment">//验证add方法，给li添加两个元素</span></span><br><span class="line"><span class="number">17</span>   li.add(<span class="string">"元素五"</span>);</span><br><span class="line"><span class="number">18</span>   li.add(<span class="string">"元素六"</span>);</span><br><span class="line"><span class="number">19</span>   System.out.println();<span class="comment">//产生换行操作</span></span><br><span class="line"><span class="number">20</span>   <span class="comment">//通过使用ListIterator的特有方法hasPrevious与previous实现List的元素</span></span><br><span class="line"><span class="number">21</span>   <span class="comment">//逆序输出</span></span><br><span class="line"><span class="number">22</span>   <span class="keyword">for</span>(String str;li.hasPrevious();)</span><br><span class="line"><span class="number">23</span>   &#123;System.out.print(li.previous().toString()+<span class="string">" "</span>);&#125;</span><br><span class="line"><span class="number">24</span>   System.out.println();<span class="comment">//产生换行操作</span></span><br><span class="line"><span class="number">25</span>   <span class="comment">//顺序输出li迭代器中现有的元素</span></span><br><span class="line"><span class="number">26</span>   <span class="keyword">while</span>(li.hasNext())</span><br><span class="line"><span class="number">27</span>   &#123;System.out.print(li.next().toString()+<span class="string">" "</span>);&#125;</span><br><span class="line"><span class="number">28</span>   System.out.println();<span class="comment">//产生换行操作</span></span><br><span class="line"><span class="number">29</span>   <span class="comment">//通过使用ListIterator的set方法来改变li中的元素</span></span><br><span class="line"><span class="number">30</span>   <span class="keyword">for</span>(String str;li.hasPrevious();)</span><br><span class="line"><span class="number">31</span>   &#123;</span><br><span class="line"><span class="number">32</span>    str=li.previous().toString();</span><br><span class="line"><span class="number">33</span>    li.set(str.replaceAll(<span class="string">"元素"</span>,<span class="string">"元素编号"</span>));</span><br><span class="line"><span class="number">34</span>   &#125;</span><br><span class="line"><span class="number">35</span>   <span class="comment">//顺序输出li迭代器中现有的元素</span></span><br><span class="line"><span class="number">36</span>   <span class="keyword">while</span>(li.hasNext())</span><br><span class="line"><span class="number">37</span>   &#123;System.out.print(li.next().toString()+<span class="string">" "</span>);&#125;</span><br><span class="line"><span class="number">38</span>  </span><br><span class="line"><span class="number">39</span>  &#125;</span><br><span class="line"><span class="number">40</span>  <span class="comment">//初始化List方法</span></span><br><span class="line"><span class="number">41</span>  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initial</span><span class="params">(List&lt;String&gt; list)</span></span></span><br><span class="line"><span class="function">42  </span>&#123;</span><br><span class="line"><span class="number">43</span>   list.add(<span class="string">"元素一"</span>);</span><br><span class="line"><span class="number">44</span>   list.add(<span class="string">"元素二"</span>);</span><br><span class="line"><span class="number">45</span>   list.add(<span class="string">"元素三"</span>);</span><br><span class="line"><span class="number">46</span>   list.add(<span class="string">"元素四"</span>);</span><br><span class="line"><span class="number">47</span>  &#125;</span><br><span class="line"><span class="number">48</span> &#125;</span><br></pre></td></tr></table></figure>

<p>　Iterator模式是用于遍历集合类的标准访问方法。它可以把访问逻辑从不同类型的集合类中抽象出来，从而避免向客户端暴露集合的内部结构。</p>
<p>　　例如，如果没有使用Iterator，遍历一个数组的方法是使用索引：<br>        for(int i=0; i&lt;array.size(); i++) { … get(i) … }<br>    客户端都必须事先知道集合的内部结构，访问代码和集合本身是紧耦合，无法将访问逻辑从集合类和客户端代码中分离出来，每一种集合对应一种遍历方法，客户端代码无法复用。<br>　　更恐怖的是，如果以后需要把ArrayList更换为LinkedList，则原来的客户端代码必须全部重写。<br>为解决以上问题，Iterator模式总是用同一种逻辑来遍历集合：</p>
<p>​         for(Iterator it = c.iterater(); it.hasNext(); ) { … }</p>
<p>　　奥秘在于客户端自身不维护遍历集合的”指针”，所有的内部状态（如当前元素位置，是否有下一个元素）都由Iterator来维护，而这个Iterator由集合类通过工厂方法生成，因此，它知道如何遍历整个集合。</p>
<p>　　客户端从不直接和集合类打交道，它总是控制Iterator，向它发送”向前”，”向后”，”取当前元素”的命令，就可以间接遍历整个集合。</p>
<h3 id="34-怎么确保一个集合不能被修改？"><a href="#34-怎么确保一个集合不能被修改？" class="headerlink" title="34.怎么确保一个集合不能被修改？"></a>34.怎么确保一个集合不能被修改？</h3><p>我们很容易想到用final关键字进行修饰，我们都知道</p>
<p>final关键字可以修饰类，方法，成员变量，final修饰的类不能被继承，final修饰的方法不能被重写，final修饰的成员变量必须初始化值，如果这个成员变量是基本数据类型，表示这个变量的值是不可改变的，如果说这个成员变量是引用类型，则表示这个引用的地址值是不能改变的，但是这个引用所指向的对象里面的内容还是可以改变的<br>。</p>
<p>那么，我们怎么确保一个集合不能被修改？首先我们要清楚，集合（map,set,list…）都是引用类型，所以我们如果用final修饰的话，集合里面的内容还是可以修改的。</p>
<p>我们可以做一个实验：</p>
<p>可以看到：我们用final关键字定义了一个map集合，这时候我们往集合里面传值，第一个键值对1,1；我们再修改后，可以把键为1的值改为100，说明我们是可以修改map集合的值的。</p>
<p>那我们应该怎么做才能确保集合不被修改呢？<br>我们可以采用Collections包下的unmodifiableMap方法，通过这个方法返回的map,是不可以修改的。他会报 java.lang.UnsupportedOperationException错。</p>
<p>同理：Collections包也提供了对list和set集合的方法。<br>Collections.unmodifiableList(List)<br>Collections.unmodifiableSet(Set)</p>
<h2 id="三、多线程"><a href="#三、多线程" class="headerlink" title="三、多线程"></a>三、多线程</h2><h3 id="35-并行和并发有什么区别？"><a href="#35-并行和并发有什么区别？" class="headerlink" title="35.并行和并发有什么区别？"></a>35.并行和并发有什么区别？</h3><p>并发（concurrency）和并行（parallellism）是：</p>
<p>解释一：并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。<br>解释二：并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。<br>解释三：在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群<br>所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。</p>
<h3 id="36-线程和进程的区别？"><a href="#36-线程和进程的区别？" class="headerlink" title="36.线程和进程的区别？"></a>36.线程和进程的区别？</h3><p>1、首先是定义</p>
<p>进程：是执行中一段程序，即一旦程序被载入到内存中并准备执行，它就是一个进程。进程是表示资源分配的的基本概念，又是调度运行的基本单位，是系统中的并发执行的单位。</p>
<p>线程：单个进程中执行中每个任务就是一个线程。线程是进程中执行运算的最小单位。</p>
<p>2、一个线程只能属于一个进程，但是一个进程可以拥有多个线程。多线程处理就是允许一个进程中在同一时刻执行多个任务。</p>
<p>3、线程是一种轻量级的进程，与进程相比，线程给操作系统带来侧创建、维护、和管理的负担要轻，意味着线程的代价或开销比较小。</p>
<p>4、线程没有地址空间，线程包含在进程的地址空间中。线程上下文只包含一个堆栈、一个寄存器、一个优先权，线程文本包含在他的进程 的文本片段中，进程拥有的所有资源都属于线程。所有的线程共享进程的内存和资源。 同一进程中的多个线程共享代码段(代码和常量)，数据段(全局变量和静态变量)，扩展段(堆存储)。但是每个线程拥有自己的栈段， 寄存器的内容，栈段又叫运行时段，用来存放所有局部变量和临时变量。</p>
<p>5、父和子进程使用进程间通信机制，同一进程的线程通过读取和写入数据到进程变量来通信。</p>
<p>6、进程内的任何线程都被看做是同位体，且处于相同的级别。不管是哪个线程创建了哪一个线程，进程内的任何线程都可以销毁、挂起、恢复和更改其它线程的优先权。线程也要对进程施加控制，进程中任何线程都可以通过销毁主线程来销毁进程，销毁主线程将导致该进程的销毁，对主线程的修改可能影响所有的线程。 </p>
<p>7、子进程不对任何其他子进程施加控制，进程的线程可以对同一进程的其它线程施加控制。子进程不能对父进程施加控制，进程中所有线程都可以对主线程施加控制。 </p>
<p>相同点：进程和线程都有ID/寄存器组、状态和优先权、信息块，创建后都可更改自己的属性，都可与父进程共享资源、都不鞥直接访问其他无关进程或线程的资源。</p>
<h3 id="37-守护线程是什么？"><a href="#37-守护线程是什么？" class="headerlink" title="37.守护线程是什么？"></a>37.守护线程是什么？</h3><p>前言</p>
<p>守护线程（即daemon thread），是个服务线程，准确地来说就是服务其他的线程，这是它的作用——而其他的线程只有一种，那就是用户线程。所以java里线程分2种，<br>1、守护线程，比如垃圾回收线程，就是最典型的守护线程。<br>2、用户线程，就是应用程序里的自定义线程。</p>
<p>守护线程</p>
<p>1、守护线程，专门用于服务其他的线程，如果其他的线程（即用户自定义线程）都执行完毕，连main线程也执行完毕，那么jvm就会退出（即停止运行）——此时，连jvm都停止运行了，守护线程当然也就停止执行了。</p>
<p>2、再换一种说法，如果有用户自定义线程存在的话，jvm就不会退出——此时，守护线程也不能退出，也就是它还要运行，干嘛呢，就是为了执行垃圾回收的任务啊。</p>
<p>用户自定义线程</p>
<p>1、应用程序里的线程，一般都是用户自定义线程。<br>2、用户也可以在应用程序代码自定义守护线程，只需要调用Thread类的设置方法设置一下即可。</p>
<h3 id="38-创建线程有哪几种方式？"><a href="#38-创建线程有哪几种方式？" class="headerlink" title="38.创建线程有哪几种方式？"></a>38.创建线程有哪几种方式？</h3><p>1.继承Thread类型重写run 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemoTest</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"通过继承Thread类重写run方法实现接口！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ThreadDemoTest threadDemoTest = <span class="keyword">new</span> ThreadDemoTest();</span><br><span class="line">    threadDemoTest.run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.实现Runnable接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableDemoTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"实现Runnable开启线程！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RunnableDemoTest());</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.实现Callable接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemoTest</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"HelloCallable!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    CallableDemoTest callableDemoTest = <span class="keyword">new</span> CallableDemoTest();</span><br><span class="line">    FutureTask futureTask = <span class="keyword">new</span> FutureTask(callableDemoTest);</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">    thread.start();</span><br><span class="line">    <span class="comment">//获取返回值</span></span><br><span class="line">    futureTask.get();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="39-说一下-runnable-和-callable-有什么区别？"><a href="#39-说一下-runnable-和-callable-有什么区别？" class="headerlink" title="39.说一下 runnable 和 callable 有什么区别？"></a>39.说一下 runnable 和 callable 有什么区别？</h3><p>创建线程的四种方式<br>Java多线程实现方式主要有四种：继承Thread类、实现Runnable接口、实现Callable接口通过FutureTask包装器来创建Thread线程、使用ExecutorService、Callable、Future实现有返回结果的多线程。</p>
<p>其中前两种方式线程执行完后都没有返回值，后两种是带返回值的。</p>
<p>Runnable和Callable的区别<br>Runnable接口<br>public interface Runnable {<br>    void run();<br>}</p>
<p>Callable接口<br>public interface Callable<V> {<br>    V call() throws Exception;<br>}</p>
<p>Runnable和Callable的区别</p>
<p>Runnable执行方法是run(),Callable是call()<br>实现Runnable接口的任务线程无返回值；实现Callable接口的任务线程能返回执行结果<br>call方法可以抛出异常，run方法若有异常只能在内部消化<br>注意</p>
<p>Callable接口支持返回执行结果，需要调用FutureTask.get()方法实现，此方法会阻塞主线程直到获取结果；当不调用此方法时，主线程不会阻塞！<br>如果线程出现异常，Future.get()会抛出throws InterruptedException或者ExecutionException；如果线程已经取消，会爬出CancellationException</p>
<p>Runnable示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个定长的核心线程和最大线程数都是1的FixedThreadPool线程池</span></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">   Callable&lt;String&gt; callable = <span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            System.out.println(<span class="string">"Thread_current="</span>+Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Hello world"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(<span class="string">"start"</span>);</span><br><span class="line">    <span class="comment">// 执行任务并获取Future对象  </span></span><br><span class="line">    Future&lt;String&gt; future = executorService.submit(callable);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//future.get()线程结果，会阻塞当前线程直到线程结束</span></span><br><span class="line">        System.out.println(<span class="string">"future.get()="</span>+future.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"end"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭线程池  </span></span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其它<br>在程序开发中只要是多线程肯定永远以实现Runnable接口为主，因为实现Runnable接口相比继承Thread类有如下好处：</p>
<p>避免点继承的局限，一个类可以实现多个接口<br>资源共享<br>Runnable接口和Thread之间的联系</p>
<p>public class Thread extends Object implements Runnable<br>1<br>由此可见：Thread类也是Runnable接口的子类</p>
<h3 id="40-线程有哪些状态？"><a href="#40-线程有哪些状态？" class="headerlink" title="40.线程有哪些状态？"></a>40.线程有哪些状态？</h3><ol>
<li>线程 start 方法执行后，并不表示该线程运行了，而是进入就绪状态，意思是随时准备运行，但是真正何时运行，是由操作系统决定的，代码并不能控制，</li>
<li>同样的，从运行状态的线程，也可能由于失去了 CPU 资源，回到就绪状态，也是由操作系统决定的。这一步中，也可以由程序主动失去 CPU 资源，只需调用 yield 方法。</li>
<li>线程运行完毕，或者运行了一半异常了，或者主动调用线程的 stop 方法，那么就进入死亡。死亡的线程不可逆转。</li>
<li>下面几个行为，会引起线程阻塞。</li>
</ol>
<ul>
<li>主动调用 sleep 方法。时间到了会进入就绪状态</li>
<li>主动调用 suspend 方法。主动调用 resume 方法，会进入就绪状态</li>
<li>调用了阻塞式 IO 方法。调用完成后，会进入就绪状态。</li>
<li>试图获取锁。成功的获取锁之后，会进入就绪状态。</li>
<li>线程在等待某个通知。其它线程发出通知后，会进入就绪状态</li>
</ul>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-2073418/v4ln6xjzff.png?imageView2/2/w/1620" alt=""></p>
<h3 id="41-sleep-和-wait-有什么区别？"><a href="#41-sleep-和-wait-有什么区别？" class="headerlink" title="41.sleep() 和 wait() 有什么区别？"></a>41.sleep() 和 wait() 有什么区别？</h3><p>1、同步锁的对待不同：</p>
<p>sleep（）后，程序并不会不释放同步锁。</p>
<p>wait（）后，程序会释放同步锁。</p>
<p>2、用法的不同：</p>
<p>sleep（）可以用时间指定来使他自动醒过来。如果时间不到你只能调用interreput()来强行打断。</p>
<p>wait（）可以用notify()直接唤起。</p>
<p><img src="https://iknow-pic.cdn.bcebos.com/c83d70cf3bc79f3d7af9e37bb7a1cd11728b2964?x-bce-process=image/resize,m_lfit,w_600,h_800,limit_1" alt=""></p>
<p>3、属于不同的类：</p>
<p>sleep（）的类是Thread。</p>
<p>wait（）的类是Object。</p>
<h3 id="42-notify-和-notifyAll-有什么区别？"><a href="#42-notify-和-notifyAll-有什么区别？" class="headerlink" title="42.notify()和 notifyAll()有什么区别？"></a>42.notify()和 notifyAll()有什么区别？</h3><p>先说两个概念：锁池和等待池</p>
<ul>
<li>锁池:假设线程A已经拥有了某个对象(注意:不是类)的锁，而其它的线程想要调用这个对象的某个synchronized方法(或者synchronized块)，由于这些线程在进入对象的synchronized方法之前必须先获得该对象的锁的拥有权，但是该对象的锁目前正被线程A拥有，所以这些线程就进入了该对象的锁池中。</li>
<li>等待池:假设一个线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁后，进入到了该对象的等待池中</li>
</ul>
<p>然后再来说notify和notifyAll的区别</p>
<ul>
<li>如果线程调用了对象的 wait()方法，那么线程便会处于该对象的<strong>等待池</strong>中，等待池中的线程<strong>不会去竞争该对象的锁</strong>。</li>
<li>当有线程调用了对象的 <strong>notifyAll</strong>()方法（唤醒所有 wait 线程）或 <strong>notify</strong>()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争</li>
<li>优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它<strong>还会留在锁池中</strong>，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。</li>
</ul>
<p>所谓唤醒线程，另一种解释可以说是将线程由等待池移动到锁池，notifyAll调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而notify只会唤醒一个线程。</p>
<p>有了这些理论基础，后面的notify可能会导致死锁，而notifyAll则不会的例子也就好解释了</p>
<h3 id="43-线程的-run-和-start-有什么区别？"><a href="#43-线程的-run-和-start-有什么区别？" class="headerlink" title="43.线程的 run()和 start()有什么区别？"></a>43.线程的 run()和 start()有什么区别？</h3><p>Start:<br>用start方法来启动线程，真正实现了多线程运行，这时无需等待run方法体代码执行完毕而直接继续执行下面的代码。通过调用Thread类的start()方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到spu时间片，就开始执行run()方法，这里方法run()称为线程体，它包含了要执行的这个线程的内容，Run方法运行结束，此线程随即终止。<br>Run:<br>run()方法只是类的一个普通方法而已，如果直接调用Run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码，这样就没有达到写线程的目的。<br>总结：调用start方法方可启动线程，而run方法只是thread的一个普通方法调用，还是在主线程里执行。</p>
<h3 id="44-创建线程池有哪几种方式？"><a href="#44-创建线程池有哪几种方式？" class="headerlink" title="44.创建线程池有哪几种方式？"></a>44.创建线程池有哪几种方式？</h3><p>JDK1.8 创建线程池有哪几种方式？<br>newFixedThreadPool<br>定长线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程数量不再变化，当线程发生错误结束时，线程池会补充一个新的线程</p>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadPool</span> </span>&#123;</span><br><span class="line"><span class="comment">//定长线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程数量不再变化，当线程发生错误结束时，线程池会补充一个新的线程</span></span><br><span class="line"><span class="keyword">static</span> ExecutorService fixedExecutor = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>​    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	testFixedExecutor();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试定长线程池，线程池的容量为3，提交6个任务，根据打印结果可以看出先执行前3个任务，3个任务结束后再执行后面的任务</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testFixedExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">		fixedExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">" index:"</span> + index);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(<span class="string">"4秒后..."</span>);</span><br><span class="line">	</span><br><span class="line">	fixedExecutor.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">打印结果：</span><br><span class="line"></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> index:<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> index:<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> index:<span class="number">2</span></span><br><span class="line"><span class="number">4</span>秒后...</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> index:<span class="number">5</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> index:<span class="number">3</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> index:<span class="number">4</span></span><br></pre></td></tr></table></figure>



<p>newCachedThreadPool<br>可缓存的线程池，如果线程池的容量超过了任务数，自动回收空闲线程，任务增加时可以自动添加新线程，线程池的容量不限制</p>
<p>测试代码：  </p>
<p>public class TestThreadPool {</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;可缓存的线程池，如果线程池的容量超过了任务数，自动回收空闲线程，任务增加时可以自动添加新线程，线程池的容量不限制</span><br><span class="line">static ExecutorService cachedExecutor &#x3D; Executors.newCachedThreadPool();</span><br></pre></td></tr></table></figure>

<p>​    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	testCachedExecutor();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试可缓存线程池</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testCachedExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">		cachedExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">" index:"</span> + index);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(<span class="string">"4秒后..."</span>);</span><br><span class="line">	</span><br><span class="line">	cachedExecutor.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">打印结果：</span><br><span class="line"></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> index:<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span> index:<span class="number">5</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> index:<span class="number">4</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> index:<span class="number">3</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> index:<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> index:<span class="number">1</span></span><br><span class="line"><span class="number">4</span>秒后...</span><br></pre></td></tr></table></figure>



<p>newScheduledThreadPool<br>定长线程池，可执行周期性的任务</p>
<p>测试代码：</p>
<p>public class TestThreadPool {</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;定长线程池，可执行周期性的任务</span><br><span class="line">static ScheduledExecutorService scheduledExecutor &#x3D; Executors.newScheduledThreadPool(3);</span><br></pre></td></tr></table></figure>

<p>​    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	testScheduledExecutor();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试定长、可周期执行的线程池</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testScheduledExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">		<span class="comment">//scheduleWithFixedDelay 固定的延迟时间执行任务； scheduleAtFixedRate 固定的频率执行任务</span></span><br><span class="line">		scheduledExecutor.scheduleWithFixedDelay(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">" index:"</span> + index);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, <span class="number">0</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(<span class="string">"4秒后..."</span>);</span><br><span class="line">	</span><br><span class="line">	scheduledExecutor.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">打印结果：</span><br><span class="line"></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> index:<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> index:<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> index:<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> index:<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> index:<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> index:<span class="number">2</span></span><br><span class="line"><span class="number">4</span>秒后...</span><br></pre></td></tr></table></figure>





<p>newSingleThreadExecutor<br>单线程的线程池，线程异常结束，会创建一个新的线程，能确保任务按提交顺序执行</p>
<p>测试代码：</p>
<p>public class TestThreadPool {</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;单线程的线程池，线程异常结束，会创建一个新的线程，能确保任务按提交顺序执行</span><br><span class="line">static ExecutorService singleExecutor &#x3D; Executors.newSingleThreadExecutor();</span><br></pre></td></tr></table></figure>

<p>​    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	testSingleExecutor();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试单线程的线程池</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSingleExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">		singleExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">" index:"</span> + index);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(<span class="string">"4秒后..."</span>);</span><br><span class="line">	</span><br><span class="line">	singleExecutor.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">打印结果：</span><br><span class="line"></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> index:<span class="number">0</span></span><br><span class="line"><span class="number">4</span>秒后...</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> index:<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> index:<span class="number">2</span></span><br></pre></td></tr></table></figure>





<p>newSingleThreadScheduledExecutor<br>单线程可执行周期性任务的线程池</p>
<p>测试代码：</p>
<p>​    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadPool</span> </span>&#123;</span><br><span class="line"><span class="comment">//单线程可执行周期性任务的线程池</span></span><br><span class="line"><span class="keyword">static</span> ScheduledExecutorService singleScheduledExecutor = Executors.newSingleThreadScheduledExecutor();</span><br></pre></td></tr></table></figure>

<p>​    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	testSingleScheduledExecutor();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试单线程可周期执行的线程池</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSingleScheduledExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">		<span class="comment">//scheduleWithFixedDelay 固定的延迟时间执行任务； scheduleAtFixedRate 固定的频率执行任务</span></span><br><span class="line">		singleScheduledExecutor.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">" index:"</span> + index);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, <span class="number">0</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(<span class="string">"4秒后..."</span>);</span><br><span class="line">	</span><br><span class="line">	singleScheduledExecutor.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">打印结果：</span><br><span class="line"></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> index:<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> index:<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> index:<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> index:<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> index:<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> index:<span class="number">2</span></span><br><span class="line"><span class="number">4</span>秒后...</span><br></pre></td></tr></table></figure>



<p>newWorkStealingPool<br>任务窃取线程池，不保证执行顺序，适合任务耗时差异较大。</p>
<p>线程池中有多个线程队列，有的线程队列中有大量的比较耗时的任务堆积，而有的线程队列却是空的，就存在有的线程处于饥饿状态，当一个线程处于饥饿状态时，它就会去其它的线程队列中窃取任务。解决饥饿导致的效率问题。</p>
<p>默认创建的并行 level 是 CPU 的核数。主线程结束，即使线程池有任务也会立即停止。</p>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadPool</span> </span>&#123;</span><br><span class="line"><span class="comment">//任务窃取线程池</span></span><br><span class="line"><span class="keyword">static</span> ExecutorService workStealingExecutor = Executors.newWorkStealingPool();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	testWorkStealingExecutor();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试任务窃取线程池</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testWorkStealingExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;<span class="comment">//本机 CPU 8核，这里创建10个任务进行测试</span></span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">		workStealingExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">" index:"</span> + index);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Thread.sleep(<span class="number">4000</span>);<span class="comment">//这里主线程不休眠，不会有打印输出</span></span><br><span class="line">	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(<span class="string">"4秒后..."</span>);</span><br><span class="line">	<span class="comment">//		workStealingExecutor.shutdown();</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">打印结果如下，index:<span class="number">8</span>，index:<span class="number">9</span>并未打印出：</span><br><span class="line"></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">1</span> index:<span class="number">0</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">7</span> index:<span class="number">6</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">5</span> index:<span class="number">4</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">3</span> index:<span class="number">2</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">4</span> index:<span class="number">3</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">2</span> index:<span class="number">1</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">0</span> index:<span class="number">7</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">6</span> index:<span class="number">5</span></span><br><span class="line"><span class="number">4</span>秒后...</span><br></pre></td></tr></table></figure>





<h3 id="45-线程池都有哪些状态？"><a href="#45-线程池都有哪些状态？" class="headerlink" title="45.线程池都有哪些状态？"></a>45.线程池都有哪些状态？</h3><p>线程池的5种状态：Running、ShutDown、Stop、Tidying、Terminated。</p>
<p>线程池各个状态切换框架图：</p>
<p><img src="https://images.cnitblog.com/blog/497634/201401/08000847-0a9caed4d6914485b2f56048c668251a.jpg" alt=""></p>
<p>1、RUNNING</p>
<p>(1) 状态说明：线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行处理。<br>(02) 状态切换：线程池的初始化状态是RUNNING。换句话说，线程池被一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br></pre></td></tr></table></figure>



<p>2、 SHUTDOWN</p>
<p>(1) 状态说明：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。<br>(2) 状态切换：调用线程池的shutdown()接口时，线程池由RUNNING -&gt; SHUTDOWN。</p>
<p>3、STOP</p>
<p>(1) 状态说明：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。<br>(2) 状态切换：调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -&gt; STOP。</p>
<p>4、TIDYING</p>
<p>(1) 状态说明：当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；可以通过重载terminated()函数来实现。<br>(2) 状态切换：当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -&gt; TIDYING。<br>当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -&gt; TIDYING。</p>
<p>5、 TERMINATED</p>
<p>(1) 状态说明：线程池彻底终止，就变成TERMINATED状态。<br>(2) 状态切换：线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -&gt; TERMINATED</p>
<h3 id="46-线程池中-submit-和-execute-方法有什么区别？"><a href="#46-线程池中-submit-和-execute-方法有什么区别？" class="headerlink" title="46.线程池中 submit()和 execute()方法有什么区别？"></a>46.线程池中 submit()和 execute()方法有什么区别？</h3><p>线程池中的execute方法大家都不陌生，即开启线程执行池中的任务。还有一个方法submit也可以做到，它的功能是提交指定的任务去执行并且返回Future对象，即执行的结果。下面简要介绍一下两者的三个区别：</p>
<p>1、接收的参数不一样</p>
<p>2、submit有返回值，而execute没有</p>
<p>用到返回值的例子，比如说我有很多个做validation的task，我希望所有的task执行完，然后每个task告诉我它的执行结果，是成功还是失败，如果是失败，原因是什么。<br>然后我就可以把所有失败的原因综合起来发给调用者。</p>
<p>个人觉得cancel execution这个用处不大，很少有需要去取消执行的。</p>
<p>而最大的用处应该是第二点。<br>3、submit方便Exception处理<br>意思就是如果你在你的task里会抛出checked或者unchecked exception，<br>而你又希望外面的调用者能够感知这些exception并做出及时的处理，那么就需要用到submit，通过捕获Future.get抛出的异常。</p>
<p>下面一个小程序演示一下submit方法 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableTestMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService pool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         \* execute(Runnable x) 没有返回值。可以执行任务，但无法判断任务是否成功完成。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        pool.execute(<span class="keyword">new</span> RunnableTest(<span class="string">"Task1"</span>)); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         \* submit(Runnable x) 返回一个future。可以用这个future来判断任务是否成功完成。请看下面：</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Future future = pool.submit(<span class="keyword">new</span> RunnableTest(<span class="string">"Task2"</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(future.get()==<span class="keyword">null</span>)&#123;<span class="comment">//如果Future's get返回null，任务完成</span></span><br><span class="line">                System.out.println(<span class="string">"任务完成"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            <span class="comment">//否则我们可以看看任务失败的原因是什么</span></span><br><span class="line">            System.out.println(e.getCause().getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String taskName;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RunnableTest</span><span class="params">(<span class="keyword">final</span> String taskName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.taskName = taskName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Inside "</span>+taskName);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"RuntimeException from inside "</span> + taskName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="47-在-java-程序中怎么保证多线程的运行安全？"><a href="#47-在-java-程序中怎么保证多线程的运行安全？" class="headerlink" title="47.在 java 程序中怎么保证多线程的运行安全？"></a>47.在 java 程序中怎么保证多线程的运行安全？</h3><p>线程的安全性问题体现在：</p>
<p>原子性：一个或者多个操作在 CPU 执行的过程中不被中断的特性<br>可见性：一个线程对共享变量的修改，另外一个线程能够立刻看到<br>有序性：程序执行的顺序按照代码的先后顺序执行</p>
<p>导致原因：</p>
<p>缓存导致的可见性问题<br>线程切换带来的原子性问题<br>编译优化带来的有序性问题</p>
<p>解决办法：</p>
<p>JDK Atomic开头的原子类、synchronized、LOCK，可以解决原子性问题<br>synchronized、volatile、LOCK，可以解决可见性问题<br>Happens-Before 规则可以解决有序性问题</p>
<p>Happens-Before 规则如下：</p>
<p>程序次序规则：在一个线程内，按照程序控制流顺序，书写在前面的操作先行发生于书写在后面的操作<br>管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作<br>volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作<br>线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作<br>线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测<br>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生<br>对象终结规则：一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始</p>
<h3 id="48-多线程锁的升级原理是什么？"><a href="#48-多线程锁的升级原理是什么？" class="headerlink" title="48.多线程锁的升级原理是什么？"></a>48.多线程锁的升级原理是什么？</h3><p>锁的级别从低到高：</p>
<p>无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</p>
<p>锁分级别原因：</p>
<p>没有优化以前，sychronized是重量级锁（悲观锁），使用 wait 和 notify、notifyAll 来切换线程状态非常消耗系统资源；线程的挂起和唤醒间隔很短暂，这样很浪费资源，影响性能。所以 JVM 对 sychronized 关键字进行了优化，把锁分为 无锁、偏向锁、轻量级锁、重量级锁 状态。</p>
<p>无锁：没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功，其他修改失败的线程会不断重试直到修改成功。</p>
<p>偏向锁：对象的代码一直被同一线程执行，不存在多个线程竞争，该线程在后续的执行中自动获取锁，降低获取锁带来的性能开销。偏向锁，指的就是偏向第一个加锁线程，该线程是不会主动释放偏向锁的，只有当其他线程尝试竞争偏向锁才会被释放。</p>
<p>偏向锁的撤销，需要在某个时间点上没有字节码正在执行时，先暂停拥有偏向锁的线程，然后判断锁对象是否处于被锁定状态。如果线程不处于活动状态，则将对象头设置成无锁状态，并撤销偏向锁；</p>
<p>如果线程处于活动状态，升级为轻量级锁的状态。</p>
<p>轻量级锁：轻量级锁是指当锁是偏向锁的时候，被第二个线程 B 所访问，此时偏向锁就会升级为轻量级锁，线程 B 会通过自旋的形式尝试获取锁，线程不会阻塞，从而提高性能。</p>
<p>当前只有一个等待线程，则该线程将通过自旋进行等待。但是当自旋超过一定的次数时，轻量级锁便会升级为重量级锁；当一个线程已持有锁，另一个线程在自旋，而此时又有第三个线程来访时，轻量级锁也会升级为重量级锁。</p>
<p>重量级锁：指当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态。</p>
<p>重量级锁通过对象内部的监视器（monitor）实现，而其中 monitor 的本质是依赖于底层操作系统的 Mutex Lock 实现，操作系统实现线程之间的切换需要从用户态切换到内核态，切换成本非常高。</p>
<p>锁状态对比：</p>
<table border="1" cellspacing="0"><tbody><tr><td>
            <p>&nbsp;</p>
            </td>
            <td>
            <p>偏向锁</p>
            </td>
            <td>
            <p>轻量级锁</p>
            </td>
            <td>
            <p>重量级锁</p>
            </td>
        </tr><tr><td>
            <p>适用场景</p>
            </td>
            <td>
            <p>只有一个线程进入同步块</p>
            </td>
            <td>
            <p>虽然很多线程，但是没有冲突：多条线程进入同步块，但是线程进入时间错开因而并未争抢锁</p>
            </td>
            <td>
            <p>发生了锁争抢的情况：多条线程进入同步块并争用锁</p>
            </td>
        </tr><tr><td>
            <p>本质</p>
            </td>
            <td>
            <p>取消同步操作</p>
            </td>
            <td>
            <p>CAS操作代替互斥同步</p>
            </td>
            <td>
            <p>互斥同步</p>
            </td>
        </tr><tr><td>
            <p>优点</p>
            </td>
            <td>
            <p>不阻塞，执行效率高（只有第一次获取偏向锁时需要CAS操作，后面只是比对ThreadId）</p>
            </td>
            <td>
            <p>不会阻塞</p>
            </td>
            <td>
            <p>不会空耗CPU</p>
            </td>
        </tr><tr><td>
            <p>缺点</p>
            </td>
            <td>
            <p>适用场景太局限。若竞争产生，会有额外的偏向锁撤销的消耗</p>
            </td>
            <td>
            <p>长时间获取不到锁空耗CPU</p>
            </td>
            <td>
            <p>阻塞，上下文切换，重量级操作，消耗操作系统资源</p>
            </td>
        </tr></tbody></table>

<h3 id="49-什么是死锁？"><a href="#49-什么是死锁？" class="headerlink" title="49.什么是死锁？"></a>49.什么是死锁？</h3><p>什么是死锁？<br>所谓死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。<br>产生死锁的原因？<br>可归结为如下两点：</p>
<p>a. 竞争资源</p>
<p>系统中的资源可以分为两类：</p>
<ol>
<li>可剥夺资源，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU和主存均属于可剥夺性资源；</li>
<li>另一类资源是不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。</li>
</ol>
<p>产生死锁中的竞争资源之一指的是竞争不可剥夺资源（例如：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞）</p>
<p>产生死锁中的竞争资源另外一种资源指的是竞争临时资源（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁</p>
<p>b. 进程间推进顺序非法</p>
<p>若P1保持了资源R1,P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁</p>
<p>例如，当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁</p>
<p>死锁产生的4个必要条件？<br>产生死锁的必要条件：</p>
<p>互斥条件<br>请求和保持条件<br>不剥夺条件<br>环路等待条件。</p>
<h3 id="50-怎么防止死锁？"><a href="#50-怎么防止死锁？" class="headerlink" title="50.怎么防止死锁？"></a>50.怎么防止死锁？</h3><p>死锁的四个必要条件：</p>
<p>互斥条件：线程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个线程所占有。此时若有其他线程请求该资源，则请求线程只能等待。<br>不剥夺条件：线程所获得的资源在未使用完毕之前，不能被其他线程强行夺走，即只能由获得该资源的线程自己主动释放。<br>请求和保持条件：线程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他线程占有，此时请求线程被阻塞，但对自己已获得的资源保持不放。<br>循环等待条件：存在一种线程资源的循环等待链，链中每一个线程已获得的资源同时被链中下一个线程所请求。即存在一个处于等待状态的线程集合{Pl, P2, …, pn}，其中Pi等待的资源被P(i+1)占有（i=0, 1, …, n-1)，Pn等待的资源被P0占有<br>避免死锁的方式：</p>
<p>加锁顺序（线程按照一定的顺序加锁）<br>加锁时限（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁）<br>死锁检测</p>
<h3 id="51-ThreadLocal-是什么？有哪些使用场景？"><a href="#51-ThreadLocal-是什么？有哪些使用场景？" class="headerlink" title="51.ThreadLocal 是什么？有哪些使用场景？"></a>51.ThreadLocal 是什么？有哪些使用场景？</h3><p>什么是ThreadLocal？</p>
<p>　　ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javaBase.LineDistance;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 〈一句话功能简述〉;</span></span><br><span class="line"><span class="comment"> * 〈功能详细描述〉</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jxx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> [相关类/方法]（可选）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> [产品/模块版本] （可选）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadLocal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ThreadLocal&lt;Integer&gt; threadLocal = <span class="keyword">new</span> MyThreadLocal();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                    threadLocal.set(threadLocal.get() + <span class="number">1</span>);</span><br><span class="line">                    System.out.println(<span class="string">"线程1："</span> + threadLocal.get());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                    threadLocal.set(threadLocal.get() + <span class="number">1</span>);</span><br><span class="line">                    System.out.println(<span class="string">"线程2："</span> + threadLocal.get());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                    threadLocal.set(threadLocal.get() + <span class="number">1</span>);</span><br><span class="line">                    System.out.println(<span class="string">"线程3："</span> + threadLocal.get());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadLocal</span> <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Integer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">执行结果：</span><br><span class="line">线程<span class="number">2</span>：<span class="number">1</span></span><br><span class="line">线程<span class="number">1</span>：<span class="number">1</span></span><br><span class="line">线程<span class="number">2</span>：<span class="number">2</span></span><br><span class="line">线程<span class="number">3</span>：<span class="number">1</span></span><br><span class="line">线程<span class="number">1</span>：<span class="number">2</span></span><br><span class="line">线程<span class="number">3</span>：<span class="number">2</span></span><br><span class="line">线程<span class="number">2</span>：<span class="number">3</span></span><br><span class="line">线程<span class="number">3</span>：<span class="number">3</span></span><br><span class="line">线程<span class="number">1</span>：<span class="number">3</span></span><br></pre></td></tr></table></figure>



<p>有结果可知个线程之间对ThreadLocal的操作互不影响。</p>
<p><strong>ThreadLocal原理</strong></p>
<p>ThreadLocal中的几个主要方法：</p>
<ul>
<li>void set(Object value)设置当前线程的线程局部变量的值。</li>
<li>public Object get()该方法返回当前线程所对应的线程局部变量。</li>
<li>public void remove()将当前线程局部变量的值删除，目的是为了减少内存的占用，该方法是JDK 5.0新增的方法。需要指出的是，当线程结束后，对应该线程的局部变量将自动被垃圾回收，所以显式调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存回收的速度。</li>
<li>protected Object initialValue()返回该线程局部变量的初始值，该方法是一个protected的方法，显然是为了让子类覆盖而设计的。这个方法是一个延迟调用方法，在线程第1次调用get()或set(Object)时才执行，并且仅执行1次。ThreadLocal中的缺省实现直接返回一个null。</li>
</ul>
<p>get和set方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value in the current thread's copy of this</span></span><br><span class="line"><span class="comment">     * thread-local variable.  If the variable has no value for the</span></span><br><span class="line"><span class="comment">     * current thread, it is first initialized to the value returned</span></span><br><span class="line"><span class="comment">     * by an invocation of the &#123;<span class="doctag">@link</span> #initialValue&#125; method.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the current thread's value of this thread-local</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                T result = (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the current thread's copy of this thread-local variable</span></span><br><span class="line"><span class="comment">     * to the specified value.  Most subclasses will have no need to</span></span><br><span class="line"><span class="comment">     * override this method, relying solely on the &#123;<span class="doctag">@link</span> #initialValue&#125;</span></span><br><span class="line"><span class="comment">     * method to set the values of thread-locals.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the value to be stored in the current thread's copy of</span></span><br><span class="line"><span class="comment">     *        this thread-local.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>　　线程隔离的秘密，就在于ThreadLocalMap这个类。ThreadLocalMap是ThreadLocal类的一个静态内部类，它实现了键值对的设置和获取（对比Map对象来理解），每个线程中都有一个独立的ThreadLocalMap副本，它所存储的值，只能被当前线程读取和修改。ThreadLocal类通过操作每一个线程特有的ThreadLocalMap副本，从而实现了变量访问在不同线程中的隔离。因为每个线程的变量都是自己特有的，完全不会有并发错误。还有一点就是，ThreadLocalMap存储的键值对中的键是this对象指向的ThreadLocal对象，而值就是你所设置的对象了。</p>
<p>ThreadLocal的应用场景</p>
<p>1、方便同一个线程使用某一对象，避免不必要的参数传递；<br>2、线程间数据隔离（每个线程在自己线程里使用自己的局部变量，各线程间的ThreadLocal对象互不影响）；<br>3、获取数据库连接、Session、关联ID（比如日志的uniqueID，方便串起多个日志）；<br>其中spring中的事务管理器就是使用的ThreadLocal：<br>　　Spring的事务管理器通过AOP切入业务代码，在进入业务代码前，会依据相应的事务管理器提取出相应的事务对象，假如事务管理器是DataSourceTransactionManager，<br>就会从DataSource中获取一个连接对象，通过一定的包装后将其保存在ThreadLocal中。而且Spring也将DataSource进行了包装，重写了当中的getConnection()方法，或者说<br>该方法的返回将由Spring来控制，这样Spring就能让线程内多次获取到的Connection对象是同一个。</p>
<h3 id="52-说一下-synchronized-底层实现原理？"><a href="#52-说一下-synchronized-底层实现原理？" class="headerlink" title="52.说一下 synchronized 底层实现原理？"></a>52.说一下 synchronized 底层实现原理？</h3><p>一、概述<br>1、synchronized作用</p>
<p>原子性：synchronized保证语句块内操作是原子的<br>可见性：synchronized保证可见性（通过“在执行unlock之前，必须先把此变量同步回主内存”实现）<br>有序性：synchronized保证有序性（通过“一个变量在同一时刻只允许一条线程对其进行lock操作”）<br>2、synchronized的使用</p>
<p>修饰实例方法，对当前实例对象加锁<br>修饰静态方法，多当前类的Class对象加锁<br>修饰代码块，对synchronized括号内的对象加锁<br>二、实现原理</p>
<p>1、jvm基于进入和退出Monitor对象来实现方法同步和代码块同步。</p>
<p>方法级的同步是隐式，即无需通过字节码指令来控制的，它实现在方法调用和返回操作之中。JVM可以从方法常量池中的方法表结构(method_info Structure) 中的 ACC_SYNCHRONIZED 访问标志区分一个方法是否同步方法。当方法调用时，调用指令将会 检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先持有monitor（虚拟机规范中用的是管程一词）， 然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放monitor。</p>
<p>代码块的同步是利用monitorenter和monitorexit这两个字节码指令。它们分别位于同步代码块的开始和结束位置。当jvm执行到monitorenter指令时，当前线程试图获取monitor对象的所有权，如果未加锁或者已经被当前线程所持有，就把锁的计数器+1；当执行monitorexit指令时，锁计数器-1；当锁计数器为0时，该锁就被释放了。如果获取monitor对象失败，该线程则会进入阻塞状态，直到其他线程释放锁。</p>
<p>这里要注意：</p>
<p>synchronized是可重入的，所以不会自己把，自己锁死<br>synchronized锁一旦被一个线程持有，其他试图获取该锁的线程将被阻塞。<br>关于ACC_SYNCHRONIZED 、monitorenter、monitorexit指令，可以看一下下面的反编译代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;    <span class="comment">//这个是同步方法</span></span><br><span class="line">        System.out.println(<span class="string">"Hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;		<span class="comment">//这个是同步代码块</span></span><br><span class="line">            System.out.println(<span class="string">"Hello world"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用javap -verbose SynchronizedDemo反编译后得到</p>
<p><img src="https://img-blog.csdnimg.cn/20190310221443337.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODQ4MTk2Mw==,size_16,color_FFFFFF,t_70" alt=""></p>
<p><img src="https://img-blog.csdnimg.cn/20190311182248435.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODQ4MTk2Mw==,size_16,color_FFFFFF,t_70" alt=""></p>
<p>我们看到对于同步方法，反编译后得到ACC_SYNCHRONIZED 标志，对于同步代码块反编译后得到monitorenter和monitorexit指令。</p>
<p><strong>三、理解Java对象头</strong></p>
<p>在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。</p>
<p><img src="https://img-blog.csdnimg.cn/20190310224348833.jpg" alt=""></p>
<p>实例变量：存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐。</p>
<p>填充数据：由于虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。</p>
<p>HotSpot虚拟机的对象头分为两部分信息，第一部分用于存储对象自身运行时数据，如哈希码、GC分代年龄等，这部分数据的长度在32位和64位的虚拟机中分别为32位和64位。官方称为Mark Word。另一部分用于存储指向对象类型数据的指针，如果是数组对象的话，还会有一个额外的部分存储数组长度。</p>
<p>虚拟机位数    对象头结构    描述<br>32位/64位    Mark Word    存储对象的哈希码、GC分代年龄、锁信息等<br>32位/64位    Class MetaData Address    指向对象类型数据的指针<br>32位/64位    数组长度    如果是数组对象的话，有这一部分，否则没有<br>由于对象头的信息是与对象自身定义的数据没有关系的额外存储成本，因此考虑到JVM的空间效率，Mark Word 被设计成为一个非固定的数据结构，以便存储更多有效的数据，它会根据对象本身的状态复用自己的存储空间。<br><img src="https://img-blog.csdnimg.cn/20190310225911793.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODQ4MTk2Mw==,size_16,color_FFFFFF,t_70" alt=""></p>
<h3 id="53-synchronized-和-volatile-的区别是什么？"><a href="#53-synchronized-和-volatile-的区别是什么？" class="headerlink" title="53.synchronized 和 volatile 的区别是什么？"></a>53.synchronized 和 volatile 的区别是什么？</h3><p><strong>作用：</strong></p>
<ul>
<li>synchronized 表示只有一个线程可以获取作用对象的锁，执行代码，阻塞其他线程。</li>
<li>volatile 表示变量在 CPU 的寄存器中是不确定的，必须从主存中读取。保证多线程环境下变量的可见性；禁止指令重排序。</li>
</ul>
<p><strong>区别：</strong></p>
<ul>
<li>synchronized 可以作用于变量、方法、对象；volatile 只能作用于变量。</li>
<li>synchronized 可以保证线程间的有序性（猜测是无法保证线程内的有序性，即线程内的代码可能被 CPU 指令重排序）、原子性和可见性；volatile 只保证了可见性和有序性，无法保证原子性。</li>
<li>synchronized 线程阻塞，volatile 线程不阻塞</li>
</ul>
<h3 id="54-synchronized-和-Lock-有什么区别？"><a href="#54-synchronized-和-Lock-有什么区别？" class="headerlink" title="54.synchronized 和 Lock 有什么区别？"></a>54.synchronized 和 Lock 有什么区别？</h3><p><img src="https://img-blog.csdn.net/20180904143958577?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlZmVuZ2xpYW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>区别如下：</p>
<ol>
<li>来源：<br>lock是一个接口，而synchronized是java的一个关键字，synchronized是内置的语言实现；</li>
<li>异常是否释放锁：<br>synchronized在发生异常时候会自动释放占有的锁，因此不会出现死锁；而lock发生异常时候，不会主动释放占有的锁，必须手动unlock来释放锁，可能引起死锁的发生。（所以最好将同步代码块用try catch包起来，finally中写入unlock，避免死锁的发生。）</li>
<li>是否响应中断<br>lock等待锁过程中可以用interrupt来中断等待，而synchronized只能等待锁的释放，不能响应中断；</li>
<li>是否知道获取锁<br>Lock可以通过trylock来知道有没有获取锁，而synchronized不能；</li>
<li>Lock可以提高多个线程进行读操作的效率。（可以通过readwritelock实现读写分离）</li>
<li>在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。</li>
<li>synchronized使用Object对象本身的wait 、notify、notifyAll调度机制，而Lock可以使用Condition进行线程之间的调度，</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Condition定义了等待&#x2F;通知两种类型的方法</span><br><span class="line">Lock lock&#x3D;new ReentrantLock();</span><br><span class="line">Condition condition&#x3D;lock.newCondition();</span><br><span class="line">...</span><br><span class="line">condition.await();</span><br><span class="line">...</span><br><span class="line">condition.signal();</span><br><span class="line">condition.signalAll();12345678</span><br></pre></td></tr></table></figure>

<p>1、synchronized和lock的用法区别</p>
<p>synchronized：在需要同步的对象中加入此控制，synchronized可以加在方法上，也可以加在特定代码块中，括号中表示需要锁的对象。</p>
<p>lock：一般使用ReentrantLock类做为锁。在加锁和解锁处需要通过lock()和unlock()显示指出。所以一般会在finally块中写unlock()以防死锁。</p>
<p>2、synchronized和lock性能区别</p>
<p>synchronized是托管给JVM执行的，<br>而lock是java写的控制锁的代码。</p>
<p>在Java1.5中，synchronize是性能低效的。因为这是一个重量级操作，需要调用操作接口，导致有可能加锁消耗的系统时间比加锁以外的操作还多。相比之下使用Java提供的Lock对象，性能更高一些。</p>
<p>但是到了Java1.6，发生了变化。synchronize在语义上很清晰，可以进行很多优化，有适应自旋，锁消除，锁粗化，轻量级锁，偏向锁等等。导致在Java1.6上synchronize的性能并不比Lock差。官方也表示，他们也更支持synchronize，在未来的版本中还有优化余地。</p>
<p>2种机制的具体区别：<br><strong>synchronized原始采用的是CPU悲观锁机制，即线程获得的是独占锁。</strong>独占锁意味着其他线程只能依靠阻塞来等待线程释放锁。而在CPU转换线程阻塞时会引起线程上下文切换，当有很多线程竞争锁的时候，会引起CPU频繁的上下文切换导致效率很低。</p>
<p><strong>而Lock用的是乐观锁方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁实现的机制就是CAS操作</strong>（Compare and Swap）。我们可以进一步研究ReentrantLock的源代码，会发现其中比较重要的获得锁的一个方法是compareAndSetState。这里其实就是调用的CPU提供的特殊指令。</p>
<p>现代的CPU提供了指令，可以自动更新共享数据，而且能够检测到其他线程的干扰，而 compareAndSet() 就用这些代替了锁定。这个算法称作非阻塞算法，意思是一个线程的失败或者挂起不应该影响其他线程的失败或挂起的算法。</p>
<p>3、synchronized和lock用途区别</p>
<p>synchronized原语和ReentrantLock在一般情况下没有什么区别，但是在非常复杂的同步应用中，请考虑使用ReentrantLock，特别是遇到下面2种需求的时候。</p>
<p>1.某个线程在等待一个锁的控制权的这段时间需要中断<br>2.需要分开处理一些wait-notify，ReentrantLock里面的Condition应用，能够控制notify哪个线程<br>3.具有公平锁功能，每个到来的线程都将排队等候</p>
<p>下面细细道来……</p>
<p>先说第一种情况，ReentrantLock的lock机制有2种，忽略中断锁和响应中断锁，这给我们带来了很大的灵活性。比如：如果A、B 2个线程去竞争锁，A线程得到了锁，B线程等待，但是A线程这个时候实在有太多事情要处理，就是一直不返回，B线程可能就会等不及了，想中断自己，不再等待这个锁了，转而处理其他事情。这个时候<strong>ReentrantLock就提供了2种机制：可中断/可不中断</strong><br>第一，B线程中断自己（或者别的线程中断它），但是ReentrantLock不去响应，继续让B线程等待，你再怎么中断，我全当耳边风（synchronized原语就是如此）；<br>第二，B线程中断自己（或者别的线程中断它），ReentrantLock处理了这个中断，并且不再等待这个锁的到来，完全放弃。</p>
<h3 id="55-synchronized-和-ReentrantLock-区别是什么？"><a href="#55-synchronized-和-ReentrantLock-区别是什么？" class="headerlink" title="55.synchronized 和 ReentrantLock 区别是什么？"></a>55.synchronized 和 ReentrantLock 区别是什么？</h3><p>ReentrantLock是Lock的实现类，是一个互斥的同步器，在多线程高竞争条件下，ReentrantLock比synchronized有更加优异的性能表现。</p>
<p>1 用法比较<br>Lock使用起来比较灵活，但是必须有释放锁的配合动作；<br>Lock必须手动获取与释放锁，而synchronized不需要手动释放和开启锁；<br>Lock只适用于代码块锁，而synchronized可用于修饰方法、代码块等。<br>此外，reentrantlock有trylock 和lockinterruptly ，所以对锁的操作更灵活。从功能<br>的角度看，reentrantlock支持公平锁和非公平锁 而synchronized 仅支持非公平锁。</p>
<p>2 特性比较<br>ReentrantLock的优势体现在：</p>
<p>具备尝试非阻塞地获取锁的特性：当前线程尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁；<br>能被中断地获取锁的特性：与synchronized不同，获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放；<br>超时获取锁的特性：在指定的时间范围内获取锁；如果截止时间到了仍然无法获取锁，则返回。</p>
<p>3 注意事项<br>在使用ReentrantLock类的时，一定要注意三点：<br>在finally中释放锁，目的是保证在获取锁之后，最终能够被释放。<br>不要将获取锁的过程写在try块内，因为如果在获取锁时发生了异常，异常抛出的同时，也会导致锁无故被释放。<br>ReentrantLock提供了一个newCondition的方法，以便用户在同一锁的情况下可以根据不同<br>的情况执行等待或唤醒的动作。</p>
<h3 id="56-说一下-atomic-的原理？"><a href="#56-说一下-atomic-的原理？" class="headerlink" title="56.说一下 atomic 的原理？"></a>56.说一下 atomic 的原理？</h3><p>在讲atomic原子类之前先看一个小例子:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UseAtomic</span> &#123;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">       AtomicInteger atomicInteger=<span class="keyword">new</span> AtomicInteger();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            Thread t=<span class="keyword">new</span> Thread(<span class="keyword">new</span> AtomicTest(atomicInteger));</span><br><span class="line">            t.start();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               t.<span class="keyword">join</span>(<span class="number">0</span>);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">               </span><br><span class="line">       &#125;</span><br><span class="line">       System.<span class="keyword">out</span>.println(atomicInteger.<span class="keyword">get</span>());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">AtomicTest</span> <span class="title">implements</span> <span class="title">Runnable</span>&#123;</span><br><span class="line">   AtomicInteger atomicInteger;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">AtomicTest</span>(<span class="params">AtomicInteger atomicInteger</span>)</span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.atomicInteger=atomicInteger;</span><br><span class="line">   &#125;</span><br><span class="line">   @Override</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">       atomicInteger.addAndGet(<span class="number">1</span>);</span><br><span class="line">       atomicInteger.addAndGet(<span class="number">2</span>);</span><br><span class="line">       atomicInteger.addAndGet(<span class="number">3</span>);</span><br><span class="line">       atomicInteger.addAndGet(<span class="number">4</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终的输出结果为100，可见这个程序是线程安全的。如果把AtomicInteger换成变量i的话，那最终结果就不确定了。</p>
<p>打开AtomicInteger的源码可以看到:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> final Unsafe <span class="keyword">unsafe</span> = Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> <span class="keyword">value</span>;</span><br></pre></td></tr></table></figure>

<p>volatile关键字用来保证内存的可见性（但不能保证线程安全性），线程读的时候直接去主内存读，写操作完成的时候立即把数据刷新到主内存当中。</p>
<p>作者：zxin1</p>
<p>链接：<a href="https://www.jianshu.com/p/a2f3c46d4783" target="_blank" rel="noopener">https://www.jianshu.com/p/a2f3c46d4783</a></p>
<p>来源：简书</p>
<p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h2 id="四、反射"><a href="#四、反射" class="headerlink" title="四、反射"></a>四、反射</h2><h3 id="57-什么是反射？"><a href="#57-什么是反射？" class="headerlink" title="57.什么是反射？"></a>57.什么是反射？</h3><p>主要是指程序可以访问、检测和修改它本身状态或行为的一种能力</p>
<p>Java反射？</p>
<p>在Java运行时环境中，对于任意一个类，能否知道这个类有哪些属性和方法？对于任意一个对象，能否调用它的任意一个方法</p>
<p>Java反射机制主要提供了以下功能：</p>
<ul>
<li>1.在运行时判断任意一个对象所属的类。</li>
<li>2.在运行时构造任意一个类的对象。</li>
<li>3.在运行时判断任意一个类所具有的成员变量和方法。</li>
<li>4.在运行时调用任意一个对象的方法。 </li>
</ul>
<h3 id="58-什么是-java-序列化？什么情况下需要序列化？"><a href="#58-什么是-java-序列化？什么情况下需要序列化？" class="headerlink" title="58.什么是 java 序列化？什么情况下需要序列化？"></a>58.什么是 java 序列化？什么情况下需要序列化？</h3><p>序列化：将 Java 对象转换成字节流的过程。</p>
<p>反序列化：将字节流转换成 Java 对象的过程。</p>
<p>当 Java 对象需要在网络上传输 或者 持久化存储到文件中时，就需要对 Java 对象进行序列化处理。</p>
<p>序列化的实现：类实现 Serializable 接口，这个接口没有需要实现的方法。实现 Serializable 接口是为了告诉 jvm 这个类的对象可以被序列化。</p>
<p>注意事项：</p>
<p>某个类可以被序列化，则其子类也可以被序列化<br>声明为 static 和 transient 的成员变量，不能被序列化。static 成员变量是描述类级别的属性，transient 表示临时数据<br>反序列化读取序列化对象的顺序要保持一致</p>
<p>具体使用</p>
<ul>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> constxiong.interview;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 测试序列化，反序列化</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- <span class="doctag">@author</span> ConstXiong</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- <span class="doctag">@date</span> 2019-06-17 09:31:22</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSerializable</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5887391604554532906L</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TestSerializable</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">  	<span class="keyword">this</span>.id = id;</span><br><span class="line">  	<span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="string">"TestSerializable [id="</span> + id + <span class="string">", name="</span> + name + <span class="string">"]"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"resource"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">  	<span class="comment">//序列化</span></span><br><span class="line">  	ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"TestSerializable.obj"</span>));</span><br><span class="line">  	oos.writeObject(<span class="string">"测试序列化"</span>);</span><br><span class="line">  	oos.writeObject(<span class="number">618</span>);</span><br><span class="line">  	TestSerializable test = <span class="keyword">new</span> TestSerializable(<span class="number">1</span>, <span class="string">"ConstXiong"</span>);</span><br><span class="line">  	oos.writeObject(test);</span><br><span class="line"><span class="comment">//反序列化</span></span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"TestSerializable.obj"</span>));</span><br><span class="line">System.out.println((String)ois.readObject());</span><br><span class="line">System.out.println((Integer)ois.readObject());</span><br><span class="line">System.out.println((TestSerializable)ois.readObject());</span><br><span class="line"></span><br><span class="line">- &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">打印结果：</span><br><span class="line">测试序列化</span><br><span class="line"><span class="number">618</span></span><br><span class="line">TestSerializable [id=<span class="number">1</span>, name=ConstXiong]</span><br></pre></td></tr></table></figure>





</li>
</ul>
<h3 id="59-动态代理是什么？有哪些应用？"><a href="#59-动态代理是什么？有哪些应用？" class="headerlink" title="59.动态代理是什么？有哪些应用？"></a>59.动态代理是什么？有哪些应用？</h3><p>动态代理：当想要给实现了某个接口的类中的方法，加一些额外的处理。比如说加日志，加事务等。可以给这个类创建一个代理，故名思议就是创建一个新的类，这个类不仅包含原来类方法的功能，而且还在原来的基础上添加了额外处理的新类。这个代理类并不是定义好的，是动态生成的。具有解耦意义，灵活，扩展性强。</p>
<p>动态代理实现：首先必须定义一个接口，还要有一个InvocationHandler(将实现接口的类的对象传递给它)处理类。再有一个工具类Proxy(习惯性将其称为代理类，因为调用他的newInstance()可以产生代理对象,其实他只是一个产生代理对象的工具类）。利用到InvocationHandler，拼接代理类源码，将其编译生成代理类的二进制码，利用加载器加载，并将其实例化产生代理对象，最后返回。</p>
<p>动态代理的应用：Spring的AOP，加事务，加权限，加日志。应用场景如：</p>
<ul>
<li>统计每个 api 的请求耗时</li>
<li>统一的日志输出</li>
<li>校验被调用的 api 是否已经登录和权限鉴定</li>
<li>Spring的 AOP 功能模块就是采用动态代理的机制来实现切面编程</li>
</ul>
<h3 id="60-怎么实现动态代理？"><a href="#60-怎么实现动态代理？" class="headerlink" title="60.怎么实现动态代理？"></a>60.怎么实现动态代理？</h3><p><strong>Java领域中，常用的动态代理实现方式有两种，一种是利用JDK反射机制生成代理，另外一种是使用CGLIB代理。</strong></p>
<p><strong>JDK代理必须要提供接口，而CGLIB则不需要，可以直接代理类。下面分别举例说明。</strong></p>
<p><strong>1.JDK动态代理：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface People &#123;</span><br><span class="line">    public void sayHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Chinese implements People &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sayHello() &#123;</span><br><span class="line">        System.out.println(&quot;Chinese say hello.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class PeopleInvocationHandler implements InvocationHandler&#123;</span><br><span class="line">    </span><br><span class="line">    private Object peolple;</span><br><span class="line">    </span><br><span class="line">    Intermediary(Object people)&#123;</span><br><span class="line">        this.people &#x3D; people;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args)</span><br><span class="line">            throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">        Object invoke &#x3D; method.invoke(people, args);</span><br><span class="line">        System.out.println(&quot;-------- end ---------&quot;);</span><br><span class="line">        return invoke;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        People chinese &#x3D; new People();</span><br><span class="line">        PeopleInvocationHandler invocationHandler &#x3D; new PeopleInvocationHandler(chinese);</span><br><span class="line">        People proxy &#x3D; (People) Proxy.newProxyInstance(chinese.getClass().getClassLoader(), chinese.getClass().getInterfaces(), invocationHandler);</span><br><span class="line">        proxy.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>2.CGLIB动态代理</strong></p>
<p><strong>需要引入CGLIB相关Jar包</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Chinese &#123;</span><br><span class="line">    public void sayHello()&#123;</span><br><span class="line">        System.out.println(&quot;Chinese say hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">import net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line">import net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line">public class ChinesePoxy implements MethodInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object object, Method method, Object[] args,MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">        Object intercept &#x3D; methodProxy.invokeSuper(object, args);</span><br><span class="line">　　　　 System.out.println(&quot;-------- end ---------&quot;);</span><br><span class="line">　　　　return intercept; </span><br><span class="line">　　&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import net.sf.cglib.proxy.Enhancer;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ChineseProxy chineseProxy &#x3D; new ChineseProxy();</span><br><span class="line">        </span><br><span class="line">        Enhancer enhancer &#x3D; new Enhancer();  </span><br><span class="line">        enhancer.setSuperclass(Chinese.class);</span><br><span class="line">        enhancer.setCallback(chineseProxy);</span><br><span class="line">        </span><br><span class="line">        Chinese proxy &#x3D; (Chinese) enhancer.create();</span><br><span class="line">        proxy.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、对象拷贝"><a href="#五、对象拷贝" class="headerlink" title="五、对象拷贝"></a>五、对象拷贝</h2><h3 id="61-为什么要使用克隆？"><a href="#61-为什么要使用克隆？" class="headerlink" title="61.为什么要使用克隆？"></a>61.为什么要使用克隆？</h3><p>Google了下，发现这个是典型的先学C/C++后再学JAVA遇到的问题，原来在JAVA中默认的“=”赋值操作，其实是将一个引用复制过去了，二者指向的还是同一块内存</p>
<p>  例如：                 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> b=a;<span class="comment">//b得到的是a的引用</span></span><br><span class="line">System.out.println(<span class="string">"a的值是："</span>+a)；     </span><br><span class="line">System.out.println(<span class="string">"b的值是："</span>+b)；<span class="comment">//a和b的值应该相同</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line">b=<span class="number">5</span>；</span><br><span class="line">System.out.println(<span class="string">"a的值是："</span>+a)；     </span><br><span class="line">System.out.println(<span class="string">"b的值是："</span>+b)；</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 发现b&#x3D;5后，a的输出结果也变成5了。这就是因为我们在b&#x3D;a时传递给b的其实是a的引用，二者仍然指向同一块内存，所以改变了b也就自然改变了a；</span><br><span class="line"></span><br><span class="line">正因为JAVA的这种特性，所以当我们需要改变b时a的值不会变时，就需要调用clone方法了。</span><br><span class="line"></span><br><span class="line">clone()是JAVAobject类里面的一个protected型方法，要想调用clone()方法，必须先实现Cloneable接口，否则会抛出CloneNotSupportedException异常</span><br></pre></td></tr></table></figure>

<h3 id="62-如何实现对象克隆？"><a href="#62-如何实现对象克隆？" class="headerlink" title="62.如何实现对象克隆？"></a>62.如何实现对象克隆？</h3><p>在java中如果单单采用复制的方式是不行的，只会让A和B同时指向一个内存地址，互相影响。</p>
<p>解决：</p>
<p>1.实现Cloneable接口，并重写object类中的clone方法，可以实现浅克隆，也可以实现深度克隆。</p>
<p>2.实现Serializable，通过对象的序列化和反序列化实现克隆，可以实现真正的深克隆。</p>
<p>3.利用BeanUtils,apache和spring都提供了这个bean工具。只是他也是浅克隆。</p>
<p><strong>有两种方式：</strong><br><strong>1). 实现Cloneable接口并重写Object类中的clone()方法；</strong><br><strong>2). 实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="keyword">import</span>` `java.io.ByteArrayInputStream;``<span class="keyword">import</span>` `java.io.ByteArrayOutputStream;``<span class="keyword">import</span>` `java.io.ObjectInputStream;``<span class="keyword">import</span>` `java.io.ObjectOutputStream;` `<span class="keyword">public</span>` `<span class="class"><span class="keyword">class</span>` `<span class="title">MyUtil</span> </span>&#123;` `    ``<span class="keyword">private</span>` `MyUtil() &#123;``        ``<span class="keyword">throw</span>` `<span class="keyword">new</span>` `AssertionError();``    ``&#125;` `    ``<span class="keyword">public</span>` `<span class="keyword">static</span>` `&lt;T&gt; <span class="function">T <span class="title">clone</span><span class="params">(T obj)</span> ``<span class="keyword">throws</span>` `Exception </span>&#123;``        ``ByteArrayOutputStream bout = ``<span class="keyword">new</span>` `ByteArrayOutputStream();``        ``ObjectOutputStream oos = ``<span class="keyword">new</span>` `ObjectOutputStream(bout);``        ``oos.writeObject(obj);` `        ``ByteArrayInputStream bin = ``<span class="keyword">new</span>` `ByteArrayInputStream(bout.toByteArray());``        ``ObjectInputStream ois = ``<span class="keyword">new</span>` `ObjectInputStream(bin);``        ``<span class="keyword">return</span>` `(T) ois.readObject();` `        ``<span class="comment">// 说明：调用ByteArrayInputStream或ByteArrayOutputStream对象的close方法没有任何意义``        ``// 这两个基于内存的流只要垃圾回收器清理对象就能够释放资源，这一点不同于对外部资源（如文件流）的释放``    ``&#125;``&#125;`</span></span><br></pre></td></tr></table></figure>

<p><strong>下面是测试代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="keyword">import</span>` `java.io.Serializable;` `<span class="comment">/**`` ``* 人类`` ``* <span class="doctag">@author</span> `` ``*`` ``*/</span>``<span class="class"><span class="keyword">class</span>` `<span class="title">Person</span> ``<span class="keyword">implements</span>` `<span class="title">Serializable</span> </span>&#123;``    ``<span class="keyword">private</span>` `<span class="keyword">static</span>` `<span class="keyword">final</span>` `<span class="keyword">long</span>` `serialVersionUID = -<span class="number">9102017020286042305L</span>;` `    ``<span class="keyword">private</span>` `String name;    ``<span class="comment">// 姓名``    ``private` `int` `age;        ``// 年龄``    ``private` `Car car;        ``// 座驾` `    ``public` `Person(String name, ``int` `age, Car car) &#123;``        ``this``.name = name;``        ``this``.age = age;``        ``this``.car = car;``    ``&#125;` `    ``public` `String getName() &#123;``        ``return` `name;``    ``&#125;` `    ``public` `void` `setName(String name) &#123;``        ``this``.name = name;``    ``&#125;` `    ``public` `int` `getAge() &#123;``        ``return` `age;``    ``&#125;` `    ``public` `void` `setAge(``int` `age) &#123;``        ``this``.age = age;``    ``&#125;` `    ``public` `Car getCar() &#123;``        ``return` `car;``    ``&#125;` `    ``public` `void` `setCar(Car car) &#123;``        ``this``.car = car;``    ``&#125;` `    ``@Override``    ``public` `String toString() &#123;``        ``return` `"Person [name="` `+ name + ``", age="` `+ age + ``", car="` `+ car + ``"]"``;``    ``&#125;` `&#125;`</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="comment">/**`` ``* 小汽车类`` ``* <span class="doctag">@author</span> `` ``*`` ``*/</span>``<span class="class"><span class="keyword">class</span>` `<span class="title">Car</span> ``<span class="keyword">implements</span>` `<span class="title">Serializable</span> </span>&#123;``    ``<span class="keyword">private</span>` `<span class="keyword">static</span>` `<span class="keyword">final</span>` `<span class="keyword">long</span>` `serialVersionUID = -<span class="number">5713945027627603702L</span>;` `    ``<span class="keyword">private</span>` `String brand;       ``<span class="comment">// 品牌``    ``private` `int` `maxSpeed;       ``// 最高时速` `    ``public` `Car(String brand, ``int` `maxSpeed) &#123;``        ``this``.brand = brand;``        ``this``.maxSpeed = maxSpeed;``    ``&#125;` `    ``public` `String getBrand() &#123;``        ``return` `brand;``    ``&#125;` `    ``public` `void` `setBrand(String brand) &#123;``        ``this``.brand = brand;``    ``&#125;` `    ``public` `int` `getMaxSpeed() &#123;``        ``return` `maxSpeed;``    ``&#125;` `    ``public` `void` `setMaxSpeed(``int` `maxSpeed) &#123;``        ``this``.maxSpeed = maxSpeed;``    ``&#125;` `    ``@Override``    ``public` `String toString() &#123;``        ``return` `"Car [brand="` `+ brand + ``", maxSpeed="` `+ maxSpeed + ``"]"``;``    ``&#125;` `&#125;`</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="class"><span class="keyword">class</span>` `<span class="title">CloneTest</span> </span>&#123;` `    ``<span class="keyword">public</span>` `<span class="keyword">static</span>` `<span class="keyword">void</span>` `main(String[] args) &#123;``        ``<span class="keyword">try</span>` `&#123;``            ``Person p1 = ``<span class="keyword">new</span>` `Person(``<span class="string">"Hao LUO"</span>``, ``<span class="number">33</span>``, ``<span class="keyword">new</span>` `Car(``<span class="string">"Benz"</span>``, ``<span class="number">300</span>``));``            ``Person p2 = MyUtil.clone(p1);   ``<span class="comment">// 深度克隆``            ``p2.getCar().setBrand(``"BYD"``);``            ``// 修改克隆的Person对象p2关联的汽车对象的品牌属性``            ``// 原来的Person对象p1关联的汽车不会受到任何影响``            ``// 因为在克隆Person对象时其关联的汽车对象也被克隆了``            ``System.out.println(p1);``        ``&#125; ``catch` `(Exception e) &#123;``            ``e.printStackTrace();``        ``&#125;``    ``&#125;``&#125;`</span></span><br></pre></td></tr></table></figure>

<h3 id="63-深拷贝和浅拷贝区别是什么？"><a href="#63-深拷贝和浅拷贝区别是什么？" class="headerlink" title="63.深拷贝和浅拷贝区别是什么？"></a>63.深拷贝和浅拷贝区别是什么？</h3><p>浅拷贝与深拷贝</p>
<p>一、数据类型<br>数据分为基本数据类型(String, Number, Boolean, Null, Undefined，Symbol)和对象数据类型。</p>
<p>基本数据类型的特点：直接存储在栈(stack)中的数据<br>引用数据类型的特点：存储的是该对象在栈中引用，真实的数据存放在堆内存里</p>
<p>引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体.</p>
<p><img src="https://image-static.segmentfault.com/103/927/1039278453-5cb44799195cb_articlex" alt=""></p>
<p>二、浅拷贝与深拷贝<br>深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的。<br>深拷贝和浅拷贝的示意图大致如下：</p>
<p><img src="https://image-static.segmentfault.com/348/335/3483357010-5cb447fba09cc_articlex" alt=""></p>
<p>浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。<br>三、赋值和浅拷贝的区别<br>当我们把一个对象赋值给一个新的变量时，赋的其实是该对象的在栈中的地址，而不是堆中的数据。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。<br>浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。即默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝)，即只复制对象空间而不复制资源。</p>
<p>我们先来看两个例子，对比赋值与浅拷贝会对原对象带来哪些改变？</p>
<p><img src="https://image-static.segmentfault.com/321/742/3217423639-5cb4481c12383_articlex" alt=""></p>
<p><img src="https://image-static.segmentfault.com/823/033/82303300-5cb44834907c3_articlex" alt=""></p>
<p><img src="https://image-static.segmentfault.com/151/165/1511654841-5cb448978ac67_articlex" alt=""></p>
<p><img src="https://image-static.segmentfault.com/269/492/269492869-5cb448b648b26_articlex" alt=""></p>
<p>上面例子中，obj1是原始数据，obj2是赋值操作得到，而obj3浅拷贝得到。我们可以很清晰看到对原始数据的影响，具体请看下表：</p>
<p><img src="https://image-static.segmentfault.com/426/020/4260200719-5cb448da74905_articlex" alt=""></p>
<p>四、浅拷贝的实现方式<br>1.Object.assign()<br>Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 Object.assign()进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。</p>
<p><img src="https://image-static.segmentfault.com/268/471/2684714099-5cb4490a24858_articlex" alt=""></p>
<p>注意：当object只有一层的时候，是深拷贝</p>
<p><img src="https://image-static.segmentfault.com/402/080/4020809164-5cb44b5159432_articlex" alt=""></p>
<p>2.Array.prototype.concat()</p>
<p><img src="https://image-static.segmentfault.com/802/512/802512886-5cb44b68b2180_articlex" alt=""></p>
<p><img src="https://image-static.segmentfault.com/237/019/2370191236-5cb44b829ac84_articlex" alt=""></p>
<p>3.Array.prototype.slice()</p>
<p><img src="https://image-static.segmentfault.com/319/476/3194760406-5cb44c6423bc6_articlex" alt=""></p>
<p>同样修改新对象会改到原对象：</p>
<p><img src="https://image-static.segmentfault.com/237/019/2370191236-5cb44b829ac84_articlex" alt=""></p>
<p>关于Array的slice和concat方法的补充说明：Array的slice和concat方法不修改原数组，只会返回一个浅复制了原数组中的元素的一个新数组。</p>
<p>原数组的元素会按照下述规则拷贝：</p>
<p>如果该元素是个对象引用(不是实际的对象)，slice 会拷贝这个对象引用到新的数组里。两个对象引用都引用了同一个对象。如果被引用的对象发生改变，则新的和原来的数组中的这个元素也会发生改变。<br>对于字符串、数字及布尔值来说（不是 String、Number 或者 Boolean 对象），slice 会拷贝这些值到新的数组里。在别的数组里修改这些字符串或数字或是布尔值，将不会影响另一个数组。</p>
<p>可能这段话晦涩难懂，我们举个例子，将上面的例子小作修改：</p>
<p><img src="https://image-static.segmentfault.com/302/554/3025543906-5cb44ba3b77e0_articlex" alt=""></p>
<p><img src="https://image-static.segmentfault.com/128/298/1282980653-5cb44cc1013f3_articlex" alt=""></p>
<p>五、深拷贝的实现方式</p>
<ol>
<li><p>JSON.parse(JSON.stringify())</p>
<p><img src="https://image-static.segmentfault.com/140/473/1404730361-5cb44bd090b99_articlex" alt=""></p>
<p><img src="https://image-static.segmentfault.com/154/083/1540832116-5cb44d4261bfe_articlex" alt=""></p>
<p>原理： 用JSON.stringify将对象转成JSON字符串，再用JSON.parse()把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。</p>
<p>这种方法虽然可以实现数组或对象深拷贝,但不能处理函数</p>
<p><img src="https://image-static.segmentfault.com/371/749/3717490699-5cb44d5a4c6ad_articlex" alt=""></p>
<p><img src="https://image-static.segmentfault.com/204/258/2042589382-5cb44d7b1a737_articlex" alt=""></p>
<p>这是因为JSON.stringify() 方法是将一个JavaScript值(对象或者数组)转换为一个 JSON字符串，不能接受函数</p>
<ol>
<li>手写递归方法</li>
</ol>
<p>递归方法实现深度克隆原理：遍历对象、数组直到里边都是基本数据类型，然后再去复制，就是深度拷贝</p>
<p><img src="https://image-static.segmentfault.com/809/484/809484289-5cb44d922e659_articlex" alt=""></p>
<ol>
<li>函数库lodash</li>
</ol>
<p>该函数库也有提供_.cloneDeep用来做 Deep Copy</p>
<p><img src="https://image-static.segmentfault.com/197/586/1975863815-5cb44da68406c_articlex" alt=""></p>
</li>
</ol>
<h2 id="六、Java-Web"><a href="#六、Java-Web" class="headerlink" title="六、Java Web"></a>六、Java Web</h2><h3 id="64-jsp-和-servlet-有什么区别？"><a href="#64-jsp-和-servlet-有什么区别？" class="headerlink" title="64.jsp 和 servlet 有什么区别？"></a>64.jsp 和 servlet 有什么区别？</h3><p>jsp和servlet的区别有以下几点：</p>
<p>Jsp是Servlet的一种简化，使用Jsp只需要完成程序员需要输出到客户端的内容，Jsp中的Java脚本如何镶嵌到一个类中，由Jsp容器完成。</p>
<p>1、jsp经编译后就变成了Servlet。</p>
<p>2、jsp更擅长表现于页面显示,servlet更擅长于逻辑控制。</p>
<p>3、Servlet中没有内置对象，Jsp中的内置对象都是必须通过HttpServletResponse对象以及HttpServlet对象得到。</p>
<p>4、而Servlet则是个完整的Java类，这个类的Service方法用于生成对客户端的响应。</p>
<p><img src="https://iknow-pic.cdn.bcebos.com/6a600c338744ebf8431eb5dfd7f9d72a6159a7e7?x-bce-process=image/resize,m_lfit,w_600,h_800,limit_1" alt=""></p>
<p><strong>扩展资料</strong>：</p>
<p>Servlet和JSP的不同点：</p>
<p>1、Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML里分离开来。</p>
<p>2、而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。</p>
<p>3、JSP侧重于视图，Servlet主要用于控制逻辑</p>
<p>4、Servlet更多的是类似于一个Controller，用来做控制.</p>
<h3 id="65-jsp-有哪些内置对象？作用分别是什么？"><a href="#65-jsp-有哪些内置对象？作用分别是什么？" class="headerlink" title="65.jsp 有哪些内置对象？作用分别是什么？"></a>65.jsp 有哪些内置对象？作用分别是什么？</h3><p>1.HttpServletRequet类的Request对象：代表请求对象，主要用于接受客户端通过HTTP协议连接传输服务器端的数据。</p>
<p>2.HttpSevletResponse类的Response对象：代表响应对象，主要用于向客户端发送数据。</p>
<p>3.JspWriter类的out对象：主要用于向客户端输出数据，out的基类是jspWriter</p>
<p>4.HttpSession类的session对象：主要用来分别保存每个月的信息与请求关联的会话；会话状态的维持是web应用开发者必须面对的问题。</p>
<p>5.ServletContext类的application对象：主要用于保存用户信息，代码片段的运行环境；它是一个共享的内置对象，即一个容器中的多个用户共享一个application</p>
<p>，故其保存的信息被所有用户所共享。</p>
<p>6.PageContext类的PageContext对象：管理网页属性，为jsp页面包装页面的上下文，管理对属于jsp的特殊可见部分中已经命名对象的访问，它的创建和初始化都是由容器来完成的。</p>
<p>7.ServletConfig类的Config对象：代码片段配置对象，标识Servlet的配置。</p>
<p>8.Object类的Page对象，处理jsp页面，是object类的一个实例，指的是jsp实现类的实例</p>
<p>9.Exception对象：处理jsp文件执行时发生的错误和异常，只有在错误页面里才使用，前提是在页面指令里要有isErrorPage=true。</p>
<h3 id="66-说一下-jsp-的-4-种作用域？"><a href="#66-说一下-jsp-的-4-种作用域？" class="headerlink" title="66.说一下 jsp 的 4 种作用域？"></a>66.说一下 jsp 的 4 种作用域？</h3><p>首先要声明一点，所谓“作用域”就是“信息共享的范围”，也就是说一个信息能够在多大的范围内有效。4个JSP内置对象的作用域分别为：application、session、request、page 。JSP内置对象作用域表如下：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>作用域</th>
</tr>
</thead>
<tbody><tr>
<td>application</td>
<td>在所有应用程序中有效</td>
</tr>
<tr>
<td>session</td>
<td>在当前会话中有效</td>
</tr>
<tr>
<td>request</td>
<td>在当前请求中有效</td>
</tr>
<tr>
<td>page</td>
<td>在当前页面有效</td>
</tr>
</tbody></table>
<p>Web交互的最基本单位为HTTP请求。每个用户从进入网站到离开网站这段过程称为一个HTTP会话，一个服务器的运行过程中会有多个用户访问，就是多个HTTP会话。作用域解释如下。</p>
<h3 id="application-作用域"><a href="#application-作用域" class="headerlink" title="application 作用域"></a>application 作用域</h3><p>​     如果把变量放到application里，就说明它的作用域是application，它的有效范围是整个应用。 整个应用是指从应用启动，到应用结束。我们没有说“从服务器启动，到服务器关闭”，是因为一个服务器可能部署多个应用，当然你关闭了服务器，就会把上面所有的应用都关闭了。 application作用域里的变量，它们的存活时间是最长的，如果不进行手工删除，它们就一直可以使用。</p>
<p>application作用域上的信息传递是通过ServletContext实现的，它提供的主要方法如下所示：</p>
<p>Object getAttribute（String name）  //从application中获取信息；</p>
<p>void setAttribute（String name, Object value）  //向application作用域中设置信息。</p>
<h3 id="session作用域"><a href="#session作用域" class="headerlink" title="session作用域"></a>session作用域</h3><p>​       session作用域比较容易理解，同一浏览器对服务器进行多次访问，在这多次访问之间传递信息，就是session作用域的体现。如果把变量放到session里，就说明它的作用域是session，它的有效范围是当前会话。所谓当前会话，就是指从用户打开浏览器开始，到用户关闭浏览器这中间的过程。这个过程可能包含多个请求响应。也就是说，只要用户不关浏览器，服务器就有办法知道这些请求是一个人发起的，整个过程被称为一个会话（session），而放到会话中的变量，就可以在当前会话的所有请求里使用。<br> session是通过HttpSession接口实现的，它提供的主要方法如下所示：</p>
<p>Object HttpSession.getAttribute（String name） //从session中获取信息。</p>
<p>void HttpSession.setAttribute（String name, Object value）//向session中保存信息。</p>
<p>HttpSession HttpServletRequest.getSessio() //获取当前请求所在的session的对象。</p>
<p> session的开始时刻比较容易判断，它从浏览器发出第一个HTTP请求即可认为会话开始。但结束时刻就不好判断了，因为浏览器关闭时并不会通知服务器，所以只能通过如下这种方法判断：如果一定的时间内客户端没有反应，则认为会话结束。Tomcat的默认值为120分钟，但这个值也可以通过HttpSession的setMaxInactiveInterval()方法来设置：</p>
<p>void setMaxInactiveInterval(int interval)</p>
<p>如果想主动让会话结束，例如用户单击“注销”按钮的时候，可以使用 HttpSession 的 invalidate()方法，用于强制结束当前session：void invalidate()</p>
<h3 id="request作用域"><a href="#request作用域" class="headerlink" title="request作用域"></a>request作用域</h3><p>​     一个HTTP请求的处理可能需要多个Servlet合作，而这几个Servlet之间可以通过某种方式传递信息，但这个信息在请求结束后就无效了。request里的变量可以跨越forward前后的两页。但是只要刷新页面，它们就重新计算了。如果把变量放到request里，就说明它的作用域是request，它的有效范围是当前请求周期。 所谓请求周期，就是指从http请求发起，到服务器处理结束，返回响应的整个过程。在这个过程中可能使用forward的方式跳转了多个jsp页面，在这些页面里你都可以使用这个变量。</p>
<p>Servlet之间的信息共享是通过HttpServletRequest接口的两个方法来实现的：</p>
<p>void setAttribute（String name, Object value） //将对象value以name为名称保存到request作用域中。</p>
<p>Object getAttribute（String name） //从request作用域中取得指定名字的信息。</p>
<p>​     JSP中的doGet()、doPost()方法的第一个参数就是HttpServletRequest对象，使用这个对象的 setAttribute()方法即可传递信息。那么在设置好信息之后，要通过何种方式将信息传给其他的Servlet呢？这就要用到RequestDispatcher接口的forward()方法，通过它将请求转发给其他Servlet。</p>
<p> RequestDispatcher ServletContext.getRequestDispatcher(String path) //取得Dispatcher以便转发，path为转发的目的Servlet。</p>
<p> void RequestDispatcher.forward(ServletRequest request, ServletResponse response)//将request和response转发</p>
<p>​     因此，只需要在当前Servlet中先通过setAttribute()方法设置相应的属性，然后使用forward()方法进行跳转，最后在跳转到的Servlet中通过使用getAttribute()方法即可实现信息传递。</p>
<p>  <strong>需要注意两点：</strong></p>
<p>1、转发不是重定向，转发是在Web应用内部进行的。</p>
<p>2、转发对浏览器是透明的，也就是说，无论在服务器上如何转发，浏览器地址栏中显示的仍然是最初那个Servlet的地址。</p>
<h3 id="page作用域"><a href="#page作用域" class="headerlink" title="page作用域"></a>page作用域</h3><p>page对象的作用范围仅限于用户请求的当前页面，对于page对象的引用将在响应返回给客户端之后被释放，或者在请求被转发到其他地方后被释放。page里的变量只要页面跳转了，它们就不见了。如果把变量放到pageContext里，就说明它的作用域是page，它的有效范围只在当前jsp页面里。从把变量放到pageContext开始，到jsp页面结束，你都可以使用这个变量。</p>
<p>以上介绍的作用范围越来越小，request和page的生命周期都是短暂的，它们之间的区别：一个request可以包含多个page页（include，forward及filter）。</p>
<p>67.session 和 cookie 有什么区别？</p>
<p><strong>cookie</strong></p>
<p>位于用户的计算机上，用来维护用户计算机中的信息，直到用户删除。比如我们在网页上登录某个软件时输入用户名及密码时如果保存为cookie，则每次我们访问的时候就不需要登录网站了。我们可以在浏览器上保存任何文本，而且我们还可以随时随地的去阻止它或者删除。我们同样也可以禁用或者编辑cookie，但是有一点需要注意不要使用cookie来存储一些隐私数据，以防隐私泄露</p>
<p><img src="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=2169381799,1320776160&fm=173&app=49&f=JPEG?w=450&h=300&s=440A5532435E4DC80AD4B1DB0000C0B2" alt="img"></p>
<p><strong>session</strong></p>
<p>session称为会话信息，位于web服务器上，主要负责访问者与网站之间的交互，当访问浏览器请求http地址时，将传递到web服务器上并与访问信息进行匹配， 当关闭网站时就表示会话已经结束，网站无法访问该信息了，所以它无法保存永久数据，我们无法访问以及禁用网站</p>
<p><img src="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=2349409144,1211092590&fm=173&app=49&f=JPEG?w=450&h=300&s=0C0A55325347434D48D5914B030060F1" alt="img"></p>
<p><strong>session与cookie的区别</strong></p>
<p>（1）Cookie以文本文件格式存储在浏览器中，而session存储在服务端它存储了限制数据量。它只允许4kb它没有在cookie中保存多个变量。</p>
<p>（2）cookie的存储限制了数据量，只允许4KB，而session是无限量的</p>
<p>（3）我们可以轻松访问cookie值但是我们无法轻松访问会话值，因此它更安全</p>
<p>（4）设置cookie时间可以使cookie过期。但是使用session-destory（），我们将会销毁会话。</p>
<p>总结：如果我们需要经常登录一个站点时，最好用cookie来保存信息，要不然每次登陆都特别麻烦，如果对于需要安全性高的站点以及控制数据的能力时需要用会话效果更佳，当然我们也可以结合两者，使网站按照我们的想法进行运行</p>
<h3 id="68-说一下-session-的工作原理？"><a href="#68-说一下-session-的工作原理？" class="headerlink" title="68.说一下 session 的工作原理？"></a>68.说一下 session 的工作原理？</h3><p>Session：Session是个服务端技术，利用这个技术 服务器在运行时候可以为每一个用户浏览器创建一个独享的session对象。由于未用户浏览器独享，所以每一个用户在访问服务器的web资源的时候，可以把给自的session中，当用户在去访问服务器的web资源的时候。其他web资源在从各自的session中取出数据为用户服务。</p>
<p>Session的工作原理图：</p>
<p> <img src="https://img-blog.csdnimg.cn/20190105150030891.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTYwNTkzNw==,size_16,color_FFFFFF,t_70" alt=""></p>
<p>Session其本质就是一个Cookie（浏览器在关闭的时候Session就失效了）。</p>
<p>如果在浏览器中禁止使用Cookie时候也会不能使用Cookie和Session这样两个都是不能用的。</p>
<h3 id="69-如果客户端禁止-cookie-能实现-session-还能用吗？"><a href="#69-如果客户端禁止-cookie-能实现-session-还能用吗？" class="headerlink" title="69.如果客户端禁止 cookie 能实现 session 还能用吗？"></a>69.如果客户端禁止 cookie 能实现 session 还能用吗？</h3><p>一般默认情况下，在会话中，服务器存储 session 的 sessionid 是通过 cookie 存到浏览器里。</p>
<p>如果浏览器禁用了 cookie，浏览器请求服务器无法携带 sessionid，服务器无法识别请求中的用户身份，session失效。</p>
<p>但是可以通过其他方法在禁用 cookie 的情况下，可以继续使用session。</p>
<p>通过url重写，把 sessionid 作为参数追加的原 url 中，后续的浏览器与服务器交互中携带 sessionid 参数。<br>服务器的返回数据中包含 sessionid，浏览器发送请求时，携带 sessionid 参数。<br>通过 Http 协议其他 header 字段，服务器每次返回时设置该 header 字段信息，浏览器中 js 读取该 header 字段，请求服务器时，js设置携带该 header 字段。</p>
<h3 id="70-spring-mvc-和-struts-的区别是什么？"><a href="#70-spring-mvc-和-struts-的区别是什么？" class="headerlink" title="70.spring mvc 和 struts 的区别是什么？"></a>70.spring mvc 和 struts 的区别是什么？</h3><h3 id="一、拦截机制的不同"><a href="#一、拦截机制的不同" class="headerlink" title="一、拦截机制的不同"></a>一、拦截机制的不同</h3><p>　　Struts2是类级别的拦截，每次请求就会创建一个Action，和Spring整合时Struts2的ActionBean注入作用域是原型模式prototype，然后通过setter，getter吧request数据注入到属性。Struts2中，一个Action对应一个request，response上下文，在接收参数时，可以通过属性接收，这说明属性参数是让多个方法共享的。Struts2中Action的一个方法可以对应一个url，而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了，只能设计为多例。</p>
<p>　　SpringMVC是方法级别的拦截，一个方法对应一个Request上下文，所以方法直接基本上是独立的，独享request，response数据。而每个方法同时又何一个url对应，参数的传递是直接注入到方法中的，是方法所独有的。处理结果通过ModeMap返回给框架。在Spring整合时，SpringMVC的Controller Bean默认单例模式Singleton，所以默认对所有的请求，只会创建一个Controller，有应为没有共享的属性，所以是线程安全的，如果要改变默认的作用域，需要添加@Scope注解修改。</p>
<p>　　Struts2有自己的拦截Interceptor机制，SpringMVC这是用的是独立的Aop方式，这样导致Struts2的配置文件量还是比SpringMVC大。</p>
<h3 id="二、底层框架的不同"><a href="#二、底层框架的不同" class="headerlink" title="二、底层框架的不同"></a>二、底层框架的不同</h3><p>　　Struts2采用Filter（StrutsPrepareAndExecuteFilter）实现，SpringMVC（DispatcherServlet）则采用Servlet实现。Filter在容器启动之后即初始化；服务停止以后坠毁，晚于Servlet。Servlet在是在调用时初始化，先于Filter调用，服务停止后销毁。</p>
<h3 id="三、性能方面"><a href="#三、性能方面" class="headerlink" title="三、性能方面"></a>三、性能方面</h3><p>　　Struts2是类级别的拦截，每次请求对应实例一个新的Action，需要加载所有的属性值注入，SpringMVC实现了零配置，由于SpringMVC基于方法的拦截，有加载一次单例模式bean注入。所以，SpringMVC开发效率和性能高于Struts2。</p>
<h3 id="四、配置方面"><a href="#四、配置方面" class="headerlink" title="四、配置方面"></a>四、配置方面</h3><p>　　spring MVC和Spring是无缝的。从这个项目的管理和安全上也比Struts2高。</p>
<p><strong>附注：拦截器与过滤器的区别</strong> ：</p>
<ol>
<li>拦截器是基于java的反射机制的，而过滤器是基于函数回调。</li>
<li>拦截器不依赖与servlet容器，过滤器依赖与servlet容器。</li>
<li>拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。</li>
<li>拦截器可以访问action上下文、值栈里的对象，而过滤器不能访问。</li>
<li>在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次</li>
</ol>
<h3 id="71-如何避免-sql-注入？"><a href="#71-如何避免-sql-注入？" class="headerlink" title="71.如何避免 sql 注入？"></a>71.如何避免 sql 注入？</h3><p>SQL注入是一种注入攻击，可以执行恶意SQL语句。下面本篇文章就来带大家了解一下SQL注入，简单介绍一下防止SQL注入攻击的方法，希望对大家有所帮助。</p>
<p><img src="https://pics3.baidu.com/feed/e1fe9925bc315c603847d2d2fdb85817485477ce.jpeg?token=23377106bfc734a5a7e48d0827f49a41&s=8D287C32973950231C44B9DA000090B1" alt="img"></p>
<p><strong>什么是SQL注入？</strong></p>
<p>SQL注入（SQLi）是一种注入攻击，，可以执行恶意SQL语句。它通过将任意SQL代码插入数据库查询，使攻击者能够完全控制Web应用程序后面的数据库服务器。攻击者可以使用SQL注入漏洞绕过应用程序安全措施；可以绕过网页或Web应用程序的身份验证和授权，并检索整个SQL数据库的内容；还可以使用SQL注入来添加，修改和删除数据库中的记录。</p>
<p>SQL注入漏洞可能会影响使用SQL数据库（如MySQL，Oracle，SQL Server或其他）的任何网站或Web应用程序。犯罪分子可能会利用它来未经授权访问用户的敏感数据：客户信息，个人数据，商业机密，知识产权等。SQL注入攻击是最古老，最流行，最危险的Web应用程序漏洞之一。</p>
<p><strong>SQL注入攻击的类型</strong></p>
<p>SQL注入攻击可以通过多种方式执行。在选择特定攻击方法之前，攻击者可能会观察系统的行为。</p>
<p><strong>带内注入</strong></p>
<p>这是典型的攻击，攻击者可以通过相同的通信通道发起攻击并获得结果。这是通过两种带内技术完成的：</p>
<p>●　基于错误的SQL注入：从显示的错误消息中获取有关数据库的信息</p>
<p>●　基于联合的SQL注入：依赖于攻击者能够将UNION ALL被盗信息的结果与合法结果连接起来。</p>
<p>这两种技术都依赖于攻击者修改应用程序发送的SQL，以及浏览器中显示的错误和返回的信息。如果应用程序开发人员或数据库开发人员无法正确地参数化他们在查询中使用的值，那么它会成功。两者都是试错法，可以检测到错误。</p>
<p><strong>盲注入</strong></p>
<p>也称为推理SQL注入，盲注入攻击不会直接从目标数据库中显示数据；相反，攻击者会仔细检查行为中的间接线索。HTTP响应中的详细信息，某些用户输入的空白网页以及数据库响应某些用户输入需要多长时间，这些都可以是线索，具体取决于攻击者的目标。他们还可以指向攻击者尝试的另一个SQLi攻击途径。</p>
<p><strong>带外注入</strong></p>
<p>这种攻击有点复杂，当攻击者无法在单个直接查询 - 响应攻击中实现其目标时，攻击者可能会使用此攻击。通常，攻击者会制作SQL语句，这些语句在呈现给数据库时会触发数据库系统创建与攻击者控制的外部服务器的连接。以这种方式，攻击者可以收集数据或可能控制数据库的行为。</p>
<p>二阶注入就是一种带外注入攻击。在这种情况下，攻击者将提供SQL注入，该注入将由数据库系统的单独行为存储和执行。当二级系统行为发生时（它可能类似于基于时间的作业或由其他典型管理员或用户使用数据库触发的某些事情）并且执行攻击者的SQL注入，那就是当“伸出”到系统时攻击者控制发生了。</p>
<p><strong>如何防止SQL注入攻击？</strong></p>
<p>以下建议可以帮助防止SQL注入攻击成功：</p>
<p><strong>不要使用动态SQL</strong></p>
<p>避免将用户提供的输入直接放入SQL语句中；最好使用准备好的语句和参数化查询，这样更安全。</p>
<p><strong>不要将敏感数据保留在纯文本中</strong></p>
<p>加密存储在数据库中的私有/机密数据；这样可以提供了另一级保护，以防攻击者成功地排出敏感数据。</p>
<p><strong>限制数据库权限和特权</strong></p>
<p>将数据库用户的功能设置为最低要求；这将限制攻击者在设法获取访问权限时可以执行的操作。</p>
<p><strong>避免直接向用户显示数据库错误</strong></p>
<p>攻击者可以使用这些错误消息来获取有关数据库的信息。</p>
<p><strong>对访问数据库的Web应用程序使用Web应用程序防火墙（WAF）</strong></p>
<p>这为面向Web的应用程序提供了保护，它可以帮助识别SQL注入尝试；根据设置，它还可以帮助防止SQL注入尝试到达应用程序（以及数据库）。</p>
<p><strong>定期测试与数据库交互的Web应用程序</strong></p>
<p>这样做可以帮助捕获可能允许SQL注入的新错误或回归。</p>
<p><strong>将数据库更新为最新的可用修补程序</strong></p>
<p>这可以防止攻击者利用旧版本中存在的已知弱点/错误。</p>
<p><strong>总结：</strong>SQL注入是一种流行的攻击攻击方法，但是通过采取适当的预防措施，例如确保数据加密，保护和测试Web应用程序，以及您是最新的补丁程序，您可以采取有意义的步骤来保持您的数据安全。</p>
<h3 id="72-什么是-XSS-攻击，如何避免？"><a href="#72-什么是-XSS-攻击，如何避免？" class="headerlink" title="72.什么是 XSS 攻击，如何避免？"></a>72.什么是 XSS 攻击，如何避免？</h3><p>什么是XSS攻击？XSS是一种网站应用程序的安全漏洞攻击，是代码注入的一种,它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。这种类型的漏洞由于被黑客用来编写危害性更大的网络钓鱼攻击而变得广为人知。</p>
<p>XSS攻击的主要目的则是，想办法获取目标攻击网站的cookie，因为有了cookie相当于有了seesion，有了这些信息就可以在任意能接进互联网的pc登陆该网站，并以其他人的生份登陆，做一些破坏。　</p>
<h3 id="XSS攻击的危害"><a href="#XSS攻击的危害" class="headerlink" title="XSS攻击的危害"></a>XSS攻击的危害</h3><p>XSS攻击是Web攻击中最常见的攻击方法之一，它是通过对网页注入可执行代码且成功地被浏览器</p>
<p>执行，达到攻击的目的，形成了一次有效XSS攻击，一旦攻击成功，它可以获取用户的联系人列</p>
<p>表，然后向联系人发送虚假诈骗信息，可以删除用户的日志等等，有时候还和其他攻击方式同时实</p>
<p>施比如SQL注入攻击服务器和数据库、Click劫持、相对链接劫持等实施钓鱼，它带来的危害是巨</p>
<p>大的，是web安全的头号大敌。</p>
<p><strong>XSS攻击的危害包括</strong></p>
<p>1、盗取各类用户帐号，如机器登录帐号、用户网银帐号、各类管理员帐号</p>
<p>2、控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力</p>
<p>3、盗窃企业重要的具有商业价值的资料</p>
<p>4、非法转账</p>
<p>5、强制发送电子邮件</p>
<p>6、网站挂马</p>
<p>7、控制受害者机器向其它网站发起攻击</p>
<h3 id="如何防御XSS攻击？"><a href="#如何防御XSS攻击？" class="headerlink" title="如何防御XSS攻击？"></a>如何防御XSS攻击？</h3><p><strong>1基于特征的防御</strong></p>
<p>XSS漏洞和著名的SQL注入漏洞一样，都是利用了Web页面的编写不完善，所以每一个漏洞所利用和针对的弱点都不尽相同。这就给XSS漏洞防御带来了困难：不可能以单一特征来概括所有XSS攻击。</p>
<p>传统XSS防御多采用特征匹配方式，在所有提交的信息中都进行匹配检查。对于这种类型的XSS攻击，采用的模式匹配方法一般会需要对“javascript”这个关键字进行检索，一旦发现提交信息中包含“javascript”，就认定为XSS攻击。这种检测方法的缺陷显而易见：骇客可以通过插入字符或完全编码的方式躲避检测：</p>
<p>躲避方法1)在javascript中加入多个tab键，得到</p>
<p>&lt; IMG SRC=”jav ascript:alert(‘XSS’);” &gt;;</p>
<p>躲避方法2) 在javascript中加入(空格)字符，得到</p>
<p>&lt; IMG SRC=”javascri pt:alert(‘XSS’);” &gt;;</p>
<p>躲避方法3) 在javascript中加入(回车)字符，得到</p>
<p>&lt; IMG SRC=”jav</p>
<p>ascript:alert(‘XSS’);” &gt;;</p>
<p>躲避方法4)在javascript中的每个字符间加入回车换行符，得到</p>
<p>&lt; IMG SRC=”javascrip\r</p>
<p>\nt:alert(‘XSS’);” &gt;</p>
<p>躲避方法5)对”javascript:alert(‘XSS’)”采用完全编码，得到</p>
<p>&lt; IMGSRC=javascrip?74:alert(‘XSS’) &gt;</p>
<p>上述方法都可以很容易的躲避基于特征的检测。而除了会有大量的漏报外，基于特征的</p>
<p>还存在大量的误报可能：在上面的例子中，对上述某网站这样一个地址，由于包含了关键字“javascript”，也将会触发报警。</p>
<p><strong>2 基于代码修改的防御</strong></p>
<p>和SQL注入防御一样，XSS攻击也是利用了Web页面的编写疏忽，所以还有一种方法就是从Web应用开发的角度来避免：</p>
<p>步骤1、对所有用户提交内容进行可靠的输入验证，包括对URL、查询关键字、HTTP头、POST数据等，仅接受指定长度范围内、采用适当格式、采用所预期的字符的内容提交，对其他的一律过滤。</p>
<p>步骤2、实现Session标记(session tokens)、CAPTCHA系统或者HTTP引用头检查，以防功能被第三方网站所执行。</p>
<p>步骤3、确认接收的的内容被妥善的规范化，仅包含最小的、安全的Tag(没有javascript)，去掉任何对远程内容的引用(尤其是样式表和javascript)，使用HTTP only的cookie。</p>
<p>当然，如上操作将会降低Web业务系统的可用性，用户仅能输入少量的制定字符，人与系统间的交互被降到极致，仅适用于信息发布型站点。并且考虑到很少有Web编码人员受过正规的安全培训，很难做到完全避免页面中的XSS漏洞。</p>
<h3 id="73-什么是-CSRF-攻击，如何避免？"><a href="#73-什么是-CSRF-攻击，如何避免？" class="headerlink" title="73.什么是 CSRF 攻击，如何避免？"></a>73.什么是 CSRF 攻击，如何避免？</h3><p>一  CSRF是什么？<br> 跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。</p>
<p>二、CSRF的原理</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/10852140-d963ba5a5de3deeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700/format/webp" alt="img"></p>
<p>image.png</p>
<p>三、CSRF的防范措施</p>
<p>1、验证 HTTP Referer 字段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP头中的Referer字段记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，而如果黑客要对其实施 CSRF 攻击，他一般只能在他自己的网站构造请求。因此，可以通过验证Referer值来防御CSRF 攻击。</span><br></pre></td></tr></table></figure>

<p>2、验证码。<br> 验证码<br> 利用验证码将用户收到的信息与后台服务器进行比对，每次用户提交都需要用户在表单中填写一个图片上的随机字符串，不符则进行拒绝。<br> 3、添加token验证</p>
<p>CSRF攻击之所以能够成功，是因为攻击者可以完全伪造用户的请求，该请求中所有的用户验证信息都存在cookie中，因此攻击者可以在不知道这些验证信息的情况下直接利用用户自己的cookie来通过安全验证。要防止CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于cookie之中。可以在HTTP请求中以参数的形式加入一个随机产生的token，并在服务器建立一个拦截器来验证这个token，如果请求中没有token或者token不正确，则认为可能是CSRF攻击而拒绝该请求。<br> 现在业界一致的做法就是使用Anti CSRF Token来防御CSRF。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">用户访问某个表单页面。</span><br><span class="line">服务端生成一个Token，放在用户的Session中，或者浏览器的Cookie中。</span><br><span class="line">在页面表单附带上Token参数。</span><br><span class="line">用户提交请求后，服务端验证表单中的Token是否与用户Session（或Cookies）中的Token一致，一致为合法请求，不是则非法请求。</span><br></pre></td></tr></table></figure>

<p>这个Token值必须是随机的，不可预测的。由于Token的存在，攻击者无法再构造一个带有合法Token的请求实施CSRF攻击。另外使用Token应注意Token的保密性，尽量把敏感操作由GET改成POST，以form或者AJAX形式提交，避免Token泄露。</p>
<p>4、尽量使用POST，限制GET</p>
<p>GET接口能够直接将请求地址暴露给攻击者，所以要防止CSRF一定最好不要用GET。当然POST并不是万无一失，攻击者只需要构造一个form表单就可以，但需要在第三方页面做，这样就增加了暴露的可能性。</p>
<h2 id="七、异常"><a href="#七、异常" class="headerlink" title="七、异常"></a>七、异常</h2><h3 id="74-throw-和-throws-的区别？"><a href="#74-throw-和-throws-的区别？" class="headerlink" title="74.throw 和 throws 的区别？"></a>74.throw 和 throws 的区别？</h3><p>throw和throws的区别：<br>1、throw代表动作，表示抛出一个异常的动作；throws代表一种状态，代表方法可能有异常抛出<br>2、throw用在方法实现中，而throws用在方法声明中<br>3、throw只能用于抛出一种异常，而throws可以抛出多个异常  仔细一看就知道了：<br>public Test() throws RepletException {<br>try {<br>System.out.println(“Test this Project!”)<br>}<br>catch (Exception e) {<br>throw new Exception(e.toString());<br>}<br>}</p>
<p>throws是用来声明一个方法可能抛出的所有异常信息<br>throw则是指抛出的一个具体的异常类型。<br>通常在一个方法（类）的声明处通过throws声明方法（类）可能抛出的异常信息，而在方法（类）内部通过throw声明一个具体的异常信息。<br>throws通常不用显示的捕获异常，可由系统自动将所有捕获的异常信息抛给上级方法；<br>throw则需要用户自己捕获相关的异常，而后在对其进行相关包装，最后在将包装后的异常信息抛  </p>
<h3 id="75-final、finally、finalize-有什么区别？"><a href="#75-final、finally、finalize-有什么区别？" class="headerlink" title="75.final、finally、finalize 有什么区别？"></a>75.final、finally、finalize 有什么区别？</h3><p>final用于声明属性、方法和类，分别表示属性不变，方法不可覆盖和类不可以被继承。<br>final属性：被final修饰的变量不可以变。一个是引用不可变，第二个是对象不可变。<br>被final修饰的引用地址不能被改变，但是可以对这个引用的内容进行更改，可以appen一些内容进去。所以被final修饰的必须初始化。</p>
<p>final的方法：方法不能当方法声明为final时，该方法不能被任何子类重写这个方法，但子类依然可以使用这个方法。</p>
<p>final参数：表示这个参数在这个方法的内部不允许被修改。</p>
<p>final类：当一个类声明为final时，此类不能被继承，所以的方法不能被重写。一个类不能既是abstract又是final。</p>
<p>finally<br>作为异常处理的一部分，他只能用于try/catch语句中，并且附带一个语句块，表示这个语句一定要被执行。</p>
<p>finalize<br>finalize是Object类的一个方法，在垃圾回收器执行时会调用被回收的对象的finalize（）方法，可以覆盖此方法来实现对其他资源回收</p>
<h3 id="76-try-catch-finally-中哪个部分可以省略？"><a href="#76-try-catch-finally-中哪个部分可以省略？" class="headerlink" title="76.try-catch-finally 中哪个部分可以省略？"></a>76.try-catch-finally 中哪个部分可以省略？</h3><p>package constxiong.interview;</p>
<p>public class TestOmitTryCatchFinally {</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	omitFinally();</span><br><span class="line">	omitCatch();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 省略finally 语句块</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static void omitFinally() &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">		int i &#x3D; 0;</span><br><span class="line">		i +&#x3D; 1;</span><br><span class="line">		System.out.println(i);</span><br><span class="line">	&#125; catch (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 省略 catch 语句块</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static void omitCatch() &#123;</span><br><span class="line">	int i &#x3D; 0;</span><br><span class="line">	try &#123;</span><br><span class="line">		i +&#x3D; 1;</span><br><span class="line">	&#125; finally &#123;</span><br><span class="line">		i &#x3D; 10;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="77-try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？"><a href="#77-try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？" class="headerlink" title="77.try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？"></a>77.try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</h3><p>会执行</p>
<p>1、不管有没有异常，finally中的代码都会执行<br>2、当try、catch中有return时，finally中的代码依然会继续执行<br>3、finally是在return后面的表达式运算之后执行的，此时并没有返回运算之后的值，而是把值保存起来，不管finally对该值做任何的改变，返回的值都不会改变，依然返回保存起来的值。也就是说方法的返回值是在finally运算之前就确定了的。<br>4、如果return的数据是引用数据类型，而在finally中对该引用数据类型的属性值的改变起作用，try中的return语句返回的就是在finally中改变后的该属性的值。<br>5、finally代码中最好不要包含return，程序会提前退出，也就是说返回的值不是try或catch中的值</p>
<h3 id="代码演示举例"><a href="#代码演示举例" class="headerlink" title="代码演示举例:"></a>代码演示举例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">　　public static void main(String[] args) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        System.out.println(&quot;try&quot;);</span><br><span class="line">        String str &#x3D; &quot;1.1&quot;;</span><br><span class="line">        int num &#x3D; Integer.parseInt(str);</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(&quot;catch&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        System.out.println(&quot;finally&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果:"></a>运行结果:</h3><p><img src="https://img2018.cnblogs.com/i-beta/1751422/201912/1751422-20191224105405074-229817569.png" alt="img"></p>
<h3 id="78-常见的异常类有哪些？"><a href="#78-常见的异常类有哪些？" class="headerlink" title="78.常见的异常类有哪些？"></a>78.常见的异常类有哪些？</h3><p>(1)NullPointerException 当应用程序试图访问空对象时，则抛出该异常。<br>(2)SQLException 提供关于数据库访问错误或其他错误信息的异常。<br>(3)IndexOutOfBoundsException指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。<br>(4)NumberFormatException当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。<br>(5)FileNotFoundException当试图打开指定路径名表示的文件失败时，抛出此异常。<br>(6)IOException当发生某种I/O异常时，抛出此异常。此类是失败或中断的I/O操作生成的异常的通用类。<br>(7)ClassCastException当试图将对象强制转换为不是实例的子类时，抛出该异常。<br>(8)ArrayStoreException试图将错误类型的对象存储到一个对象数组时抛出的异常。<br>(9)IllegalArgumentException 抛出的异常表明向方法传递了一个不合法或不正确的参数。<br>(10)ArithmeticException当出现异常的运算条件时，抛出此异常。例如，一个整数“除以零”时，抛出此类的一个实例。<br>(11)NegativeArraySizeException如果应用程序试图创建大小为负的数组，则抛出该异常。<br>(12)NoSuchMethodException无法找到某一特定方法时，抛出该异常。<br>(13)SecurityException由安全管理器抛出的异常，指示存在安全侵犯。<br>(14)UnsupportedOperationException当不支持请求的操作时，抛出该异常。<br>(15)RuntimeExceptionRuntimeException 是那些可能在Java虚拟机正常运行期间抛出的异常的超类。</p>
<h2 id="八、网络"><a href="#八、网络" class="headerlink" title="八、网络"></a>八、网络</h2><h3 id="79-http-响应码-301-和-302-代表的是什么？有什么区别？"><a href="#79-http-响应码-301-和-302-代表的是什么？有什么区别？" class="headerlink" title="79.http 响应码 301 和 302 代表的是什么？有什么区别？"></a>79.http 响应码 301 和 302 代表的是什么？有什么区别？</h3><p>官方的比较简洁的说明：</p>
<p>​        301 redirect: 301 代表永久性转移(Permanently Moved)</p>
<p>​        302 redirect: 302 代表暂时性转移(Temporarily Moved )</p>
<p>​        ps:这里也顺带记住了两个比较相近的英语单词（permanently、temporarily），嘻哈！</p>
<p>​        详细来说，301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）——这是它们的共同点。他们的不同在于。301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），<strong>搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址</strong>；302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，<strong>搜索引擎会抓取新的内容而保存旧的网址。</strong></p>
<p>​      这里开启傻瓜自问自答模式（自己可能想到的疑问）：</p>
<p>1、什么是重定向啊？</p>
<p>​        就是地址A跳转到地址B啦。百度百科的解释：<a href="http://baike.baidu.com/link?url=fYZD-oFmvcSmZ6PU-HJRhpnUx43LoZLqCVyFUmKI26NKpho1havccKoyqRW4H0kqZoAw9E6lUHzTMD9bjroEWq" target="_blank" rel="noopener">重定向</a>(Redirect)就是通过各种方法将各种网络请求重新定个方向转到其它位置（如：网页重定向、域名的重定向、路由选择的变化也是对数据报文经由路径的一种重定向）。</p>
<p>2、可是，为什么要进行重定向啊？什么时候需要重定向呢？</p>
<p>​        想跳就跳，就跳的漂亮。还是借鉴百度百科：</p>
<p>1）网站调整（如改变网页目录结构）；</p>
<p>2）网页被移到一个新地址；</p>
<p>3）网页扩展名改变(如应用需要把.php改成.Html或.shtml)。</p>
<p>​        这种情况下，如果不做重定向，则用户收藏夹或搜索引擎数据库中旧地址只能让访问客户得到一个404页面错误信息，访问流量白白丧失；再者某些注册了多个域名的网站，也需要通过重定向让访问这些域名的用户自动跳转到主站点等。</p>
<p>3、那么，什么时候进行301或者302跳转呢？</p>
<p>​        当一个网站或者网页24—48小时内临时移动到一个新的位置，这时候就要进行302跳转，打个比方说，我有一套房子，但是最近走亲戚去亲戚家住了，过两天我还回来的。而使用301跳转的场景就是之前的网站因为某种原因需要移除掉，然后要到新的地址访问，是永久性的，就比如你的那套房子其实是租的，现在租期到了，你又在另一个地方找到了房子，之前租的房子不住了。</p>
<p>​    清晰明确而言：</p>
<p>使用301跳转的场景：</p>
<p>1）域名到期不想续费（或者发现了更适合网站的域名），想换个域名。</p>
<p>2）在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。</p>
<p>3）空间服务器不稳定，换空间的时候。</p>
<p>使用302跳转的场景：</p>
<p>​        –尽量使用301跳转！</p>
<p>4、为什么尽量要使用301跳转？——网址劫持！</p>
<p>​        这里摘录百度百科上的解释：</p>
<p>​        从网址A 做一个302 重定向到网址B 时，主机服务器的隐含意思是网址A 随时有可能改主意，重新显示本身的内容或转向其他的地方。大部分的搜索引擎在大部分情况下，当收到302 重定向时，一般只要去抓取目标网址就可以了，也就是说网址B。如果搜索引擎在遇到302 转向时，百分之百的都抓取目标网址B 的话，就不用担心网址URL 劫持了。问题就在于，有的时候搜索引擎，尤其是Google，并不能总是抓取目标网址。比如说，有的时候A 网址很短，但是它做了一个302 重定向到B 网址，而B 网址是一个很长的乱七八糟的URL 网址，甚至还有可能包含一些问号之类的参数。很自然的，A 网址更加用户友好，而B 网址既难看，又不用户友好。这时Google 很有可能会仍然显示网址A。由于搜索引擎排名算法只是程序而不是人，在遇到302 重定向的时候，并不能像人一样的去准确判定哪一个网址更适当，这就造成了网址<a href="http://baike.baidu.com/view/1496.htm" target="_blank" rel="noopener">URL</a> 劫持的可能性。也就是说，一个不道德的人在他自己的网址A 做一个302 重定向到你的网址B，出于某种原因， Google 搜索结果所显示的仍然是网址A，但是所用的网页内容却是你的网址B 上的内容，这种情况就叫做网址URL 劫持。你辛辛苦苦所写的内容就这样被别人偷走了。302 重定向所造成的网址URL 劫持现象，已经存在一段时间了。不过到目前为止，似乎也没有什么更好的解决方法。在正在进行的谷歌大爸爸数据中心转换中，302 重定向问题也是要被解决的目标之一。从一些搜索结果来看，网址劫持现象有所改善，但是并没有完全解决。</p>
<p>​        我的理解是，从网站A（网站比较烂）上做了一个302跳转到网站B（搜索排名很靠前），这时候有时搜索引擎会使用网站B的内容，但却收录了网站A的地址，这样在不知不觉间，网站B在为网站A作贡献，网站A的排名就靠前了。</p>
<p>​      301跳转对查找引擎是一种对照驯良的跳转编制，也是查找引擎能够遭遇的跳转编制，它告诉查找引擎，这个地址弃用了，永远转向一个新地址，可以转移新域名的权重。而302重定向很容易被搜索引擎误认为是利用多个域名指向同一网站，那么你的网站就会被封掉，罪名是“利用重复的内容来干扰Google搜索结果的网站排名”。</p>
<p>​        自问自答模式先告一段落，这里分享下我在NodeJs中实现跳转的场景：</p>
<p>​        之前做过一个重构的项目，由于各种原因，我们的网站的登录以及注册部分需要剥离为另一个网站，域名和之前的不同，所以，我们需要保证旧的地址也能重定向到地址中去，我们就在旧的系统的node层中作了一个重定向，代码类似这样：</p>
<p><img src="https://img-blog.csdn.net/20150812175720353?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>这里没有设置状态码，发现默认是302跳转，然后我们设置了301状态码，类似这样：</p>
<p><img src="https://img-blog.csdn.net/20150812175924769?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>用fiddle抓包(上面的302调整我就不上图了)，看到效果:</p>
<p><img src="https://img-blog.csdn.net/20150812180232152?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>以上是使用Express，用nodejs原生的代码实现类似这样：</p>
<p><img src="https://img-blog.csdn.net/20150812180547633?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"> </p>
<h3 id="80-forward-和-redirect-的区别？"><a href="#80-forward-和-redirect-的区别？" class="headerlink" title="80.forward 和 redirect 的区别？"></a>80.forward 和 redirect 的区别？</h3><p>1、请求方不同</p>
<p>redirect：客户端发起的请求</p>
<p>forward：服务端发起的请求</p>
<p>2、浏览器地址表现不同</p>
<p>redirect：浏览器地址显示被请求的</p>
<p><a href="https://www.baidu.com/s?wd=url&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">url</a>forward：浏览器地址不显示被请求的<a href="https://www.baidu.com/s?wd=url&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">url</a></p>
<p><a href="https://iknow-pic.cdn.bcebos.com/810a19d8bc3eb1351031fc0fab1ea8d3fc1f448b" target="_blank" rel="noopener"><img src="https://iknow-pic.cdn.bcebos.com/810a19d8bc3eb1351031fc0fab1ea8d3fc1f448b?x-bce-process=image/resize,m_lfit,w_600,h_800,limit_1" alt="img"></a></p>
<p>3、参数传递不同</p>
<p>redirect：重新开始一个request,原页面的request生命周期结束。</p>
<p>forward：forward另一个连接的时候。request变量是在其生命周期内的。另一个页面也可以使用，其实质是把目标地址include。 </p>
<p>4、底层运作不同</p>
<p>redirect：发送的请求信息又回送给客户机，让客户机再转发到另一个资源上，需要在服务器和客户机之间增加一次通信。</p>
<p>forward：服务器端直接找到目标，并include过来。</p>
<p>5、定义不同</p>
<p>直接转发方式（Forward）：客户端和浏览器只发出一次请求，Servlet、HTML、JSP或其它信息资源，由第二个信息资源响应该请求，在请求对象request中，保存的对象对于每个信息资源是共享的。</p>
<p>间接转发方式（Redirect）实际是两次<a href="https://www.baidu.com/s?wd=HTTP%E8%AF%B7%E6%B1%82&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">HTTP请求</a>，服务器端在响应<a href="https://www.baidu.com/s?wd=%E7%AC%AC%E4%B8%80%E6%AC%A1&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">第一次</a>请求的时候，让浏览器再向另外一个<a href="https://www.baidu.com/s?wd=URL&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">URL</a>发出请求，从而达到转发的目的。</p>
<h3 id="81-简述-tcp-和-udp的区别？"><a href="#81-简述-tcp-和-udp的区别？" class="headerlink" title="81.简述 tcp 和 udp的区别？"></a>81.简述 tcp 和 udp的区别？</h3><p>TCP提供面向连接的、可靠的数据流传输，而UDP提供的是非面向连接的、不可靠的数据流传输。<br>TCP传输单位称为TCP报文段，UDP传输单位称为用户数据报。<br>TCP注重数据安全性，UDP数据传输快，因为不需要连接等待，少了许多操作，但是其安全性却一般。<br>TCP对应的协议和UDP对应的协议<br>TCP对应的协议：<br>（1） FTP：定义了文件传输协议，使用21端口。<br>（2） Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。<br>（3） SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。<br>（4） POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。<br>（5）HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。<br>UDP对应的协议：<br>（1） DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。<br>（2） SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。<br>（3） TFTP(Trival File Transfer Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。</p>
<h3 id="82-tcp-为什么要三次握手，两次-不行吗？为什么？"><a href="#82-tcp-为什么要三次握手，两次-不行吗？为什么？" class="headerlink" title="82.tcp 为什么要三次握手，两次 不行吗？为什么？"></a>82.tcp 为什么要三次握手，两次 不行吗？为什么？</h3><p>TCP 通信流程<br>TCP 的通信流程</p>
<p><img src="https://img-blog.csdn.net/20180208112533496" alt=""></p>
<p>上图中的每一个箭头都代表着一次 TCP数据包的发送</p>
<p>需要注意的是， 上图中出现的 ACK = x +1 的写法很容易让人误以为数据包中的 ACK 域的数据值被填成了 y+1 。 ACK = x+1 的实际含义是：<br>TCP 包的 ACK 标志位（1 bit） 被置成了 1<br>TCP 包的确认号（acknowledgement number ） 的值为 x+1<br>类似的， TCP 数据包中的 SYN 标志位， 也容易与序号（sequence number） 混淆， 这点需要读者注意</p>
<p>TCP 数据包结构图</p>
<p><img src="https://img-blog.csdn.net/2018091917061915?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbmd4aWFvMTk5Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<p><strong>为什么 TCP 需要握手这个操作</strong><br>在解答为什么 TCP 需要三次握手， 而不是两次之前， 首先需要回答的问题是:</p>
<p>为什么需要握手这个操作， 能不能不握手？<br>如果读者对比一下 UDP 的通信流程和 TCP 的通信流程， 可以发现， 在 UDP 协议中， 是没有握手这个操作的。</p>
<p><img src="https://img-blog.csdn.net/20180919164448658?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbmd4aWFvMTk5Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<p>这里就引出了 TCP 与 UDP 的一个基本区别， TCP 是可靠通信协议， 而 UDP 是不可靠通信协议。</p>
<p>TCP 的可靠性含义： 接收方收到的数据是完整， 有序， 无差错的。<br>UDP 不可靠性含义： 接收方接收到的数据可能存在部分丢失， 顺序也不一定能保证。<br>UDP 和 TCP 协议都是基于同样的互联网基础设施， 且都基于 IP 协议实现， 互联网基础设施中对于数据包的发送过程是会发生丢包现象的， 为什么 TCP 就可以实现可靠传输， 而 UDP 不行？</p>
<p>TCP 协议为了实现可靠传输， 通信双方需要判断自己已经发送的数据包是否都被接收方收到， 如果没收到， 就需要重发。 为了实现这个需求， 很自然地就会引出序号（sequence number） 和 确认号（acknowledgement number） 的使用。</p>
<p>发送方在发送数据包（假设大小为 10 byte）时， 同时送上一个序号( 假设为 500)，那么接收方收到这个数据包以后， 就可以回复一个确认号（510 = 500 + 10） 告诉发送方 “我已经收到了你的数据包， 你可以发送下一个数据包， 序号从 510 开始” 。</p>
<p>这样发送方就可以知道哪些数据被接收到，哪些数据没被接收到， 需要重发。</p>
<p><strong>为什么需要三次握手，而非两次</strong><br>正如上文所描述的，为了实现可靠传输，发送方和接收方始终需要同步( SYNchronize )序号。 需要注意的是， 序号并不是从 0 开始的， 而是由发送方随机选择的初始序列号 ( Initial Sequence Number, ISN )开始 。 由于 TCP 是一个双向通信协议， 通信双方都有能力发送信息， 并接收响应。 因此， 通信双方都需要随机产生一个初始的序列号， 并且把这个起始值告诉对方。</p>
<p>于是， 这个过程就变成了下面这样。</p>
<p><img src="https://img-blog.csdnimg.cn/20191129144820655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbmd4aWFvMTk5Mw==,size_16,color_FFFFFF,t_70" alt=""></p>
<p>下面这个流程图描述的和上面一样， 但是更加清楚的展示了 TCP 数据包标志位， 以及数据域的命名来源。</p>
<p>补充知识： 有一位读者关注到了三次握手中， 序列号变化的问题， 让笔者临时想起了曾经困扰自己的一个问题：</p>
<p>为什么三次握手最后一次握手中， 在上面的示意图中回复的 seq = x+1 而不是 x+2<br><a href="https://blog.csdn.net/lengxiao1993/article/details/82771768" target="_blank" rel="noopener">https://blog.csdn.net/lengxiao1993/article/details/82771768</a></p>
<p>答案：</p>
<p><img src="https://img-blog.csdnimg.cn/20191129145350949.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbmd4aWFvMTk5Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191129145434875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbmd4aWFvMTk5Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="83-说一下-tcp-粘包是怎么产生的？"><a href="#83-说一下-tcp-粘包是怎么产生的？" class="headerlink" title="83.说一下 tcp 粘包是怎么产生的？"></a>83.说一下 tcp 粘包是怎么产生的？</h3><p>引言：TCP协议是网络通信协议中十分重要的协议，相比于UDP协议来说，它是一个可靠的传输协议，并且是一个面向数据流的协议；所谓面向数据流，其实是指数据传输是以流式的方式传输，这些传输的数据就像一条河里的水，他们之间是没有缝隙的，也就是说TCP协议传输的数据是无边界的；（其实TCP粘包概念个人感觉不恰当，毕竟TCP传输是以流式的方式）<br>而UDP是面向数据包的，收发数据包要么全收要么不收，数据包与数据包之间是有明显的边界的；</p>
<p>一、TCP粘包是什么？<br>粘包发生在发送或接收缓冲区中；应用程序从缓冲区中取数据是整个缓冲区中有多少取多少；那么就有可能第一个数据的尾部和第二个数据的头部同时存在缓冲区，而TCP是流式的，数据无边界，这时发生粘包。</p>
<p><img src="https://img-blog.csdn.net/20171219104402700?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzYzNTkwMjI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>二、TCP粘包的产生<br>1.发送方产生粘包<br>采用TCP协议传输数据的客户端与服务器经常是保持一个长连接的状态（一次连接发一次数据不存在粘包），双方在连接不断开的情况下，可以一直传输数据；但当发送的数据包过于的小时，那么TCP协议默认的会启用Nagle算法，将这些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程）；这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来它已经是粘包的状态了；</p>
<p><img src="https://img-blog.csdn.net/20171219110406861?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzYzNTkwMjI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>2.接收方产生粘包<br>接收方采用TCP协议接收数据时的过程是这样的：数据到底接收方，从网络模型的下方传递至传输层，传输层的TCP协议处理是将其放置接收缓冲区，然后由应用层来主动获取（C语言用recv、read等函数）；这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包；（放数据的速度 &gt; 应用层拿数据速度）</p>
<p><img src="https://img-blog.csdn.net/20171219115333087?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzYzNTkwMjI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p><strong>TCP粘包解决方案</strong><br>目前应用最广泛的是在消息的头部添加数据包长度，接收方根据消息长度进行接收；在一条TCP连接上，数据的流式传输在接收缓冲区里是有序的，其主要的问题就是第一个包的包尾与第二个包的包头共存接收缓冲区，所以根据长度读取是十分合适的；</p>
<p>1.解决发送方粘包<br>（1）发送产生是因为Nagle算法合并小数据包，那么可以禁用掉该算法；<br>（2）TCP提供了强制数据立即传送的操作指令push，当填入数据后调用操作指令就可以立即将数据发送，而不必等待发送缓冲区填充自动发送；<br>（3）数据包中加头，头部信息为整个数据的长度（最广泛最常用）；<br>2.解决接收方粘包<br>（1）解析数据包头部信息，根据长度来接收；<br>（2）自定义数据格式：在数据中放入开始、结束标识；解析时根据格式抓取数据，缺点是数据内不能含有开始或结束标识；<br>（3）短连接传输，建立一次连接只传输一次数据就关闭；（不推荐</p>
<h3 id="84-OSI-的七层模型都有哪些？"><a href="#84-OSI-的七层模型都有哪些？" class="headerlink" title="84.OSI 的七层模型都有哪些？"></a>84.OSI 的七层模型都有哪些？</h3><table cellspacing="0"><tbody><tr><td style="border-color:#dddddd;text-align:left;vertical-align:middle;width:103pt;">
        <p><span style="color:#000000;">OSI七层模型</span></p>
        </td>
        <td style="border-color:#dddddd;text-align:left;vertical-align:middle;width:277pt;"><span style="color:#000000;">功能</span></td>
        <td style="border-color:#dddddd;text-align:left;vertical-align:middle;width:158pt;"><span style="color:#000000;">数据格式</span></td>
        <td style="border-color:#dddddd;text-align:left;vertical-align:middle;width:251pt;"><span style="color:#000000;">对应的网络协议</span></td>
        <td style="border-color:#dddddd;text-align:left;vertical-align:middle;width:219pt;"><span style="color:#000000;">TCP/IP四层概念模型</span></td>
    </tr><tr><td style="border-color:#dddddd;text-align:left;vertical-align:middle;width:103pt;"><span style="color:#000000;">应用层</span></td>
        <td style="border-color:#dddddd;text-align:left;vertical-align:middle;width:277pt;"><span style="color:#000000;">提供为应用软件而设的接口，以设置与另一应用软件之间的通信</span></td>
        <td style="border-color:#dddddd;text-align:left;vertical-align:middle;width:158pt;"><span style="color:#000000;">数据ATPU</span></td>
        <td style="border-color:#dddddd;text-align:left;vertical-align:middle;width:251pt;"><span style="color:#000000;">DNS、HTTP、FTP、IMAP4、POP3、SSH、TELNET…</span></td>
        <td rowspan="3" style="text-align:left;vertical-align:middle;width:219pt;"><span style="color:#000000;">应用层</span></td>
    </tr><tr><td style="border-color:#dddddd;text-align:left;vertical-align:middle;width:103pt;"><span style="color:#000000;">表达层</span></td>
        <td style="border-color:#dddddd;text-align:left;vertical-align:middle;width:277pt;"><span style="color:#000000;">把数据转换为能与接收者的系统格式兼容并适合传输的格式</span></td>
        <td style="border-color:#dddddd;text-align:left;vertical-align:middle;width:158pt;"><span style="color:#000000;">数据PTPU</span></td>
        <td style="border-color:#dddddd;text-align:left;vertical-align:middle;width:251pt;"><span style="color:#000000;">　</span></td>
    </tr><tr><td style="border-color:#dddddd;text-align:left;vertical-align:middle;width:103pt;"><span style="color:#000000;">会话层</span></td>
        <td style="border-color:#dddddd;text-align:left;vertical-align:middle;width:277pt;"><span style="color:#000000;">负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接</span></td>
        <td style="border-color:#dddddd;text-align:left;vertical-align:middle;width:158pt;"><span style="color:#000000;">数据DTPU</span></td>
        <td style="border-color:#dddddd;text-align:left;vertical-align:middle;width:251pt;"><span style="color:#000000;">　</span></td>
    </tr><tr><td style="border-color:#dddddd;text-align:left;vertical-align:middle;width:103pt;"><span style="color:#000000;">传输层</span></td>
        <td style="border-color:#dddddd;text-align:left;vertical-align:middle;width:277pt;"><span style="color:#000000;">把传输表头（TH）加至数据以形成数据包。传输表头包含了所使用的协议等发送信息</span></td>
        <td style="border-color:#dddddd;text-align:left;vertical-align:middle;width:158pt;"><span style="color:#000000;">数据组织成数据段Segment</span></td>
        <td style="border-color:#dddddd;text-align:left;vertical-align:middle;width:251pt;"><span style="color:#000000;">TCP、UDP、PPTP、TLS/SSL…</span></td>
        <td style="border-color:#dddddd;text-align:left;vertical-align:middle;width:219pt;"><span style="color:#000000;">传输层</span></td>
    </tr><tr><td style="border-color:#dddddd;text-align:left;vertical-align:middle;width:103pt;"><span style="color:#000000;">网络层</span></td>
        <td style="border-color:#dddddd;text-align:left;vertical-align:middle;width:277pt;"><span style="color:#000000;">决定数据的路径选择和转寄，将网络表头（NH）加至数据包，以形成分组。网络表头包含了网络数据</span></td>
        <td style="border-color:#dddddd;text-align:left;vertical-align:middle;width:158pt;"><span style="color:#000000;">分割和重新组合数据包Packet</span></td>
        <td style="border-color:#dddddd;text-align:left;vertical-align:middle;width:251pt;"><span style="color:#000000;">IP（v4·v6）、ICMP（v6）、IGMP、Ipsec…</span></td>
        <td style="border-color:#dddddd;text-align:left;vertical-align:middle;width:219pt;"><span style="color:#000000;">网络层</span></td>
    </tr><tr><td style="border-color:#dddddd;text-align:left;vertical-align:middle;width:103pt;"><span style="color:#000000;">数据链路层</span></td>
        <td style="border-color:#dddddd;text-align:left;vertical-align:middle;width:277pt;"><span style="color:#000000;">负责网络寻址、错误侦测和改错。当表头和表尾被加至数据包时，会形成帧。数据链表头（DLH）是包含了物理地址和错误侦测及改错的方法。数据链表尾（DLT）是一串指示数据包末端的字符串</span></td>
        <td style="border-color:#dddddd;text-align:left;vertical-align:middle;width:158pt;"><span style="color:#000000;">将比特信息封装成数据帧Frame</span></td>
        <td style="border-color:#dddddd;text-align:left;vertical-align:middle;width:251pt;"><span style="color:#000000;">Wi-Fi（IEEE 802.11）、ARP、WiMAX（IEEE 802.16）、PPP、PPPoE、L2TP…</span></td>
        <td rowspan="2" style="text-align:left;vertical-align:middle;width:219pt;"><span style="color:#000000;">数据链路层</span></td>
    </tr><tr><td style="text-align:left;vertical-align:middle;width:103pt;"><span style="color:#000000;">物理层</span></td>
        <td style="text-align:left;vertical-align:middle;width:277pt;"><span style="color:#000000;">在局部局域网上传送数据帧（data frame），它负责管理计算机通信设备和网络媒体之间的互通。包括了针脚、电压、线缆规范、集线器、中继器、网卡、主机接口卡等</span></td>
        <td style="text-align:left;vertical-align:middle;width:158pt;"><span style="color:#000000;">传输比特（bit）流</span></td>
        <td style="text-align:left;vertical-align:middle;width:251pt;"><span style="color:#000000;">　</span></td>
    </tr></tbody></table>　



<h3 id="85-get-和-post-请求有哪些区别？"><a href="#85-get-和-post-请求有哪些区别？" class="headerlink" title="85.get 和 post 请求有哪些区别？"></a>85.get 和 post 请求有哪些区别？</h3><table><tbody><tr><th>&nbsp;</th>
            <th>GET</th>
            <th>POST</th>
        </tr><tr><td>后退按钮/刷新</td>
            <td>无害</td>
            <td>数据会被重新提交（浏览器应该告知用户数据会被重新提交）。</td>
        </tr><tr><td>书签</td>
            <td>可收藏为书签</td>
            <td>不可收藏为书签</td>
        </tr><tr><td>缓存</td>
            <td>能被缓存</td>
            <td>不能缓存</td>
        </tr><tr><td>编码类型</td>
            <td>application/x-www-form-urlencoded</td>
            <td>application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。</td>
        </tr><tr><td>历史</td>
            <td>参数保留在浏览器历史中。</td>
            <td>参数不会保存在浏览器历史中。</td>
        </tr><tr><td>对数据长度的限制</td>
            <td>是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。</td>
            <td>无限制。</td>
        </tr><tr><td>对数据类型的限制</td>
            <td>只允许 ASCII 字符。</td>
            <td>没有限制。也允许二进制数据。</td>
        </tr><tr><td>安全性</td>
            <td>
            <p>与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！</p>    </td>
    <td>POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。</td>
    </tr><tr><td>可见性</td>
        <td>数据在 URL 中对所有人都是可见的。</td>
        <td>数据不会显示在 URL 中。</td>
    </tr></tbody></table>

<p>2、从 RFC 规范的（Safe-安全、Idempotent-幂等、Cacheable-可缓存性、语义）角度看 </p>
<p>GET 安全；POST 不安全<br>GET 幂等；POST 不幂等<br>GET 可缓存；POST 不可缓存<br>GET 用于信息获取；POST 表示可能修改变服务器上的资源的请求<br>这里的安全是指，GET 只读服务器数据不会修改； 幂等简单理解就是每次请求结果和产生的影响都一样。</p>
<p>3、注意问题</p>
<p>长度限制：http 协议并未规定 get 和post  的长度限制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">get 的最大长度限制是因为浏览器和 web 服务器限制了 URL 的长度</span><br><span class="line"></span><br><span class="line">不同的浏览器和web服务器，限制的最大长度不一样</span><br><span class="line"></span><br><span class="line">超出了最大长度，大部分的服务器直接截断，有些服务器会报414错误</span><br></pre></td></tr></table></figure>











<p>安全：这里的安全指使用过程中的安全</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET 是通过 URL 方式请求，可以直接看到，明文传输； POST 参数通过 header 传输，同样是明文</span><br><span class="line"></span><br><span class="line">浏览器会缓存和记录 GET 请求及参数，不缓存 POST 的请求的参数（如参数中包含敏感信息可能被其他从浏览器的缓存和浏览记录获取）</span><br></pre></td></tr></table></figure>

<h3 id="86-如何实现跨域？"><a href="#86-如何实现跨域？" class="headerlink" title="86.如何实现跨域？"></a>86.如何实现跨域？</h3><p>跨域：当浏览器执行脚本时会检查是否同源，只有同源的脚本才会执行，如果不同源即为跨域。</p>
<p>这里的同源指访问的协议、域名、端口都相同。<br>同源策略是由 Netscape 提出的著名安全策略，是浏览器最核心、基本的安全功能，它限制了一个源中加载脚本与来自其他源中资源的交互方式。<br>Ajax 发起的跨域 HTTP 请求，结果被浏览器拦截，同时 Ajax 请求不能携带与本网站不同源的 Cookie。</p>
<script> <img> <iframe> <link> <video> <audio> 等带有 src 属性的标签可以从不同的域加载和执行资源。 



如当使用 ajax 提交非同源的请求时，浏览器就会阻止请求。提示
Access to XMLHttpRequest at '...' from origin '...' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.



如何实现跨域请求呢？
1、jsonp
利用了 script 不受同源策略的限制
缺点：只能 get 方式，易受到 XSS攻击

2、CORS（Cross-Origin Resource Sharing）,跨域资源共享
当使用XMLHttpRequest发送请求时，如果浏览器发现违反了同源策略就会自动加上一个请求头 origin；
后端在接受到请求后确定响应后会在后端在接受到请求后确定响应后会在 Response Headers 中加入一个属性 Access-Control-Allow-Origin；
浏览器判断响应中的 Access-Control-Allow-Origin 值是否和当前的地址相同，匹配成功后才继续响应处理，否则报错
缺点：忽略 cookie，浏览器版本有一定要求

3、代理跨域请求
前端向发送请求，经过代理，请求需要的服务器资源
缺点：需要额外的代理服务器

4、Html5 postMessage 方法
允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本、多窗口、跨域消息传递
缺点：浏览器版本要求，部分浏览器要配置放开跨域限制

5、修改 document.domain 跨子域
相同主域名下的不同子域名资源，设置 document.domain 为 相同的一级域名
缺点：同一一级域名；相同协议；相同端口

6、基于 Html5 websocket 协议
websocket 是 Html5 一种新的协议，基于该协议可以做到浏览器与服务器全双工通信，允许跨域请求
缺点：浏览器一定版本要求，服务器需要支持 websocket 协议

7、document.xxx + iframe
通过 iframe 是浏览器非同源标签，加载内容中转，传到当前页面的属性中
缺点：页面的属性值有大小限制



### 前言

前后端数据交互经常会碰到请求跨域，什么是跨域，以及有哪几种跨域方式，这是本文要探讨的内容。

**本文完整的源代码请猛戳GitHub博客，纸上得来终觉浅，建议动手敲敲代码**

### 一、什么是跨域？

#### 1. 什么是同源策略及其限制内容？

同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指"协议+域名+端口"三者相同，即便两个不同的域名指向同一个ip地址，也非同源。

![img](https://image.fundebug.com/2019-01-26-01.png)

**同源策略限制内容有：**

- Cookie、LocalStorage、IndexedDB 等存储性内容
- DOM 节点
- AJAX 请求不能发送

但是有三个标签是允许跨域加载资源：

- `<img src=XXX>`
- `<link href=XXX>`
- `<script src=XXX>`

#### 2. 常见跨域场景

**当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域**。不同域之间相互请求资源，就算作“跨域”。常见跨域场景如下图所示：

![img](https://image.fundebug.com/2019-01-26-02.png)

特别说明两点：

**第一：如果是协议和端口造成的跨域问题“前台”是无能为力的。**

**第二：在跨域问题上，仅仅是通过“URL的首部”来识别而不会根据域名对应的IP地址是否相同来判断。“URL的首部”可以理解为“协议, 域名和端口必须匹配”**。

这里你或许有个疑问：**请求跨域了，那么请求到底发出去没有？**

**跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了**。你可能会疑问明明通过表单的方式可以发起跨域请求，为什么 Ajax 就不会?因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。

### 二、跨域解决方案

#### 1. jsonp

**1) JSONP原理**

**利用 <script> 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定需要对方的服务器做支持才可以。**

**2) JSONP和AJAX对比**

JSONP和AJAX相同，都是客户端向服务器端发送请求，从服务器端获取数据的方式。但AJAX属于同源策略，JSONP属于非同源策略（跨域请求）

**3) JSONP优缺点**

JSONP优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。**缺点是仅支持get方法具有局限性,不安全可能会遭受XSS攻击。**

**4) JSONP的实现流程**

- 声明一个回调函数，其函数名(如show)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的data)。

- 创建一个

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br></pre></td></tr></table></figure>

  标签，把那个跨域的API数据接口地址，赋值给script的src,还要在这个地址中向服务器传递该函数名（可以通过问号传参:?callback=show）。

  - 服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串,例如：传递进去的函数名是show，它准备好的数据是`show('我不爱你')`。

- 最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前声明的回调函数（show），对返回的数据进行操作。

在开发中可能会遇到多个 JSONP 请求的回调函数名是相同的，这时候就需要自己封装一个 JSONP函数。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; index.html</span><br><span class="line">function jsonp(&#123; url, params, callback &#125;) &#123;</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    let script &#x3D; document.createElement(&#39;script&#39;)</span><br><span class="line">    window[callback] &#x3D; function(data) &#123;</span><br><span class="line">      resolve(data)</span><br><span class="line">      document.body.removeChild(script)</span><br><span class="line">    &#125;</span><br><span class="line">    params &#x3D; &#123; ...params, callback &#125; &#x2F;&#x2F; wd&#x3D;b&amp;callback&#x3D;show</span><br><span class="line">    let arrs &#x3D; []</span><br><span class="line">    for (let key in params) &#123;</span><br><span class="line">      arrs.push(&#96;$&#123;key&#125;&#x3D;$&#123;params[key]&#125;&#96;)</span><br><span class="line">    &#125;</span><br><span class="line">    script.src &#x3D; &#96;$&#123;url&#125;?$&#123;arrs.join(&#39;&amp;&#39;)&#125;&#96;</span><br><span class="line">    document.body.appendChild(script)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">jsonp(&#123;</span><br><span class="line">  url: &#39;http:&#x2F;&#x2F;localhost:3000&#x2F;say&#39;,</span><br><span class="line">  params: &#123; wd: &#39;Iloveyou&#39; &#125;,</span><br><span class="line">  callback: &#39;show&#39;</span><br><span class="line">&#125;).then(data &#x3D;&gt; &#123;</span><br><span class="line">  console.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

上面这段代码相当于向`http://localhost:3000/say?wd=Iloveyou&callback=show`这个地址请求数据，然后后台返回`show('我不爱你')`，最后会运行show()这个函数，打印出'我不爱你'

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; server.js</span><br><span class="line">let express &#x3D; require(&#39;express&#39;)</span><br><span class="line">let app &#x3D; express()</span><br><span class="line">app.get(&#39;&#x2F;say&#39;, function(req, res) &#123;</span><br><span class="line">  let &#123; wd, callback &#125; &#x3D; req.query</span><br><span class="line">  console.log(wd) &#x2F;&#x2F; Iloveyou</span><br><span class="line">  console.log(callback) &#x2F;&#x2F; show</span><br><span class="line">  res.end(&#96;$&#123;callback&#125;(&#39;我不爱你&#39;)&#96;)</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(3000)</span><br></pre></td></tr></table></figure>

**5) jQuery的jsonp形式**

**JSONP都是GET和异步请求的，不存在其他的请求方式和同步请求，且jQuery默认就会给JSONP的请求清除缓存。**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">url:&quot;http:&#x2F;&#x2F;crossdomain.com&#x2F;jsonServerResponse&quot;,</span><br><span class="line">dataType:&quot;jsonp&quot;,</span><br><span class="line">type:&quot;get&quot;,&#x2F;&#x2F;可以省略</span><br><span class="line">jsonpCallback:&quot;show&quot;,&#x2F;&#x2F;-&gt;自定义传递给服务器的函数名，而不是使用jQuery自动生成的，可省略</span><br><span class="line">jsonp:&quot;callback&quot;,&#x2F;&#x2F;-&gt;把传递函数名的那个形参callback，可省略</span><br><span class="line">success:function (data)&#123;</span><br><span class="line">console.log(data);&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

#### 2. cors

**CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现**。

浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。

服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。

虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为**简单请求**和**复杂请求**。

**1) 简单请求**

只要同时满足以下两大条件，就属于简单请求

条件1：使用下列方法之一：

- GET
- HEAD
- POST

条件2：Content-Type 的值仅限于下列三者之一：

- text/plain
- multipart/form-data
- application/x-www-form-urlencoded

请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器； XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。

**2) 复杂请求**

不符合以上条件的请求就肯定是复杂请求了。
复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求,该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。

我们用`PUT`向后台请求时，属于复杂请求，后台需做如下配置：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 允许哪个方法访问我</span><br><span class="line">res.setHeader(&#39;Access-Control-Allow-Methods&#39;, &#39;PUT&#39;)</span><br><span class="line">&#x2F;&#x2F; 预检的存活时间</span><br><span class="line">res.setHeader(&#39;Access-Control-Max-Age&#39;, 6)</span><br><span class="line">&#x2F;&#x2F; OPTIONS请求不做任何处理</span><br><span class="line">if (req.method &#x3D;&#x3D;&#x3D; &#39;OPTIONS&#39;) &#123;</span><br><span class="line">  res.end() </span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 定义后台返回的内容</span><br><span class="line">app.put(&#39;&#x2F;getData&#39;, function(req, res) &#123;</span><br><span class="line">  console.log(req.headers)</span><br><span class="line">  res.end(&#39;我不爱你&#39;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

接下来我们看下一个完整复杂请求的例子，并且介绍下CORS请求相关的字段

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; index.html</span><br><span class="line">let xhr &#x3D; new XMLHttpRequest()</span><br><span class="line">document.cookie &#x3D; &#39;name&#x3D;xiamen&#39; &#x2F;&#x2F; cookie不能跨域</span><br><span class="line">xhr.withCredentials &#x3D; true &#x2F;&#x2F; 前端设置是否带cookie</span><br><span class="line">xhr.open(&#39;PUT&#39;, &#39;http:&#x2F;&#x2F;localhost:4000&#x2F;getData&#39;, true)</span><br><span class="line">xhr.setRequestHeader(&#39;name&#39;, &#39;xiamen&#39;)</span><br><span class="line">xhr.onreadystatechange &#x3D; function() &#123;</span><br><span class="line">  if (xhr.readyState &#x3D;&#x3D;&#x3D; 4) &#123;</span><br><span class="line">    if ((xhr.status &gt;&#x3D; 200 &amp;&amp; xhr.status &lt; 300) || xhr.status &#x3D;&#x3D;&#x3D; 304) &#123;</span><br><span class="line">      console.log(xhr.response)</span><br><span class="line">      &#x2F;&#x2F;得到响应头，后台需设置Access-Control-Expose-Headers</span><br><span class="line">      console.log(xhr.getResponseHeader(&#39;name&#39;))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.send()</span><br><span class="line">&#x2F;&#x2F;server1.js</span><br><span class="line">let express &#x3D; require(&#39;express&#39;);</span><br><span class="line">let app &#x3D; express();</span><br><span class="line">app.use(express.static(__dirname));</span><br><span class="line">app.listen(3000);</span><br><span class="line">&#x2F;&#x2F;server2.js</span><br><span class="line">let express &#x3D; require(&#39;express&#39;)</span><br><span class="line">let app &#x3D; express()</span><br><span class="line">let whitList &#x3D; [&#39;http:&#x2F;&#x2F;localhost:3000&#39;] &#x2F;&#x2F;设置白名单</span><br><span class="line">app.use(function(req, res, next) &#123;</span><br><span class="line">  let origin &#x3D; req.headers.origin</span><br><span class="line">  if (whitList.includes(origin)) &#123;</span><br><span class="line">    &#x2F;&#x2F; 设置哪个源可以访问我</span><br><span class="line">    res.setHeader(&#39;Access-Control-Allow-Origin&#39;, origin)</span><br><span class="line">    &#x2F;&#x2F; 允许携带哪个头访问我</span><br><span class="line">    res.setHeader(&#39;Access-Control-Allow-Headers&#39;, &#39;name&#39;)</span><br><span class="line">    &#x2F;&#x2F; 允许哪个方法访问我</span><br><span class="line">    res.setHeader(&#39;Access-Control-Allow-Methods&#39;, &#39;PUT&#39;)</span><br><span class="line">    &#x2F;&#x2F; 允许携带cookie</span><br><span class="line">    res.setHeader(&#39;Access-Control-Allow-Credentials&#39;, true)</span><br><span class="line">    &#x2F;&#x2F; 预检的存活时间</span><br><span class="line">    res.setHeader(&#39;Access-Control-Max-Age&#39;, 6)</span><br><span class="line">    &#x2F;&#x2F; 允许返回的头</span><br><span class="line">    res.setHeader(&#39;Access-Control-Expose-Headers&#39;, &#39;name&#39;)</span><br><span class="line">    if (req.method &#x3D;&#x3D;&#x3D; &#39;OPTIONS&#39;) &#123;</span><br><span class="line">      res.end() &#x2F;&#x2F; OPTIONS请求不做任何处理</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br><span class="line">app.put(&#39;&#x2F;getData&#39;, function(req, res) &#123;</span><br><span class="line">  console.log(req.headers)</span><br><span class="line">  res.setHeader(&#39;name&#39;, &#39;jw&#39;) &#x2F;&#x2F;返回一个响应头，后台需设置</span><br><span class="line">  res.end(&#39;我不爱你&#39;)</span><br><span class="line">&#125;)</span><br><span class="line">app.get(&#39;&#x2F;getData&#39;, function(req, res) &#123;</span><br><span class="line">  console.log(req.headers)</span><br><span class="line">  res.end(&#39;我不爱你&#39;)</span><br><span class="line">&#125;)</span><br><span class="line">app.use(express.static(__dirname))</span><br><span class="line">app.listen(4000)</span><br></pre></td></tr></table></figure>

上述代码由`http://localhost:3000/index.html`向`http://localhost:4000/`跨域请求，正如我们上面所说的，后端是实现 CORS 通信的关键。

**给大家推荐一个好用的BUG监控工具Fundebug，欢迎免费试用！**

#### 3. postMessage

postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：

- 页面和其打开的新窗口的数据传递
- 多窗口之间消息传递
- 页面与嵌套的iframe消息传递
- 上面三个场景的跨域数据传递

**postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递**。

> otherWindow.postMessage(message, targetOrigin, [transfer]);

- message: 将要发送到其他 window的数据。
- targetOrigin:通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串"*"（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。
- transfer(可选)：是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。

接下来我们看个例子： `http://localhost:3000/a.html`页面向`http://localhost:4000/b.html`传递“我爱你”,然后后者传回"我不爱你"。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a.html</span><br><span class="line">  &lt;iframe src&#x3D;&quot;http:&#x2F;&#x2F;localhost:4000&#x2F;b.html&quot; frameborder&#x3D;&quot;0&quot; id&#x3D;&quot;frame&quot; onload&#x3D;&quot;load()&quot;&gt;&lt;&#x2F;iframe&gt; &#x2F;&#x2F;等它加载完触发一个事件</span><br><span class="line">  &#x2F;&#x2F;内嵌在http:&#x2F;&#x2F;localhost:3000&#x2F;a.html</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      function load() &#123;</span><br><span class="line">        let frame &#x3D; document.getElementById(&#39;frame&#39;)</span><br><span class="line">        frame.contentWindow.postMessage(&#39;我爱你&#39;, &#39;http:&#x2F;&#x2F;localhost:4000&#39;) &#x2F;&#x2F;发送数据</span><br><span class="line">        window.onmessage &#x3D; function(e) &#123; &#x2F;&#x2F;接受返回数据</span><br><span class="line">          console.log(e.data) &#x2F;&#x2F;我不爱你</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&#x2F;&#x2F; b.html</span><br><span class="line">  window.onmessage &#x3D; function(e) &#123;</span><br><span class="line">    console.log(e.data) &#x2F;&#x2F;我爱你</span><br><span class="line">    e.source.postMessage(&#39;我不爱你&#39;, e.origin)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

#### 4. websocket

Websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket和HTTP都是应用层协议，都基于 TCP 协议。但是 **WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据**。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。

原生WebSocket API使用起来不太方便，我们使用`Socket.io`，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。

我们先来看个例子：本地文件socket.html向`localhost:3000`发生数据和接受数据

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; socket.html</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    let socket &#x3D; new WebSocket(&#39;ws:&#x2F;&#x2F;localhost:3000&#39;);</span><br><span class="line">    socket.onopen &#x3D; function () &#123;</span><br><span class="line">      socket.send(&#39;我爱你&#39;);&#x2F;&#x2F;向服务器发送数据</span><br><span class="line">    &#125;</span><br><span class="line">    socket.onmessage &#x3D; function (e) &#123;</span><br><span class="line">      console.log(e.data);&#x2F;&#x2F;接收服务器返回的数据</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&#x2F;&#x2F; server.js</span><br><span class="line">let express &#x3D; require(&#39;express&#39;);</span><br><span class="line">let app &#x3D; express();</span><br><span class="line">let WebSocket &#x3D; require(&#39;ws&#39;);&#x2F;&#x2F;记得安装ws</span><br><span class="line">let wss &#x3D; new WebSocket.Server(&#123;port:3000&#125;);</span><br><span class="line">wss.on(&#39;connection&#39;,function(ws) &#123;</span><br><span class="line">  ws.on(&#39;message&#39;, function (data) &#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">    ws.send(&#39;我不爱你&#39;)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

#### 5. Node中间件代理(两次跨域)

实现原理：**同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。**
代理服务器，需要做以下几个步骤：

- 接受客户端请求 。
- 将请求 转发给服务器。
- 拿到服务器 响应 数据。
- 将 响应 转发给客户端。

![img](https://image.fundebug.com/2019-01-26-03.png)

我们先来看个例子：本地文件index.html文件，通过代理服务器`http://localhost:3000`向目标服务器`http://localhost:4000`请求数据。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; index.html(http:&#x2F;&#x2F;127.0.0.1:5500)</span><br><span class="line"> &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;jquery&#x2F;3.3.1&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      $.ajax(&#123;</span><br><span class="line">        url: &#39;http:&#x2F;&#x2F;localhost:3000&#39;,</span><br><span class="line">        type: &#39;post&#39;,</span><br><span class="line">        data: &#123; name: &#39;xiamen&#39;, password: &#39;123456&#39; &#125;,</span><br><span class="line">        contentType: &#39;application&#x2F;json;charset&#x3D;utf-8&#39;,</span><br><span class="line">        success: function(result) &#123;</span><br><span class="line">          console.log(result) &#x2F;&#x2F; &#123;&quot;title&quot;:&quot;fontend&quot;,&quot;password&quot;:&quot;123456&quot;&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        error: function(msg) &#123;</span><br><span class="line">          console.log(msg)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">     &lt;&#x2F;script&gt;</span><br><span class="line">&#x2F;&#x2F; server1.js 代理服务器(http:&#x2F;&#x2F;localhost:3000)</span><br><span class="line">const http &#x3D; require(&#39;http&#39;)</span><br><span class="line">&#x2F;&#x2F; 第一步：接受客户端请求</span><br><span class="line">const server &#x3D; http.createServer((request, response) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 代理服务器，直接和浏览器直接交互，需要设置CORS 的首部字段</span><br><span class="line">  response.writeHead(200, &#123;</span><br><span class="line">    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,</span><br><span class="line">    &#39;Access-Control-Allow-Methods&#39;: &#39;*&#39;,</span><br><span class="line">    &#39;Access-Control-Allow-Headers&#39;: &#39;Content-Type&#39;</span><br><span class="line">  &#125;)</span><br><span class="line">  &#x2F;&#x2F; 第二步：将请求转发给服务器</span><br><span class="line">  const proxyRequest &#x3D; http</span><br><span class="line">    .request(</span><br><span class="line">      &#123;</span><br><span class="line">        host: &#39;127.0.0.1&#39;,</span><br><span class="line">        port: 4000,</span><br><span class="line">        url: &#39;&#x2F;&#39;,</span><br><span class="line">        method: request.method,</span><br><span class="line">        headers: request.headers</span><br><span class="line">      &#125;,</span><br><span class="line">      serverResponse &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 第三步：收到服务器的响应</span><br><span class="line">        var body &#x3D; &#39;&#39;</span><br><span class="line">        serverResponse.on(&#39;data&#39;, chunk &#x3D;&gt; &#123;</span><br><span class="line">          body +&#x3D; chunk</span><br><span class="line">        &#125;)</span><br><span class="line">        serverResponse.on(&#39;end&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">          console.log(&#39;The data is &#39; + body)</span><br><span class="line">          &#x2F;&#x2F; 第四步：将响应结果转发给浏览器</span><br><span class="line">          response.end(body)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">    .end()</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(3000, () &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;The proxyServer is running at http:&#x2F;&#x2F;localhost:3000&#39;)</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; server2.js(http:&#x2F;&#x2F;localhost:4000)</span><br><span class="line">const http &#x3D; require(&#39;http&#39;)</span><br><span class="line">const data &#x3D; &#123; title: &#39;fontend&#39;, password: &#39;123456&#39; &#125;</span><br><span class="line">const server &#x3D; http.createServer((request, response) &#x3D;&gt; &#123;</span><br><span class="line">  if (request.url &#x3D;&#x3D;&#x3D; &#39;&#x2F;&#39;) &#123;</span><br><span class="line">    response.end(JSON.stringify(data))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(4000, () &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;The server is running at http:&#x2F;&#x2F;localhost:4000&#39;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

上述代码经过两次跨域，值得注意的是浏览器向代理服务器发送请求，也遵循同源策略，最后在index.html文件打印出`{"title":"fontend","password":"123456"}`

#### 6. nginx反向代理

实现原理类似于Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求。

使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。

实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。

先下载[nginx](http://nginx.org/en/download.html)，然后将nginx目录下的nginx.conf修改如下:

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; proxy服务器</span><br><span class="line">server &#123;</span><br><span class="line">    listen       81;</span><br><span class="line">    server_name  www.domain1.com;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass   http:&#x2F;&#x2F;www.domain2.com:8080;  #反向代理</span><br><span class="line">        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line"></span><br><span class="line">        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用</span><br><span class="line">        add_header Access-Control-Allow-Origin http:&#x2F;&#x2F;www.domain1.com;  #当前端只跨域不带cookie时，可为*</span><br><span class="line">        add_header Access-Control-Allow-Credentials true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

最后通过命令行`nginx -s reload`启动nginx

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; index.html</span><br><span class="line">var xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">&#x2F;&#x2F; 前端开关：浏览器是否读写cookie</span><br><span class="line">xhr.withCredentials &#x3D; true;</span><br><span class="line">&#x2F;&#x2F; 访问nginx中的代理服务器</span><br><span class="line">xhr.open(&#39;get&#39;, &#39;http:&#x2F;&#x2F;www.domain1.com:81&#x2F;?user&#x3D;admin&#39;, true);</span><br><span class="line">xhr.send();</span><br><span class="line">&#x2F;&#x2F; server.js</span><br><span class="line">var http &#x3D; require(&#39;http&#39;);</span><br><span class="line">var server &#x3D; http.createServer();</span><br><span class="line">var qs &#x3D; require(&#39;querystring&#39;);</span><br><span class="line">server.on(&#39;request&#39;, function(req, res) &#123;</span><br><span class="line">    var params &#x3D; qs.parse(req.url.substring(2));</span><br><span class="line">    &#x2F;&#x2F; 向前台写cookie</span><br><span class="line">    res.writeHead(200, &#123;</span><br><span class="line">        &#39;Set-Cookie&#39;: &#39;l&#x3D;a123456;Path&#x3D;&#x2F;;Domain&#x3D;www.domain2.com;HttpOnly&#39;   &#x2F;&#x2F; HttpOnly:脚本无法读取</span><br><span class="line">    &#125;);</span><br><span class="line">    res.write(JSON.stringify(params));</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(&#39;8080&#39;);</span><br><span class="line">console.log(&#39;Server is running at port 8080...&#39;);</span><br></pre></td></tr></table></figure>

#### 7. window.name + iframe

window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。

其中a.html和b.html是同域的，都是`http://localhost:3000`;而c.html是`http://localhost:4000`

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a.html(http:&#x2F;&#x2F;localhost:3000&#x2F;b.html)</span><br><span class="line"> &lt;iframe src&#x3D;&quot;http:&#x2F;&#x2F;localhost:4000&#x2F;c.html&quot; frameborder&#x3D;&quot;0&quot; onload&#x3D;&quot;load()&quot; id&#x3D;&quot;iframe&quot;&gt;&lt;&#x2F;iframe&gt;</span><br><span class="line"> &lt;script&gt;</span><br><span class="line">   let first &#x3D; true</span><br><span class="line">   &#x2F;&#x2F; onload事件会触发2次，第1次加载跨域页，并留存数据于window.name</span><br><span class="line">   function load() &#123;</span><br><span class="line">     if(first)&#123;</span><br><span class="line">     &#x2F;&#x2F; 第1次onload(跨域页)成功后，切换到同域代理页面</span><br><span class="line">       let iframe &#x3D; document.getElementById(&#39;iframe&#39;);</span><br><span class="line">       iframe.src &#x3D; &#39;http:&#x2F;&#x2F;localhost:3000&#x2F;b.html&#39;;</span><br><span class="line">       first &#x3D; false;</span><br><span class="line">     &#125;else&#123;</span><br><span class="line">     &#x2F;&#x2F; 第2次onload(同域b.html页)成功后，读取同域window.name中数据</span><br><span class="line">       console.log(iframe.contentWindow.name);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

b.html为中间代理页，与a.html同域，内容为空。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; c.html(http:&#x2F;&#x2F;localhost:4000&#x2F;c.html)</span><br><span class="line"> &lt;script&gt;</span><br><span class="line">   window.name &#x3D; &#39;我不爱你&#39;  </span><br><span class="line"> &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。

#### 8. location.hash + iframe

实现原理： a.html欲与c.html跨域相互通信，通过中间页b.html来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。

具体实现步骤：一开始a.html给c.html传一个hash值，然后c.html收到hash值后，再把hash值传递给b.html，最后b.html将结果放到a.html的hash值中。
同样的，a.html和b.html是同域的，都是`http://localhost:3000`;而c.html是`http://localhost:4000`

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a.html</span><br><span class="line"> &lt;iframe src&#x3D;&quot;http:&#x2F;&#x2F;localhost:4000&#x2F;c.html#iloveyou&quot;&gt;&lt;&#x2F;iframe&gt;</span><br><span class="line"> &lt;script&gt;</span><br><span class="line">   window.onhashchange &#x3D; function () &#123; &#x2F;&#x2F;检测hash的变化</span><br><span class="line">     console.log(location.hash);</span><br><span class="line">   &#125;</span><br><span class="line"> &lt;&#x2F;script&gt;</span><br><span class="line">&#x2F;&#x2F; b.html</span><br><span class="line"> &lt;script&gt;</span><br><span class="line">   window.parent.parent.location.hash &#x3D; location.hash </span><br><span class="line">   &#x2F;&#x2F;b.html将结果放到a.html的hash值中，b.html可通过parent.parent访问a.html页面</span><br><span class="line"> &lt;&#x2F;script&gt;</span><br><span class="line">&#x2F;&#x2F; c.html</span><br><span class="line">console.log(location.hash);</span><br><span class="line"> let iframe &#x3D; document.createElement(&#39;iframe&#39;);</span><br><span class="line"> iframe.src &#x3D; &#39;http:&#x2F;&#x2F;localhost:3000&#x2F;b.html#idontloveyou&#39;;</span><br><span class="line"> document.body.appendChild(iframe);</span><br></pre></td></tr></table></figure>

#### 9. document.domain + iframe

**该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式**。
只需要给页面添加 `document.domain ='test.com'` 表示二级域名都相同就可以实现跨域。

实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。

我们看个例子：页面`a.zf1.cn:3000/a.html`获取页面`b.zf1.cn:3000/b.html`中a的值

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a.html</span><br><span class="line">&lt;body&gt;</span><br><span class="line"> helloa</span><br><span class="line">  &lt;iframe src&#x3D;&quot;http:&#x2F;&#x2F;b.zf1.cn:3000&#x2F;b.html&quot; frameborder&#x3D;&quot;0&quot; onload&#x3D;&quot;load()&quot; id&#x3D;&quot;frame&quot;&gt;&lt;&#x2F;iframe&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    document.domain &#x3D; &#39;zf1.cn&#39;</span><br><span class="line">    function load() &#123;</span><br><span class="line">      console.log(frame.contentWindow.a);</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&#x2F;&#x2F; b.html</span><br><span class="line">&lt;body&gt;</span><br><span class="line">   hellob</span><br><span class="line">   &lt;script&gt;</span><br><span class="line">     document.domain &#x3D; &#39;zf1.cn&#39;</span><br><span class="line">     var a &#x3D; 100;</span><br><span class="line">   &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

### 三、总结

- CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案
- JSONP只支持GET请求，JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。
- 不管是Node中间件代理还是nginx反向代理，主要是通过同源策略对服务器不加限制。
- 日常工作中，用得比较多的跨域方案是cors和nginx反向代理





### 87.说一下 JSONP 实现原理？

### 一、 同源策略

所有支持Javascript的浏览器都会使用同源策略这个安全策略。看看百度的解释：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">同源策略，它是由Netscape提出的一个著名的安全策略。</span><br><span class="line">现在所有支持JavaScript 的浏览器都会使用这个策略。所谓同源是指，域名，协议，端口相同。</span><br><span class="line">当一个浏览器的两个tab页中分别打开百度和谷歌的页面</span><br><span class="line">当一个百度浏览器执行一个脚本的时候会检查这个脚本是属于哪个页面的</span><br><span class="line">即检查是否同源，只有和百度同源的脚本才会被执行。</span><br></pre></td></tr></table></figure>

而解决这种同源策略的方法称之为**跨域**
跨域的方法有很多种,这里介绍一下最经典的jsonp跨域

### 二、JSON和JSONP

JSONP和JSON好像啊，他们之间有什么联系吗？

JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。对于JSON大家应该是很了解了吧，不是很清楚的朋友可以去[json.org](http://www.json.org/json-zh.html)上了解下，简单易懂。

**JSONP是JSON with Padding的略称。它是一个非官方的协议，它允许在服务器端集成Script tags返回至客户端，通过javascript callback的形式实现跨域访问（这仅仅是JSONP简单的实现形式）。**--来源百度

　　JSONP就像是JSON+Padding一样(Padding这里我们理解为填充)， 我们先看下面的小例子然后再详细介绍。
　　

### 三、跨域的简单原理

光看定义还不是很明白，那首先我们先来手动做个简单易懂的小测试。新建一个asp.net的web程序，添加**sample.html**网页和一个**test.js**文件，代码如下：

sample.html的代码：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;sample.html</span><br><span class="line">&lt;!DOCTYPE&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;test&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;test.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

test.js的代码：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;test.js</span><br><span class="line"></span><br><span class="line">alert(&quot;success&quot;);</span><br></pre></td></tr></table></figure>

打开sample.html后会跳出"success”这样的这样的信息框，这似乎并不能说明什么， 跨域问题到底怎么解决呢？

好，现在我们模拟下**非同源的环境**，刚才我们不是已经用Visual Studio新建了一个Web程序吗(这里我们叫A程序)，现在我们再打开一个新的Visual Studio再新建一个Web程序(B程序)，将我们的之前的test.js文件从A程序中移除然后拷贝到B程序中。

两个程序都运行起来后，Visual Studio会启动内置服务器，假设A程序是localhost:20001,B程序是localhost:20002，这就模拟了一个非同源的环境了(虽然域名相同但端口号不同，所以是非同源的)。

OK，我们接下来应该改下sample.html里的代码，因为test.js文件在B程序上了，url也就变成了localhost:20002。

sample.html部分代码:

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;http:&#x2F;&#x2F;localhost:20002&#x2F;test.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

请保持AB两个Web程序的运行状态，当你再次刷新localhost:20001/sample.html的时候，和原来一样跳出了"success"的对话框.

是的，成功访问到了**非同源的localhost:20002/test.js**这个所谓的远程服务了。到了这一步，相信大家应该已经大概明白如何跨域访问了的原理了。

　　<script>标签的src属性并不被同源策略所约束，所以可以获取任何服务器上脚本并执行。

### 四、JSONP的实现模式--CallBack

刚才的小例子讲解了跨域的原理，我们回上去再看看JSONP的定义说明中讲到了`javascript callback`的形式。那我们就来修改下代码，如何实现JSONP的javascript callback的形式。

程序A中sample的部分代码：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">&#x2F;&#x2F;回调函数</span><br><span class="line">function callback(data) &#123;</span><br><span class="line">    alert(data.message);</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;http:&#x2F;&#x2F;localhost:20002&#x2F;test.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

程序B中test.js的代码：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;调用callback函数，并以json数据形式作为阐述传递，完成回调</span><br><span class="line"></span><br><span class="line">callback(&#123;message:&quot;success&quot;&#125;);</span><br></pre></td></tr></table></figure>

这其实就是JSONP的简单实现模式，或者说是JSONP的原型：**创建一个回调函数，然后在远程服务上调用这个函数并且将JSON 数据形式作为参数传递，完成回调。**

**将JSON数据填充进回调函数**，这就是JSONP的JSON+Padding的含义吧。

一般情况下，我们希望这个script标签能够动态的调用，而不是像上面因为固定在html里面所以没等页面显示就执行了，很不灵活。我们可以通过javascript动态的创建script标签，这样我们就可以灵活调用远程服务了。

程序A中sample的部分代码：
\```

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">程序B的test.js代码不变，我们再执行下程序，是不是和原来的一样呢。  </span><br><span class="line"></span><br><span class="line">如果我们再想调用一个远程服务的话，只要添加&#96;addScriptTag&#96;方法，传入远程服务的src值就可以了。 </span><br><span class="line"></span><br><span class="line">这里说明下为什么要将addScriptTag方法放入到&#96;window.onload&#96;的方法里，原因是addScriptTag方法中有句&#96;document.body.appendChild(script);&#96;，这个script标签是被添加到body里的，由于我们写的javascript代码是在head标签中，document.body还没有初始化完毕呢，所以我们要通过window.onload方法先初始化页面，这样才不会出错。</span><br><span class="line"></span><br><span class="line">上面的例子是最简单的JSONP的实现模型，不过它还算不上一个真正的JSONP服务。  </span><br><span class="line"></span><br><span class="line">我们来看一下真正的JSONP服务是怎么样的，比如Google的ajax搜索接口：http:&#x2F;&#x2F;ajax.googleapis.com&#x2F;ajax&#x2F;services&#x2F;search&#x2F;web?v&#x3D;1.0&amp;q&#x3D;?&amp;callback&#x3D;? </span><br><span class="line"></span><br><span class="line">q&#x3D;?这个问号是表示你要搜索的内容，最重要的是第二个&#96;callback&#x3D;?&#96;这个是正如其名表示回调函数的名称，也就是将你自己在客户端定义的回调函数的函数名传送给服务端，服务端则会返回以你定义的回调函数名的方法，将获取的json数据传入这个方法完成回调。有点罗嗦了，还是看看实现代码吧:</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">### 五、jQuery对JSONP的实现</span><br><span class="line">jQuery框架也当然支持JSONP，可以使用&#96;$.getJSON(url,[data],[callback])&#96;方法(详细可以参考&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;api.jquery.com&#x2F;jQuery.getJSON&#x2F;&quot; target&#x3D;&quot;_blank&quot;&gt;JQ实现jsonp&lt;&#x2F;a&gt;)。  </span><br><span class="line"></span><br><span class="line">那我们就来修改下程序A的代码，改用jQuery的getJSON方法来实现(下面的例子没用用到向服务传参，所以只写了getJSON(url,[callback]))：</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">结果是一样的，&lt;b&gt;要注意的是在url的后面必须添加一个callback参数，这样getJSON方法才会知道是用JSONP方式去访问服务&lt;&#x2F;b&gt;，callback后面的那个问号是内部自动生成的一个回调函数名。这个函数名大家可以debug一下看看，比如jQuery17207481773362960666_1332575486681。</span><br><span class="line"></span><br><span class="line">　　当然，加入说我们想&lt;b&gt;指定自己的回调函数名&lt;&#x2F;b&gt;，或者说服务上规定了固定回调函数名该怎么办呢？我们可以使用&#96;$.ajax&#96;方法来实现(参数较多，详细可以参考http:&#x2F;&#x2F;api.jquery.com&#x2F;jQuery.ajax)。先来看看如何实现吧：</span><br></pre></td></tr></table></figure>

\```

没错，jsonpCallback就是可以指定我们自己的回调方法名person，远程服务接受callback参数的值就不再是自动生成的回调名，而是person。dataType是指定按照JSOPN方式访问远程服务

## 九、设计模式

### 88.说一下你熟悉的设计模式？

**一、什么是设计模式**                                                                                                                                       

设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理的运用设计模式可以完美的解决很多问题，每种模式在现在中都有相应的原理来与之对应，每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是它能被广泛应用的原因。简单说：

**模式：在某些场景下，针对某类问题的某种通用的解决方案。**

场景：项目所在的环境

问题：约束条件，项目目标等

解决方案：通用、可复用的设计，解决约束达到目标。

**二、设计模式的三个分类**                                                                                                                                

**创建型模式：对象实例化的模式，创建型模式用于解耦对象的实例化过程。**

**结构型模式：把类或对象结合在一起形成一个更大的结构。**

**行为型模式：类和对象如何交互，及划分责任和算法。**

**如下图所示：**

**![img](https://images2017.cnblogs.com/blog/401339/201709/401339-20170928225241215-295252070.png)**

**三、各分类中模式的关键点**                                                                                                                             

单例模式：某个类只能有一个实例，提供一个全局的访问点。

简单工厂：一个工厂类根据传入的参量决定创建出那一种产品类的实例。

工厂方法：定义一个创建对象的接口，让子类决定实例化那个类。

抽象工厂：创建相关或依赖对象的家族，而无需明确指定具体类。

建造者模式：封装一个复杂对象的构建过程，并可以按步骤构造。

原型模式：通过复制现有的实例来创建新的实例。



适配器模式：将一个类的方法接口转换成客户希望的另外一个接口。

组合模式：将对象组合成树形结构以表示“”部分-整体“”的层次结构。

装饰模式：动态的给对象添加新的功能。

代理模式：为其他对象提供一个代理以便控制这个对象的访问。

亨元（蝇量）模式：通过共享技术来有效的支持大量细粒度的对象。

外观模式：对外提供一个统一的方法，来访问子系统中的一群接口。

桥接模式：将抽象部分和它的实现部分分离，使它们都可以独立的变化。



模板模式：定义一个算法结构，而将一些步骤延迟到子类实现。

解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器。

策略模式：定义一系列算法，把他们封装起来，并且使它们可以相互替换。

状态模式：允许一个对象在其对象内部状态改变时改变它的行为。

观察者模式：对象间的一对多的依赖关系。

备忘录模式：在不破坏封装的前提下，保持对象的内部状态。

中介者模式：用一个中介对象来封装一系列的对象交互。

命令模式：将命令请求封装为一个对象，使得可以用不同的请求来进行参数化。

访问者模式：在不改变数据结构的前提下，增加作用于一组对象元素的新功能。

责任链模式：将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会。

迭代器模式：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。



**四、概说23种设计模式**                                                                                                                                    

1.单例模式                                                                                                                                            

单例模式，它的定义就是确保某一个类只有一个实例，并且提供一个全局访问点。

单例模式具备典型的3个特点：1、只有一个实例。 2、自我实例化。 3、提供全局访问点。

 因此当系统中只需要一个实例对象或者系统中只允许一个公共访问点，除了这个公共访问点外，不能通过其他访问点访问该实例时，可以使用单例模式。

单例模式的主要优点就是节约系统资源、提高了系统效率，同时也能够严格控制客户对它的访问。也许就是因为系统中只有一个实例，这样就导致了单例类的职责过重，违背了“单一职责原则”，同时也没有抽象类，所以扩展起来有一定的困难。其UML结构图非常简单，就只有一个类，如下图：

![img](https://images2017.cnblogs.com/blog/401339/201709/401339-20170929202530606-709085396.png)



2.工厂方法模式                                                                                                                                     

作为抽象工厂模式的孪生兄弟，工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个，也就是说工厂方法模式让实例化推迟到子类。

工厂方法模式非常符合“开闭原则”，当需要增加一个新的产品时，我们只需要增加一个具体的产品类和与之对应的具体工厂即可，无须修改原有系统。同时在工厂方法模式中用户只需要知道生产产品的具体工厂即可，无须关系产品的创建过程，甚至连具体的产品类名称都不需要知道。虽然他很好的符合了“开闭原则”，但是由于每新增一个新产品时就需要增加两个类，这样势必会导致系统的复杂度增加。其UML结构图：

![img](https://images2017.cnblogs.com/blog/401339/201709/401339-20170929204041684-1520979160.png)



3.抽象工厂模式                                                                                                                                    

所谓抽象工厂模式就是提供一个接口，用于创建相关或者依赖对象的家族，而不需要明确指定具体类。他允许客户端使用抽象的接口来创建一组相关的产品，而不需要关系实际产出的具体产品是什么。这样一来，客户就可以从具体的产品中被解耦。它的优点是隔离了具体类的生成，使得客户端不需要知道什么被创建了，而缺点就在于新增新的行为会比较麻烦，因为当添加一个新的产品对象时，需要更加需要更改接口及其下所有子类。其UML结构图如下：

 ![img](https://images2017.cnblogs.com/blog/401339/201709/401339-20170929204151184-2094793629.png)



4.建造者模式                                                                                                                                          

对于建造者模式而已，它主要是将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。适用于那些产品对象的内部结构比较复杂。

建造者模式将复杂产品的构建过程封装分解在不同的方法中，使得创建过程非常清晰，能够让我们更加精确的控制复杂产品对象的创建过程，同时它隔离了复杂产品对象的创建和使用，使得相同的创建过程能够创建不同的产品。但是如果某个产品的内部结构过于复杂，将会导致整个系统变得非常庞大，不利于控制，同时若几个产品之间存在较大的差异，则不适用建造者模式，毕竟这个世界上存在相同点大的两个产品并不是很多，所以它的使用范围有限。其UML结构图：

![img](https://images2017.cnblogs.com/blog/401339/201709/401339-20170929204518044-666328371.png)





5.原型模式                                                                                                                                             

在我们应用程序可能有某些对象的结构比较复杂，但是我们又需要频繁的使用它们，如果这个时候我们来不断的新建这个对象势必会大大损耗系统内存的，这个时候我们需要使用原型模式来对这个结构复杂又要频繁使用的对象进行克隆。所以原型模式就是用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。

它主要应用与那些创建新对象的成本过大时。它的主要优点就是简化了新对象的创建过程，提高了效率，同时原型模式提供了简化的创建结构。UML结构图：

![img](https://images2017.cnblogs.com/blog/401339/201709/401339-20170929205441153-1950745368.png)



**模式结构**
原型模式包含如下角色：
Prototype：抽象原型类
ConcretePrototype：具体原型类
Client：客户类

6.适配器模式                                                                                                                                            

在我们的应用程序中我们可能需要将两个不同接口的类来进行通信，在不修改这两个的前提下我们可能会需要某个中间件来完成这个衔接的过程。这个中间件就是适配器。所谓适配器模式就是将一个类的接口，转换成客户期望的另一个接口。它可以让原本两个不兼容的接口能够无缝完成对接。

作为中间件的适配器将目标类和适配者解耦，增加了类的透明性和可复用性。

![img](https://images2017.cnblogs.com/blog/401339/201709/401339-20170929205627606-1781915371.png)



适配器模式包含如下角色：
Target：目标抽象类
Adapter：适配器类
Adaptee：适配者类
Client：客户类

7.桥接模式                                                                                                                                              

如果说某个系统能够从多个角度来进行分类，且每一种分类都可能会变化，那么我们需要做的就是讲这多个角度分离出来，使得他们能独立变化，减少他们之间的耦合，这个分离过程就使用了桥接模式。所谓桥接模式就是讲抽象部分和实现部分隔离开来，使得他们能够独立变化。

桥接模式将继承关系转化成关联关系，封装了变化，完成了解耦，减少了系统中类的数量，也减少了代码量。

![img](https://images2017.cnblogs.com/blog/401339/201709/401339-20170929205836028-1108970959.png)

桥接模式包含如下角色：
Abstraction：抽象类
RefinedAbstraction：扩充抽象类
Implementor：实现类接口
ConcreteImplementor：具体实现类



8.组合模式                                                                                                                                              

组合模式组合多个对象形成树形结构以表示“整体-部分”的结构层次。它定义了如何将容器对象和叶子对象进行递归组合，使得客户在使用的过程中无须进行区分，可以对他们进行一致的处理。在使用组合模式中需要注意一点也是组合模式最关键的地方：叶子对象和组合对象实现相同的接口。这就是组合模式能够将叶子节点和对象节点进行一致处理的原因。

虽然组合模式能够清晰地定义分层次的复杂对象，也使得增加新构件也更容易，但是这样就导致了系统的设计变得更加抽象，如果系统的业务规则比较复杂的话，使用组合模式就有一定的挑战了。

![img](https://images2017.cnblogs.com/blog/401339/201709/401339-20170929210011122-1282025445.png)



 **模式结构**
组合模式包含如下角色：
Component: 抽象构件
Leaf: 叶子构件
Composite: 容器构件
Client: 客户类

9.装饰模式                                                                                                                                                  

我们可以通过继承和组合的方式来给一个对象添加行为，虽然使用继承能够很好拥有父类的行为，但是它存在几个缺陷：一、对象之间的关系复杂的话，系统变得复杂不利于维护。二、容易产生“类爆炸”现象。三、是静态的。在这里我们可以通过使用装饰者模式来解决这个问题。

装饰者模式，动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更加有弹性的替代方案。虽然装饰者模式能够动态将责任附加到对象上，但是他会产生许多的细小对象，增加了系统的复杂度。

![img](https://images2017.cnblogs.com/blog/401339/201709/401339-20170929210140794-1843692006.png)

**模式结构**
装饰模式包含如下角色：
Component: 抽象构件
ConcreteComponent: 具体构件
Decorator: 抽象装饰类
ConcreteDecorator: 具体装饰类



10.外观模式                                                                                                                                                

我们都知道类与类之间的耦合越低，那么可复用性就越好，如果两个类不必彼此通信，那么就不要让这两个类发生直接的相互关系，如果需要调用里面的方法，可以通过第三者来转发调用。外观模式非常好的诠释了这段话。外观模式提供了一个统一的接口，用来访问子系统中的一群接口。它让一个应用程序中子系统间的相互依赖关系减少到了最少，它给子系统提供了一个简单、单一的屏障，客户通过这个屏障来与子系统进行通信。通过使用外观模式，使得客户对子系统的引用变得简单了，实现了客户与子系统之间的松耦合。但是它违背了“开闭原则”，因为增加新的子系统可能需要修改外观类或客户端的源代码。

![img](https://images2017.cnblogs.com/blog/401339/201709/401339-20170929210303044-1520176505.png)

外观模式包含如下角色：
Facade: 外观角色
SubSystem:子系统角色

11.亨元模式                                                                                                                                                

在一个系统中对象会使得内存占用过多，特别是那些大量重复的对象，这就是对系统资源的极大浪费。享元模式对对象的重用提供了一种解决方案，它使用共享技术对相同或者相似对象实现重用。享元模式就是运行共享技术有效地支持大量细粒度对象的复用。系统使用少量对象,而且这些都比较相似，状态变化小，可以实现对象的多次复用。这里有一点要注意：享元模式要求能够共享的对象必须是细粒度对象。享元模式通过共享技术使得系统中的对象个数大大减少了，同时享元模式使用了内部状态和外部状态，同时外部状态相对独立，不会影响到内部状态，所以享元模式能够使得享元对象在不同的环境下被共享。同时正是分为了内部状态和外部状态，享元模式会使得系统变得更加复杂，同时也会导致读取外部状态所消耗的时间过长。

![img](https://images2017.cnblogs.com/blog/401339/201709/401339-20170929210423544-273577223.png)

享元模式包含如下角色：
Flyweight: 抽象享元类
ConcreteFlyweight: 具体享元类
UnsharedConcreteFlyweight: 非共享具体享元类
FlyweightFactory: 享元工厂类

12.代理模式                                                                                                                                               

 代理模式就是给一个对象提供一个代理，并由代理对象控制对原对象的引用。它使得客户不能直接与真正的目标对象通信。代理对象是目标对象的代表，其他需要与这个目标对象打交道的操作都是和这个代理对象在交涉。

代理对象可以在客户端和目标对象之间起到中介的作用，这样起到了的作用和保护了目标对象的，同时也在一定程度上面减少了系统的耦合度。

![img](https://images2017.cnblogs.com/blog/401339/201709/401339-20170929210617169-1348842872.png)

代理模式包含如下角色：
 Subject: 抽象主题角色
 Proxy: 代理主题角色
 RealSubject: 真实主题角色

13.访问者模式                                                                                                                                           

访问者模式俗称23大设计模式中最难的一个。除了结构复杂外，理解也比较难。在我们软件开发中我们可能会对同一个对象有不同的处理，如果我们都做分别的处理，将会产生灾难性的错误。对于这种问题，访问者模式提供了比较好的解决方案。访问者模式即表示一个作用于某对象结构中的各元素的操作，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

访问者模式的目的是封装一些施加于某种数据结构元素之上的操作，一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。为不同类型的元素提供多种访问操作方式，且可以在不修改原有系统的情况下增加新的操作方式。同时我们还需要明确一点那就是访问者模式是适用于那些数据结构比较稳定的，因为他是将数据的操作与数据结构进行分离了，如果某个系统的数据结构相对稳定，但是操作算法易于变化的话，就比较适用适用访问者模式，因为访问者模式使得算法操作的增加变得比较简单了。

![img](https://images2017.cnblogs.com/blog/401339/201709/401339-20170929210854090-2120695915.png)

访问者模式包含如下角色：
Vistor: 抽象访问者
ConcreteVisitor: 具体访问者
Element: 抽象元素
ConcreteElement: 具体元素 
ObjectStructure: 对象结构

14.模板模式                                                                                                                                              

有些时候我们做某几件事情的步骤都差不多，仅有那么一小点的不同，在软件开发的世界里同样如此，如果我们都将这些步骤都一一做的话，费时费力不讨好。所以我们可以将这些步骤分解、封装起来，然后利用继承的方式来继承即可，当然不同的可以自己重写实现嘛！这就是模板方法模式提供的解决方案。

所谓模板方法模式就是在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。

模板方法模式就是基于继承的代码复用技术的。在模板方法模式中，我们可以将相同部分的代码放在父类中，而将不同的代码放入不同的子类中。也就是说我们需要声明一个抽象的父类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法让子类来实现剩余的逻辑，不同的子类可以以不同的方式来实现这些逻辑。所以模板方法的模板其实就是一个普通的方法，只不过这个方法是将算法实现的步骤封装起来的。

![img](https://images2017.cnblogs.com/blog/401339/201709/401339-20170929211025028-883324233.png)

模板方法模式包含如下角色：
AbstractClass: 抽象类 
ConcreteClass: 具体子类

15.策略模式                                                                                                                                             

 我们知道一件事可能会有很多种方式来实现它，但是其中总有一种最高效的方式，在软件开发的世界里面同样如此，我们也有很多中方法来实现一个功能，但是我们需要一种简单、高效的方式来实现它，使得系统能够非常灵活，这就是策略模式。

所以策略模式就是定义了算法族，分别封装起来，让他们之前可以互相转换，此模式然该算法的变化独立于使用算法的客户。

在策略模式中它将这些解决问题的方法定义成一个算法群，每一个方法都对应着一个具体的算法，这里的一个算法我就称之为一个策略。虽然策略模式定义了算法，但是它并不提供算法的选择，即什么算法对于什么问题最合适这是策略模式所不关心的，所以对于策略的选择还是要客户端来做。客户必须要清楚的知道每个算法之间的区别和在什么时候什么地方使用什么策略是最合适的，这样就增加客户端的负担。

同时策略模式也非常完美的符合了“开闭原则”，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。但是一个策略对应一个类将会是系统产生很多的策略类。

![img](https://images2017.cnblogs.com/blog/401339/201709/401339-20170929211201231-1986841784.png)

策略模式包含如下角色：
Context: 环境类
Strategy: 抽象策略类
ConcreteStrategy: 具体策略类

16.状态模式                                                                                                                                              

 在很多情况下我们对象的行为依赖于它的一个或者多个变化的属性，这些可变的属性我们称之为状态，也就是说行为依赖状态，即当该对象因为在外部的互动而导致他的状态发生变化，从而它的行为也会做出相应的变化。对于这种情况，我们是不能用行为来控制状态的变化，而应该站在状态的角度来思考行为，即是什么状态就要做出什么样的行为。这个就是状态模式。

所以状态模式就是允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。

在状态模式中我们可以减少大块的if…else语句，它是允许态转换逻辑与状态对象合成一体，但是减少if…else语句的代价就是会换来大量的类，所以状态模式势必会增加系统中类或者对象的个数。

同时状态模式是将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。但是这样就会导致系统的结构和实现都会比较复杂，如果使用不当就会导致程序的结构和代码混乱，不利于维护。

![img](https://images2017.cnblogs.com/blog/401339/201709/401339-20170929211342028-1513098324.png)



 状态模式包含如下角色：
Context: 环境类
State: 抽象状态类
ConcreteState: 具体状态类

17.观察者模式                                                                                                                                          

何谓观察者模式？观察者模式定义了对象之间的一对多依赖关系，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并且自动更新。

在这里，发生改变的对象称之为观察目标，而被通知的对象称之为观察者。一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，所以么可以根据需要增加和删除观察者，使得系统更易于扩展。所以观察者提供了一种对象设计，让主题和观察者之间以松耦合的方式结合。

![img](https://images2017.cnblogs.com/blog/401339/201709/401339-20170929211501637-186121583.png)



 观察者模式包含如下角色：
Subject: 目标
ConcreteSubject: 具体目标
Observer: 观察者
ConcreteObserver: 具体观察者

18.备忘录模式                                                                                                                                         

 后悔药人人都想要，但是事实却是残酷的，根本就没有后悔药可买，但是也不仅如此，在软件的世界里就有后悔药！备忘录模式就是一种后悔药，它给我们的软件提供后悔药的机制，通过它可以使系统恢复到某一特定的历史状态。

所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。它实现了对信息的封装，使得客户不需要关心状态保存的细节。保存就要消耗资源，所以备忘录模式的缺点就在于消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。

![img](https://images2017.cnblogs.com/blog/401339/201709/401339-20170929211612762-15763568.png)



备忘录模式包含如下角色：
Originator: 原发器
Memento: 备忘录
Caretaker: 负责人

19.中介者模式                                                                                                                                         

 租房各位都有过的经历吧！在这个过程中中介结构扮演着很重要的角色，它在这里起到一个中间者的作用，给我们和房主互相传递信息。在外面软件的世界里同样需要这样一个中间者。在我们的系统中有时候会存在着对象与对象之间存在着很强、复杂的关联关系，如果让他们之间有直接的联系的话，必定会导致整个系统变得非常复杂，而且可扩展性很差！在前面我们就知道如果两个类之间没有不必彼此通信，我们就不应该让他们有直接的关联关系，如果实在是需要通信的话，我们可以通过第三者来转发他们的请求。同样，这里我们利用中介者来解决这个问题。

所谓中介者模式就是用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。在中介者模式中，中介对象用来封装对象之间的关系，各个对象可以不需要知道具体的信息通过中介者对象就可以实现相互通信。它减少了对象之间的互相关系，提供了系统可复用性，简化了系统的结构。

 在中介者模式中，各个对象不需要互相知道了解，他们只需要知道中介者对象即可，但是中介者对象就必须要知道所有的对象和他们之间的关联关系，正是因为这样就导致了中介者对象的结构过于复杂，承担了过多的职责，同时它也是整个系统的核心所在，它有问题将会导致整个系统的问题。所以如果在系统的设计过程中如果出现“多对多”的复杂关系群时，千万别急着使用中介者模式，而是要仔细思考是不是您设计的系统存在问题。

![img](https://images2017.cnblogs.com/blog/401339/201709/401339-20170929211741247-840833944.png)

Mediator: 抽象中介者
ConcreteMediator: 具体中介者
Colleague: 抽象同事类
ConcreteColleague: 具体同事类

20.迭代器模式                                                                                                                                        

对于迭代在编程过程中我们经常用到，能够游走于聚合内的每一个元素，同时还可以提供多种不同的遍历方式，这就是迭代器模式的设计动机。在我们实际的开发过程中，我们可能会需要根据不同的需求以不同的方式来遍历整个对象，但是我们又不希望在聚合对象的抽象接口中充斥着各种不同的遍历操作，于是我们就希望有某个东西能够以多种不同的方式来遍历一个聚合对象，这时迭代器模式出现了。

何为迭代器模式？所谓迭代器模式就是提供一种方法顺序访问一个聚合对象中的各个元素，而不是暴露其内部的表示。迭代器模式是将迭代元素的责任交给迭代器，而不是聚合对象，我们甚至在不需要知道该聚合对象的内部结构就可以实现该聚合对象的迭代。

通过迭代器模式，使得聚合对象的结构更加简单，它不需要关注它元素的遍历，只需要专注它应该专注的事情，这样就更加符合单一职责原则了。

![img](https://images2017.cnblogs.com/blog/401339/201709/401339-20170929211907231-1120239995.png)

迭代器模式包含如下角色：
Iterator: 抽象迭代器
ConcreteIterator: 具体迭代器
Aggregate: 抽象聚合类
ConcreteAggregate: 具体聚合类

21.解释器模式                                                                                                                                        

所谓解释器模式就是定义语言的文法，并且建立一个解释器来解释该语言中的句子。解释器模式描述了如何构成一个简单的语言解释器，主要应用在使用面向对象语言开发的编译器中。它描述了如何为简单的语言定义一个文法，如何在该语言中表示一个句子，以及如何解释这些句子。

![img](https://images2017.cnblogs.com/blog/401339/201709/401339-20170929212030919-2061065218.png)

解释器模式包含如下角色：
AbstractExpression: 抽象表达式
TerminalExpression: 终结符表达式
NonterminalExpression: 非终结符表达式
Context: 环境类
Client: 客户类

22.命令模式                                                                                                                                           

 有些时候我们想某个对象发送一个请求，但是我们并不知道该请求的具体接收者是谁，具体的处理过程是如何的，们只知道在程序运行中指定具体的请求接收者即可，对于这样将请求封装成对象的我们称之为命令模式。所以命令模式将请求封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。同时命令模式支持可撤销的操作。

命令模式可以将请求的发送者和接收者之间实现完全的解耦，发送者和接收者之间没有直接的联系，发送者只需要知道如何发送请求命令即可，其余的可以一概不管，甚至命令是否成功都无需关心。同时我们可以非常方便的增加新的命令，但是可能就是因为方便和对请求的封装就会导致系统中会存在过多的具体命令类。

![img](https://images2017.cnblogs.com/blog/401339/201709/401339-20170929212209419-2076536302.png)

命令模式包含如下角色：
Command: 抽象命令类
ConcreteCommand: 具体命令类
Invoker: 调用者
Receiver: 接收者
Client:客户类

23.责任链模式                                                                                                                                       

职责链模式描述的请求如何沿着对象所组成的链来传递的。它将对象组成一条链，发送者将请求发给链的第一个接收者，并且沿着这条链传递，直到有一个对象来处理它或者直到最后也没有对象处理而留在链末尾端。

避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止，这就是职责链模式。在职责链模式中，使得每一个对象都有可能来处理请求，从而实现了请求的发送者和接收者之间的解耦。同时职责链模式简化了对象的结构，它使得每个对象都只需要引用它的后继者即可，而不必了解整条链，这样既提高了系统的灵活性也使得增加新的请求处理类也比较方便。但是在职责链中我们不能保证所有的请求都能够被处理，而且不利于观察运行时特征。

![img](https://images2017.cnblogs.com/blog/401339/201709/401339-20170929212323622-1583713986.png)



职责链模式包含如下角色：
Handler: 抽象处理者
ConcreteHandler: 具体处理者
Client: 客户类

**五、如何学习设计模式**                                                                                                                          

**说明，《如何学习设计模式》转摘自：http://blog.csdn.net/yqj2065/article/details/39103857**

#### ①    学习技巧

学习设计模式时，有一些技巧能够帮助你快速理解设计模式。

a)   使用较简单的**面向对象的语言**如Java、C#。GoF的[设计模式]实质上是**面向对象的设计模式**。[GoF·1.1]中提到“程序设计语言的选择非常重要，它将影响人们理解问题的出发点”。从学习设计模式的角度看，Java和C#较C++更容易一些。比如Java接口等，能够更有效展现设计模式的意图。

b)   使用**工具BlueJ**。BlueJ最大的好处，就是提供了简单的类图。正如我在[简明设计模式Java](http://blog.csdn.net/column/details/dp-in-java-yqj2065.html)中所做的，较少去专门画类图，而是在BlueJ中截图。在学生上机编写演示程序时，常常先看他的类图，以判断他的程序是否正确，必要时再看源代码。

c)   日常生活的**隐喻**。用一些实际生活中的例子来说明某某模式，能够让你快速掌握某模式的目的和实现代码的结构。同时，你要认识到，这种隐喻如同告诉你（2+3）2=22+2*2*3+32，你需要自己举一反三，得出（a+b）2=a2+2ab+b2。在实际工作中的模式的具体应用，则相当于应用代数公式。

d)    **动手实践和怀疑精神**。看**显浅的参考书或上网查阅资料**时，要自己敲(复制也可以)代码并运行，要多修改别人的源代码提出自己的观点：为什么书中不这样设计、为什么要那样设计；如果增添一些方法、方法参数、或成员变量会如何？必须要自己亲自动手，最起码要运行。另外，要敢于向博主提问、拍砖。你甚至可以质疑GoF的某些章节的解说和意图，更何况一些博主呢。

#### ②    基础知识

这些知识让你知道，设计模式好在何处。

a)    **面向对象范式**。也就是人们传说的思想。封装、继承和多态这些东西，在我看来比if、for等稍微高一点，也属于语法问题。面向对象编程要掌握的[三大原则](http://blog.csdn.net/yqj2065/article/details/8502681)是**柏拉图(Plato)原则、里氏(Liskov)替换原则和Parnas原则**。这三个原则其实非常简单。任何原则，你觉得很难一见钟情，很难快速认同，那它就不会是好原则。

b)    **设计原则。**许多人列举了7大原则，如单一职责原则、开闭原则、里氏代换原则、依赖倒转原则、接口隔离原则、合成复用原则、迪米特法则。LSP，我将它提升为面向对象范式的3大基石之一；单一职责和接口隔离，主要作为面向对象分析/OOA时职责划分所遵循的原则，此时你可以不太在意。依赖倒转原则，我把它作为垃圾扔掉，因为**开闭原则或者直接地说“依赖于抽象类型原则”**已经包含了依赖倒转原则的精华，而依赖倒转原则的糟粕由IoC继承。当然，[回调](http://blog.csdn.net/yqj2065/article/details/8758101)，我很强调。所以，你要掌握的有**抽象依赖原则(OCP)、单向依赖原则(含对回调的学习)和最低依赖原则(合成复用原则、迪米特法则)**。

c)    UML的初步了解。这是学习设计模式的工具。在早期，你甚至可以仅了解BlueJ的相关图示，也就10分钟的事情。

#### ③    境界

《五灯会元》卷十七中，有一则唐朝禅师青原惟信禅师的语录:“老僧三十年前未参禅时，见山是山，见水是水。及至后来亲见知识，有个入处，见山不是山，见水不是水。而今得个休歇处，依前见山只是山，见水只是水。”

a)    仔细研究GoF的[设计模式]，逐个学习其**意图和结构**，是一个抱着字典学习英语的方式。见山是山，见水是水，导致你可能在实际工作中生搬硬套、东施效颦。

b)    建议从简单的场景出发，**自己发现或设计出某种模式**。你从中体会该模式是如何解决问题的，这样，该模式成为你自己的东西，你才不会出现**知易行难**的问题。所有的设计模式不过是基本原则和理念在特定场合的应用。你可能不知道某个设计模式的名字，但是你知道它一切的优缺点和变体以及应用场合。见山不是山，见水不是水。

c)     你对**基本原则和理念**融会贯通，你可以惋惜：“我找到一种模式，原来在[设计模式](其实是某个特殊的书、文章提到的模式)中早就有了这种模式”。这时，模式不模式又如何呢？反模式又怎样。看见一个模式，你会说：“嗯，这是一种有用的模式”。见山只是山，见水只是水。

以上一点浅见。

------

注：【】中的内容是我加的。

1 转录【IT168知识库】

​         发现很多初学设计模式的人都有一些特点就是学习了某个设计模式之后，**貌似理解了，但是却不知道怎么去使用**这些所谓的精华经验，苦于不知如何下手。我最初学习设计模式的时候也有类似的经验，我将我的经验分享出来，希望能对初学者有帮助。
​        我对设计模式产生兴趣是在大概一年以前，最初看书的时候好像是看懂了，大概知道他在说什么。看了几个模式之后就开始寻找时机来套用套用这些模式。结果是除了Singleton模式以外的其他模式都没有找到应用的场所。然后我就没开始看下去了，我知道再看也没用，但是我并没有放弃对设计模式的关注。
​        不久我就在MSDN的Webcast上看到李建忠的 C#面向对象设计模式纵横谈讲座，很不错的系列讲座，让我对设计模式有了新的理解。我**意识到学习设计模式，确切的讲是学习面向对象的设计模式，应该从学习面向对象开始**。【**面向对象的原理如同了解下象棋的规则，而设计模式相当于残局，不知道规则看什么残局**】由于之前一年都在做asp.net开发，虽然都是在写类、学着duwamish搞分层架构、搞类型化DataSet、也弄过自定义实体类，但好像一年下来还没怎么用过接口，什么多态也是极少用。事实上对面向对象的编程思想的认识还是很模糊的。
​        重新认识OO：面向对象编程是一种思想，以面向对象的思维来思考软件设计结构，从而强化面向对象的编程范式。面向对象的特点是封装，继承，多态【**这些也算？**】。所以从那是开始，当我设计一个类的时候，不断的提示自己以下三点：
第一：别把自己的数据公开，除非你要向别人提供数据，使用尽量低的访问权限。
第二：以一个外部的视角来看类，紧记不要要求别人要在知道你是怎么实现一个方法之后才能使用我的类。
第三：分清类的职责，该这个类做的事情就要在这个类中实现，不该我的类做的事情就让别的类去实现。
在这三点的指导下来写类，写程序开始像在做“设计”了^_^。
一段时间后对设计模式就慢慢有感觉了，并能够找到一些设计模式的应用场景了。并常套用套用那些模式，逐渐的加深对模式的理解，并把它变成自己的东西，能够在其他的地方灵活的用起来。

\2. 转录 《易学设计模式·1.4  如何学习设计模式》郭志学 人民邮电出版社

如何学习设计模式
在了解了设计模式的历史和分类后，应该如何学习设计模式呢？在学习设计模式之前，读者一定要树立一种意识，那就是：**设计模式并不只是一种方法和技术，它更是一种思想、一个方法论。**它和具体的语言没有关系，学习设计模式**最主要的目的就是要建立**面向对象的思想，尽可能地面向接口编程、低耦合、高内聚，使你设计的程序尽可能地复用。【**似是而非。学习设计模式能够更好理解面向对象的思想，设计模式是一些设计的技巧和窍门，不要上升到思想、方法论好不好**】
有些软件开发人员，在程序设计时，总想着往某个设计模式上套，其实这样是不对的，并没有真正掌握设计模式的思想。其实很多时候读者用了某种设计模式，只是自己不知道这个模式叫什么名字而已。因此，在程序设计时，要根据自己的理解，使用合适的设计模式。
而有另外一些软件开发人员，在程序设计时，动不动就给类起个类似模式的名字，比如叫某某Facade、某某Factory等，其实类里面的内容和设计模式根本没有一点关系，只是用来标榜自己懂设计模式而已。
因此，学习设计模式，首先要了解有哪些方面的设计模式可以供开发人员使用，然后再分别研究每个设计模式的原理，使用时机和方法，也就是说要在什么情况下才使用某个设计模式，在了解某个设计模式的使用时机时，还要了解此时如果不使用这个设计模式，会造成什么样的后果。当对每个模式的原理和使用方法都了解了**以后**，更重要的是，学习面向对象的思想方式，在掌握面向对象的思想方式后，再回过头来看设计模式，就会有更深刻的理解，**最后，学习设计模式，一定要勤学多练**。【就最后一句很赞同】



**六、个人感悟**                                                                                                                 

学习设计模式确实有几种境界：

第一种是学习了一两个设计模式，就一直想用到自己的代码中去；

第二种是学完全部设计模式，觉得很多模式都很相似，分不清楚它们之间有什么区别；

第三种是灵活运用设计模式，就算不用具体哪种模式也可以设计也高质量的代码，无剑胜有剑。

最后附上总结图：

![img](https://images2017.cnblogs.com/blog/401339/201709/401339-20170929215000231-1094575081.png)





## JAVA设计模式总结之六大设计原则

从今年的七月份开始学习设计模式到9月底，设计模式全部学完了，在学习期间，总共过了两篇；第一篇看完设计模式后，感觉只是脑子里面有印象但无法言语。于是决定在看一篇，到9月份第二篇设计模式总于看完了，这一篇看完，脑子里面已经能够对绝大多数的设计模式能够说出其核心思想且可以画出类图也知道应用场景，算是一个进步，但可能还不能够特别熟练的使用，可能需要多多巩固和强化使用才能够完全理解设计模式的精髓所在。学习期间收获还是不少的：

1、从只听过设计模式到学习了所有的设计模式，并写了不少设计模式的博客，在公司期间也总结了，只会限于公司资料保密政策无法带出，对这个我只能呵呵，博客园也写了部分博客，有兴趣的可以查看随笔分类设计模式系列。

2、看源码和别人写的代码的时候，开始能够知道用的是什么模式，比如项目中典型的解释器模式，外观模式，策略模式等等，现在写代码也会考虑系统的可扩展性，以及如何来更好的设计，从而是代码更加优化和漂亮。

3、遇到问题也会想是否可以采用设计模式来解决问题，对面向对象也进一步的理解了。

下面来总结下自己所学习的设计模式，首先我们看下各个模式之间的关系图，下面这张图是网上比较典型的一个类图关系：

​                      ![img](https://images2017.cnblogs.com/blog/401339/201709/401339-20170926072840714-1631147313.jpg)



从上面的类图之间可以看出，学习设计模式或者说学懂完全理解所有的设计模式还是挺难的，只能说不断的重复学习，不断的去领悟才是唯一的方法，当然不排除有些人是天才看一篇就学会了，可惜鄙人不是，所以必须不断重复学习来加深自己的理解。个人感觉，单例、工厂、装饰者、观察者、代理模式使用的频率比较高；当然不是说其他模糊就不使用，只是个人的看法而已，o(*￣︶￣*)o。

学习设计模式，首先要学习的就是设计原则，因此我从设计原则来开始第一个节。

**一、设计原则**                                                                                                                                                

**1.单一职责**                                                                                                                                                     

一个类，只有一个引起它变化的原因。应该只有一个职责。每一个职责都是变化的一个轴线，如果一个类有一个以上的职责，这些职责就耦合在了一起。这会导致脆弱的设计。当一个职责发生变化时，可能会影响其它的职责。另外，多个职责耦合在一起，会影响复用性。例如：要实现逻辑和界面的分离。

简单通俗的来说：一个类只负责一项职责。

**问题：**比如一个类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。

解决方法：遵循单一职责原则。分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险。

扩展：说到单一职责原则，其实很多人不知不觉的都在使用，即使没有学习过设计模式的人，或者没有听过单一职责原则这个概念的人也会自觉的遵守这个重要原则，因为这是一个常识，比如你去在原有的项目上开发一个新的业务功能的时候，你肯定是会从新建立一个类，来实现一个新的功能，肯定不会基于原有的A功能身上直接写B业务的功能，肯定一般都是会新写一个类来实现B功能。在软件编程中，谁也不希望因为修改了一个功能导致其他的功能发生故障。而避免出现这一问题的方法便是遵循单一职责原则。虽然单一职责原则如此简单，并且被认为是常识，**但是**即便是经验丰富的程序员写出的程序，也会有违背这一原则的代码存在。为什么会出现这种现象呢？**因为有职责扩散。所谓职责扩散，就是因为某种原因，职责P被分化为粒度更细的职责P1和P2。**

**比如：类T只负责一个职责P，这样设计是符合单一职责原则的。后来由于某种原因，也许是需求变更了，也许是程序的设计者境界提高了，需要将职责P细分为粒度更细的职责P1，P2，这时如果要使程序遵循单一职责原则，需要将类T也分解为两个类T1和T2，分别负责P1、P2两个职责。但是在程序已经写好的情况下，这样做简直太费时间了。所以，简单的修改类T，用它来负责两个职责是一个比较不错的选择，虽然这样做有悖于单一职责原则。（这样做的风险在于职责扩散的不确定性，因为我们不会想到这个职责P，在未来可能会扩散为P1，P2，P3，P4……Pn。所以记住，在职责扩散到我们无法控制的程度之前，立刻对代码进行重构。）**

举例说明，用一个类描述动物呼吸这个场景：



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Animal&#123;</span><br><span class="line">    public void breathe(String animal)&#123;</span><br><span class="line">        System.out.println(animal+&quot;呼吸空气&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Client&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Animal animal &#x3D; new Animal();</span><br><span class="line">        animal.breathe(&quot;牛&quot;);</span><br><span class="line">        animal.breathe(&quot;羊&quot;);</span><br><span class="line">        animal.breathe(&quot;猪&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



运行结果：

牛呼吸空气

羊呼吸空气

猪呼吸空气

程序上线后，发现问题了，并不是所有的动物都呼吸空气的，比如鱼就是呼吸水的。修改时如果遵循单一职责原则，需要将Animal类细分为陆生动物类Terrestrial，水生动物Aquatic，代码如下：





<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Terrestrial&#123;</span><br><span class="line">    public void breathe(String animal)&#123;</span><br><span class="line">        System.out.println(animal+&quot;呼吸空气&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Aquatic&#123;</span><br><span class="line">    public void breathe(String animal)&#123;</span><br><span class="line">        System.out.println(animal+&quot;呼吸水&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Terrestrial terrestrial &#x3D; new Terrestrial();</span><br><span class="line">        terrestrial.breathe(&quot;牛&quot;);</span><br><span class="line">        terrestrial.breathe(&quot;羊&quot;);</span><br><span class="line">        terrestrial.breathe(&quot;猪&quot;);</span><br><span class="line">        </span><br><span class="line">        Aquatic aquatic &#x3D; new Aquatic();</span><br><span class="line">        aquatic.breathe(&quot;鱼&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



运行结果：

牛呼吸空气

羊呼吸空气

猪呼吸空气

鱼呼吸水

我们会发现如果这样修改花销是很大的，除了将原来的类分解之外，还需要修改客户端。而直接修改类Animal来达成目的虽然违背了单一职责原则，但花销却小的多，代码如下：



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Animal&#123;</span><br><span class="line">    public void breathe(String animal)&#123;</span><br><span class="line">        if(&quot;鱼&quot;.equals(animal))&#123;</span><br><span class="line">            System.out.println(animal+&quot;呼吸水&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            System.out.println(animal+&quot;呼吸空气&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Animal animal &#x3D; new Animal();</span><br><span class="line">        animal.breathe(&quot;牛&quot;);</span><br><span class="line">        animal.breathe(&quot;羊&quot;);</span><br><span class="line">        animal.breathe(&quot;猪&quot;);</span><br><span class="line">        animal.breathe(&quot;鱼&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



可以看到，这种修改方式要简单的多。但是却存在着隐患：有一天需要将鱼分为呼吸淡水的鱼和呼吸海水的鱼，则又需要修改Animal类的breathe方法，而对原有代码的修改会对调用“猪”“牛”“羊”等相关功能带来风险，也许某一天你会发现程序运行的结果变为“牛呼吸水”了。这种修改方式直接在代码级别上违背了单一职责原则，虽然修改起来最简单，但隐患却是最大的。还有一种修改方式：



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Animal&#123;</span><br><span class="line">    public void breathe(String animal)&#123;</span><br><span class="line">        System.out.println(animal+&quot;呼吸空气&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void breathe2(String animal)&#123;</span><br><span class="line">        System.out.println(animal+&quot;呼吸水&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Animal animal &#x3D; new Animal();</span><br><span class="line">        animal.breathe(&quot;牛&quot;);</span><br><span class="line">        animal.breathe(&quot;羊&quot;);</span><br><span class="line">        animal.breathe(&quot;猪&quot;);</span><br><span class="line">        animal.breathe2(&quot;鱼&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



可以看到，这种修改方式没有改动原来的方法，而是在类中新加了一个方法，这样虽然也违背了单一职责原则，但在方法级别上却是符合单一职责原则的，因为它并没有动原来方法的代码。**这三种方式各有优缺点，那么在实际编程中，采用哪一中呢？其实这真的比较难说，需要根据实际情况来确定。我的原则是：只有逻辑足够简单，才可以在代码级别上违反单一职责原则；只有类中方法数量足够少，才可以在方法级别上违反单一职责原则；**

例如本文所举的这个例子，它太简单了，它只有一个方法，所以，无论是在代码级别上违反单一职责原则，还是在方法级别上违反，都不会造成太大的影响。实际应用中的类都要复杂的多，一旦发生职责扩散而需要修改类时，除非这个类本身非常简单，否则还是遵循单一职责原则的好。

**遵循单一职责原的优点有：**

- 可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；
- 提高类的可读性，提高系统的可维护性；
- 变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。

需要说明的一点是单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都适用单一职责原则。

单一职责看似简单，实际上在实际运用过程中，会发现真的会出现很多职责扩展的现象，这个时候采用直接违反还会方法上遵循还是完全遵循单一职责原则还是取决于当前业务开发的人员的技能水平和这个需求的时间，如果技能水平不足，肯定会简单的if else 去解决，不会想什么原则，直接实现功能就好了，这也是为什么在很多小公司会发现代码都是业务堆起来的，当然也有好的小公司代码是写的好的，这个也是不可否认的。不过不管采用什么方式解决，心中至少要知道有几种解决方法。



**2.里氏替换原则 （Liskov Substitution Principle）**                                                                       

里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

看完上面的概念估计很多人都和我一样不是太理解，或者比较好奇，为什么叫里氏替换？其原因是：这项原则最早是在1988年，由麻省理工学院的一位姓里的女士（Barbara Liskov）提出来的。

解剖为下面的描述:

定义1：如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。

定义2：所有引用基类的地方必须能透明地使用其子类的对象。

通俗简单的说就是：子类可以扩展父类的功能，但不能改变父类原有的功能。

**问题由来：**有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障。

解决方案：**当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。【由时候我们可以采用final的手段强制来遵循】**

继承包含这样一层含义：父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而里氏替换原则就是表达了这一层含义。

继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生故障。

举例说明继承的风险，我们需要完成一个两数相减的功能，由类A来负责。



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">    public int func1(int a, int b)&#123;</span><br><span class="line">        return a-b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        A a &#x3D; new A();</span><br><span class="line">        System.out.println(&quot;100-50&#x3D;&quot;+a.func1(100, 50));</span><br><span class="line">        System.out.println(&quot;100-80&#x3D;&quot;+a.func1(100, 80));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



运行结果：

100-50=50

100-80=20

后来，我们需要增加一个新的功能：完成两数相加，然后再与100求和，由类B来负责。即类B需要完成两个功能：

- 两数相减。
- 两数相加，然后再加100。

由于类A已经实现了第一个功能【两数相减】，所以类B继承类A后，只需要再完成第二个功能【两数相加，然后再加100】就可以了，代码如下：



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class B extends A&#123;</span><br><span class="line">    public int func1(int a, int b)&#123;</span><br><span class="line">        return a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int func2(int a, int b)&#123;</span><br><span class="line">        return func1(a,b)+100;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        B b &#x3D; new B();</span><br><span class="line">        System.out.println(&quot;100-50&#x3D;&quot;+b.func1(100, 50));</span><br><span class="line">        System.out.println(&quot;100-80&#x3D;&quot;+b.func1(100, 80));</span><br><span class="line">        System.out.println(&quot;100+20+100&#x3D;&quot;+b.func2(100, 20));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



类B完成后，运行结果：

100-50=150

100-80=180

100+20+100=220

我们发现原本运行正常的相减功能发生了错误。**原因就是类B在给方法起名时无意中重写了父类的方法**，造成所有运行相减功能的代码全部调用了类B重写后的方法，造成原本运行正常的功能出现了错误。在本例中，**引用基类A完成的功能，换成子类B之后，发生了异常**。**在实际编程中，我们常常会通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的几率非常大。如果非要重写父类的方法，比较通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合，组合等关系代替。**

再次来理解里氏替换原则：子类可以扩展父类的功能，但不能改变父类原有的功能。它包含以下4层含义：

- 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。
- 子类中可以增加自己特有的方法。
- 当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。【注意区分重载和重写】
- 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。

看上去很不可思议，因为我们会发现在自己编程中常常会违反里氏替换原则，程序照样跑的好好的。所以大家都会产生这样的疑问，假如我非要不遵循里氏替换原则会有什么后果？

后果就是：你写的代码出问题的几率将会大大增加。

 **3.依赖倒置原则 （Dependence Inversion Principle）**                                                       

所谓依赖倒置原则（Dependence Inversion Principle）就是要依赖于抽象，不要依赖于具体。实现开闭原则的关键是抽象化，并且从抽象化导出具体化实现，如果说开闭原则是面向对象设计的目标的话，那么依赖倒转原则就是面向对象设计的主要手段。

定义：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。

通俗点说：要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。

**问题由来：**类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。

解决方案：将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。

依赖倒置原则基于这样一个事实：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。在java中，抽象指的是接口或者抽象类，细节就是具体的实现类，**使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。**

**依赖倒置原则的核心思想是面向接口编程，**我们依旧用一个例子来说明面向接口编程比相对于面向实现编程好在什么地方。场景是这样的，母亲给孩子讲故事，只要给她一本书，她就可以照着书给孩子讲故事了。代码如下：





<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Book&#123;</span><br><span class="line">    public String getContent()&#123;</span><br><span class="line">        return &quot;很久很久以前有一个阿拉伯的故事……&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Mother&#123;</span><br><span class="line">    public void narrate(Book book)&#123;</span><br><span class="line">        System.out.println(&quot;妈妈开始讲故事&quot;);</span><br><span class="line">        System.out.println(book.getContent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Mother mother &#x3D; new Mother();</span><br><span class="line">        mother.narrate(new Book());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





运行结果：

妈妈开始讲故事

很久很久以前有一个阿拉伯的故事……

上述是面向实现的编程，即依赖的是Book这个具体的实现类；看起来功能都很OK，也没有什么问题。

运行良好，假如有一天，需求变成这样：不是给书而是给一份报纸，让这位母亲讲一下报纸上的故事，报纸的代码如下：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Newspaper&#123;</span><br><span class="line">    public String getContent()&#123;</span><br><span class="line">        return &quot;林书豪38+7领导尼克斯击败湖人……&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

这位母亲却办不到，因为她居然不会读报纸上的故事，这太荒唐了，只是将书换成报纸，居然必须要修改Mother才能读。假如以后需求换成杂志呢？换成网页呢？还要不断地修改Mother，这显然不是好的设计。原因就是Mother与Book之间的耦合性太高了，必须降低他们之间的耦合度才行。

我们引入一个抽象的接口IReader。读物，只要是带字的都属于读物：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface IReader&#123;</span><br><span class="line">    public String getContent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

Mother类与接口IReader发生依赖关系，而Book和Newspaper都属于读物的范畴，他们各自都去实现IReader接口，这样就符合依赖倒置原则了，代码修改为：



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Newspaper implements IReader &#123;</span><br><span class="line">    public String getContent()&#123;</span><br><span class="line">        return &quot;林书豪17+9助尼克斯击败老鹰……&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Book implements IReader&#123;</span><br><span class="line">    public String getContent()&#123;</span><br><span class="line">        return &quot;很久很久以前有一个阿拉伯的故事……&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Mother&#123;</span><br><span class="line">    public void narrate(IReader reader)&#123;</span><br><span class="line">        System.out.println(&quot;妈妈开始讲故事&quot;);</span><br><span class="line">        System.out.println(reader.getContent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Mother mother &#x3D; new Mother();</span><br><span class="line">        mother.narrate(new Book());</span><br><span class="line">        mother.narrate(new Newspaper());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



运行结果：

妈妈开始讲故事

很久很久以前有一个阿拉伯的故事……

妈妈开始讲故事

林书豪17+9助尼克斯击败老鹰……

这样修改后，无论以后怎样扩展Client类，都不需要再修改Mother类了。这只是一个简单的例子，实际情况中，代表高层模块的Mother类将负责完成主要的业务逻辑，一旦需要对它进行修改，引入错误的风险极大。所以遵循依赖倒置原则可以降低类之间的耦合性，提高系统的稳定性，降低修改程序造成的风险。

采用依赖倒置原则给多人并行开发带来了极大的便利，比如上例中，原本Mother类与Book类直接耦合时，Mother类必须等Book类编码完成后才可以进行编码，因为Mother类依赖于Book类。修改后的程序则可以同时开工，互不影响，因为Mother与Book类一点关系也没有。参与协作开发的人越多、项目越庞大，采用依赖导致原则的意义就越重大。现在很流行的TDD开发模式就是依赖倒置原则最成功的应用。

传递依赖关系有三种方式，以上的例子中使用的方法是接口传递，另外还有两种传递方式：构造方法传递和setter方法传递，相信用过Spring框架的，对依赖的传递方式一定不会陌生。

**在实际编程中，我们一般需要做到如下3点：**

- **低层模块尽量都要有抽象类或接口，或者两者都有。【可能会被人用到的】**
- **变量的声明类型尽量是抽象类或接口。**
- **使用继承时遵循里氏替换原则。**

**依赖倒置原则的核心就是要我们面向接口编程，理解了面向接口编程，也就理解了依赖倒置。**

 **4.接口隔离原则 （Interface Segregation Principle）**                                                                 

其原则字面的意思是：使用多个隔离的接口，比使用单个接口要好。本意降低类之间的耦合度，而设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。

原定义：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。 

问题由来：类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。

**解决方案：将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。**

举例来说明接口隔离原则：

![img](https://images2017.cnblogs.com/blog/401339/201709/401339-20170927214256294-478349580.png)



上图就没有实现接口隔离，类B 和 类 D 中都会实现不是自己的方法。

具体来说：类A依赖接口I中的方法1、方法2、方法3，类B是对类A依赖的实现。类C依赖接口I中的方法1、方法4、方法5，类D是对类C依赖的实现。对于类B和类D来说，虽然他们都存在着用不到的方法（也就是图中红色字体标记的方法），但由于实现了接口I，所以也必须要实现这些用不到的方法。对类图不熟悉的可以参照程序代码来理解，代码如下：



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">interface I &#123;</span><br><span class="line">    public void method1();</span><br><span class="line">    public void method2();</span><br><span class="line">    public void method3();</span><br><span class="line">    public void method4();</span><br><span class="line">    public void method5();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class A&#123;</span><br><span class="line">    public void depend1(I i)&#123;</span><br><span class="line">        i.method1();</span><br><span class="line">    &#125;</span><br><span class="line">    public void depend2(I i)&#123;</span><br><span class="line">        i.method2();</span><br><span class="line">    &#125;</span><br><span class="line">    public void depend3(I i)&#123;</span><br><span class="line">        i.method3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B implements I&#123;</span><br><span class="line">    public void method1() &#123;</span><br><span class="line">        System.out.println(&quot;类B实现接口I的方法1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void method2() &#123;</span><br><span class="line">        System.out.println(&quot;类B实现接口I的方法2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void method3() &#123;</span><br><span class="line">        System.out.println(&quot;类B实现接口I的方法3&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;对于类B来说，method4和method5不是必需的，但是由于接口A中有这两个方法，</span><br><span class="line">    &#x2F;&#x2F;所以在实现过程中即使这两个方法的方法体为空，也要将这两个没有作用的方法进行实现。</span><br><span class="line">    public void method4() &#123;&#125;</span><br><span class="line">    public void method5() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C&#123;</span><br><span class="line">    public void depend1(I i)&#123;</span><br><span class="line">        i.method1();</span><br><span class="line">    &#125;</span><br><span class="line">    public void depend2(I i)&#123;</span><br><span class="line">        i.method4();</span><br><span class="line">    &#125;</span><br><span class="line">    public void depend3(I i)&#123;</span><br><span class="line">        i.method5();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class D implements I&#123;</span><br><span class="line">    public void method1() &#123;</span><br><span class="line">        System.out.println(&quot;类D实现接口I的方法1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;对于类D来说，method2和method3不是必需的，但是由于接口A中有这两个方法，</span><br><span class="line">    &#x2F;&#x2F;所以在实现过程中即使这两个方法的方法体为空，也要将这两个没有作用的方法进行实现。</span><br><span class="line">    public void method2() &#123;&#125;</span><br><span class="line">    public void method3() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public void method4() &#123;</span><br><span class="line">        System.out.println(&quot;类D实现接口I的方法4&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void method5() &#123;</span><br><span class="line">        System.out.println(&quot;类D实现接口I的方法5&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        A a &#x3D; new A();</span><br><span class="line">        a.depend1(new B());</span><br><span class="line">        a.depend2(new B());</span><br><span class="line">        a.depend3(new B());</span><br><span class="line">        </span><br><span class="line">        C c &#x3D; new C();</span><br><span class="line">        c.depend1(new D());</span><br><span class="line">        c.depend2(new D());</span><br><span class="line">        c.depend3(new D());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



可以看到，如果接口过于臃肿，只要接口中出现的方法，不管对依赖于它的类有没有用处，实现类中都必须去实现这些方法，这显然不是好的设计。如果将这个设计修改为符合接口隔离原则，就必须对接口I进行拆分。在这里我们将原有的接口I拆分为三个接口，拆分后的设计如图2所示：

![img](https://images2017.cnblogs.com/blog/401339/201709/401339-20170927214612559-854563464.png)



上述为遵循接口隔离原则的设计，代码如下：



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">interface I1 &#123;</span><br><span class="line">    public void method1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface I2 &#123;</span><br><span class="line">    public void method2();</span><br><span class="line">    public void method3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface I3 &#123;</span><br><span class="line">    public void method4();</span><br><span class="line">    public void method5();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class A&#123;</span><br><span class="line">    public void depend1(I1 i)&#123;</span><br><span class="line">        i.method1();</span><br><span class="line">    &#125;</span><br><span class="line">    public void depend2(I2 i)&#123;</span><br><span class="line">        i.method2();</span><br><span class="line">    &#125;</span><br><span class="line">    public void depend3(I2 i)&#123;</span><br><span class="line">        i.method3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B implements I1, I2&#123;</span><br><span class="line">    public void method1() &#123;</span><br><span class="line">        System.out.println(&quot;类B实现接口I1的方法1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void method2() &#123;</span><br><span class="line">        System.out.println(&quot;类B实现接口I2的方法2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void method3() &#123;</span><br><span class="line">        System.out.println(&quot;类B实现接口I2的方法3&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C&#123;</span><br><span class="line">    public void depend1(I1 i)&#123;</span><br><span class="line">        i.method1();</span><br><span class="line">    &#125;</span><br><span class="line">    public void depend2(I3 i)&#123;</span><br><span class="line">        i.method4();</span><br><span class="line">    &#125;</span><br><span class="line">    public void depend3(I3 i)&#123;</span><br><span class="line">        i.method5();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class D implements I1, I3&#123;</span><br><span class="line">    public void method1() &#123;</span><br><span class="line">        System.out.println(&quot;类D实现接口I1的方法1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void method4() &#123;</span><br><span class="line">        System.out.println(&quot;类D实现接口I3的方法4&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void method5() &#123;</span><br><span class="line">        System.out.println(&quot;类D实现接口I3的方法5&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



**接口隔离原则的含义是：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少**。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。本文例子中，将一个庞大的接口变更为3个专用的接口所采用的就是接口隔离原则。在程序设计中，依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的“契约”，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。

说到这里，很多人会觉的接口隔离原则跟之前的单一职责原则很相似，其实不然。**其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构建。**

采用接口隔离原则对接口进行约束时，要注意以下几点：

- 接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。
- 为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。
- 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。

运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。



**5.迪米特法则（最少知道原则） （Demeter Principle）**                                                                                  

为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。也就是说一个软件实体应当尽可能少的与其他实体发生相互作用。这样，当一个模块修改时，就会尽量少的影响其他的模块，扩展会相对容易，这是对软件实体之间通信的限制，它要求限制软件实体之间通信的宽度和深度。

**定义：一个对象应该对其他对象保持最少的了解。**

问题由来：类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。

解决方案：尽量降低类与类之间的耦合。

自从我们接触编程开始，就知道了软件编程的总的原则：低耦合，高内聚。无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。低耦合的优点不言而喻，但是怎么样编程才能做到低耦合呢？那正是迪米特法则要去完成的。

迪米特法则又叫最少知道原则，最早是在1987年由美国Northeastern University的Ian Holland提出。**通俗的来讲，就是一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外除了提供的public方法，不对外泄漏任何信息。**迪米特法则还有一个更简单的定义：只与直接的朋友通信。首先来解释一下什么是直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类则不是直接的朋友。也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部。

举一个例子：有一个集团公司，下属单位有分公司和直属部门，现在要求打印出所有下属单位的员工ID。先来看一下违反迪米特法则的设计。



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;总公司员工</span><br><span class="line">class Employee&#123;</span><br><span class="line">    private String id;</span><br><span class="line">    public void setId(String id)&#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getId()&#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;分公司员工</span><br><span class="line">class SubEmployee&#123;</span><br><span class="line">    private String id;</span><br><span class="line">    public void setId(String id)&#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getId()&#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SubCompanyManager&#123;</span><br><span class="line">    public List&lt;SubEmployee&gt; getAllEmployee()&#123;</span><br><span class="line">        List&lt;SubEmployee&gt; list &#x3D; new ArrayList&lt;SubEmployee&gt;();</span><br><span class="line">        for(int i&#x3D;0; i&lt;100; i++)&#123;</span><br><span class="line">            SubEmployee emp &#x3D; new SubEmployee();</span><br><span class="line">            &#x2F;&#x2F;为分公司人员按顺序分配一个ID</span><br><span class="line">            emp.setId(&quot;分公司&quot;+i);</span><br><span class="line">            list.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CompanyManager&#123;</span><br><span class="line"></span><br><span class="line">    public List&lt;Employee&gt; getAllEmployee()&#123;</span><br><span class="line">        List&lt;Employee&gt; list &#x3D; new ArrayList&lt;Employee&gt;();</span><br><span class="line">        for(int i&#x3D;0; i&lt;30; i++)&#123;</span><br><span class="line">            Employee emp &#x3D; new Employee();</span><br><span class="line">            &#x2F;&#x2F;为总公司人员按顺序分配一个ID</span><br><span class="line">            emp.setId(&quot;总公司&quot;+i);</span><br><span class="line">            list.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void printAllEmployee(SubCompanyManager sub)&#123;</span><br><span class="line">        List&lt;SubEmployee&gt; list1 &#x3D; sub.getAllEmployee();</span><br><span class="line">        for(SubEmployee e:list1)&#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Employee&gt; list2 &#x3D; this.getAllEmployee();</span><br><span class="line">        for(Employee e:list2)&#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        CompanyManager e &#x3D; new CompanyManager();</span><br><span class="line">        e.printAllEmployee(new SubCompanyManager());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



现在这个设计的主要问题出在CompanyManager中，根据迪米特法则，只与直接的朋友发生通信，而SubEmployee类并不是CompanyManager类的直接朋友（以局部变量出现的耦合不属于直接朋友），从逻辑上讲总公司只与他的分公司耦合就行了，与分公司的员工并没有任何联系，这样设计显然是增加了不必要的耦合。按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合。修改后的代码如下:



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class SubCompanyManager&#123;</span><br><span class="line">    public List&lt;SubEmployee&gt; getAllEmployee()&#123;</span><br><span class="line">        List&lt;SubEmployee&gt; list &#x3D; new ArrayList&lt;SubEmployee&gt;();</span><br><span class="line">        for(int i&#x3D;0; i&lt;100; i++)&#123;</span><br><span class="line">            SubEmployee emp &#x3D; new SubEmployee();</span><br><span class="line">            &#x2F;&#x2F;为分公司人员按顺序分配一个ID</span><br><span class="line">            emp.setId(&quot;分公司&quot;+i);</span><br><span class="line">            list.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">    public void printEmployee()&#123;</span><br><span class="line">        List&lt;SubEmployee&gt; list &#x3D; this.getAllEmployee();</span><br><span class="line">        for(SubEmployee e:list)&#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CompanyManager&#123;</span><br><span class="line">    public List&lt;Employee&gt; getAllEmployee()&#123;</span><br><span class="line">        List&lt;Employee&gt; list &#x3D; new ArrayList&lt;Employee&gt;();</span><br><span class="line">        for(int i&#x3D;0; i&lt;30; i++)&#123;</span><br><span class="line">            Employee emp &#x3D; new Employee();</span><br><span class="line">            &#x2F;&#x2F;为总公司人员按顺序分配一个ID</span><br><span class="line">            emp.setId(&quot;总公司&quot;+i);</span><br><span class="line">            list.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void printAllEmployee(SubCompanyManager sub)&#123;</span><br><span class="line">        sub.printEmployee();</span><br><span class="line">        List&lt;Employee&gt; list2 &#x3D; this.getAllEmployee();</span><br><span class="line">        for(Employee e:list2)&#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



修改后，为分公司增加了打印人员ID的方法，总公司直接调用来打印，从而避免了与分公司的员工发生耦合。

迪米特法则的初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系。但是凡事都有度，虽然可以避免与非直接的类通信，但是要通信，必然会通过一个“中介”来发生联系，例如本例中，总公司就是通过分公司这个“中介”来与分公司的员工发生联系的。过分的使用迪米特原则，会产生大量这样的中介和传递类，导致系统复杂度变大。所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。

6.开闭原则（Open Close Principle）                                                                                               

开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，需要面向接口编程。

定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。

问题由来：在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。

解决方案：当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。

**开闭原则是面向对象设计中最基础的设计原则**，它指导我们如何建立稳定灵活的系统。开闭原则可能是设计模式六项原则中定义最模糊的一个了，它只告诉我们对扩展开放，对修改关闭，可是到底如何才能做到对扩展开放，对修改关闭，并没有明确的告诉我们。以前，如果有人告诉我“你进行设计的时候一定要遵守开闭原则”，我会觉的他什么都没说，但貌似又什么都说了。因为开闭原则真的太虚了。

如果仔细思考以及仔细阅读很多设计模式的文章后，会发现其实，我们遵循设计模式前面5大原则，以及使用23种设计模式的目的就是遵循开闭原则。也就是说，只要我们对前面5项原则遵守的好了，设计出的软件自然是符合开闭原则的，这个开闭原则更像是前面五项原则遵守程度的“平均得分”，前面5项原则遵守的好，平均分自然就高，说明软件设计开闭原则遵守的好；如果前面5项原则遵守的不好，则说明开闭原则遵守的不好。

开闭原则无非就是想表达这样一层意思：用抽象构建框架，用实现扩展细节。因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节，我们用从抽象派生的实现类来进行扩展，当软件需要发生变化时，我们只需要根据需求重新派生一个实现类来扩展就可以了。当然前提是我们的抽象要合理，要对需求的变更有前瞻性和预见性才行。

说到这里，再回想一下前面说的5项原则，恰恰是告诉我们**用抽象构建框架，用实现扩展细节的注意事项而已：单一职责原则告诉我们实现类要职责单一；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合。而开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。**

最后说明一下如何去遵守这六个原则。对这六个原则的遵守并不是是和否的问题，而是多和少的问题，也就是说，我们一般不会说有没有遵守，而是说遵守程度的多少。任何事都是过犹不及，设计模式的六个设计原则也是一样，制定这六个原则的目的并不是要我们刻板的遵守他们，而需要根据实际情况灵活运用。对他们的遵守程度只要在一个合理的范围内，就算是良好的设计。我们用一幅图来说明一下。

![img](https://images2017.cnblogs.com/blog/401339/201709/401339-20170927223521856-615672071.png)

图中的每一条维度各代表一项原则，我们依据对这项原则的遵守程度在维度上画一个点，则如果对这项原则遵守的合理的话，这个点应该落在红色的同心圆内部；如果遵守的差，点将会在小圆内部；如果过度遵守，点将会落在大圆外部。一个良好的设计体现在图中，应该是六个顶点都在同心圆中的六边形。

![img](https://images2017.cnblogs.com/blog/401339/201709/401339-20170927223703294-1177189859.png)

在上图中，设计1、设计2属于良好的设计，他们对六项原则的遵守程度都在合理的范围内；设计3、设计4设计虽然有些不足，但也基本可以接受；设计5则严重不足，对各项原则都没有很好的遵守；而设计6则遵守过渡了，设计5和设计6都是迫切需要重构的设计。

### 89.简单工厂和抽象工厂有什么区别？

简单工厂模式
是由一个工厂对象创建产品实例，简单工厂模式的工厂类一般是使用静态方法，通过不同的参数的创建不同的对象实例
可以生产结构中的任意产品，不能增加新的产品



抽象工厂模式
提供一个创建一系列相关或相互依赖对象的接口，而无需制定他们具体的类，生产多个系列产品
生产不同产品族的全部产品，不能新增产品，可以新增产品族



## 十、Spring/Spring MVC

### 90.为什么要使用 spring？

1.方便解耦，便于开发（Spring就是一个大工厂，可以将所有对象的创建和依赖关系维护都交给spring管理）

2.spring支持aop编程（spring提供面向切面编程，可以很方便的实现对程序进行权限拦截和运行监控等功能）

3.声明式事务的支持（通过配置就完成对事务的支持，不需要手动编程）

4.方便程序的测试，spring 对junit4支持，可以通过注解方便的测试spring 程序

5.方便集成各种优秀的框架（）

6.降低javaEE API的使用难度（Spring 对javaEE开发中非常难用的一些API 例如JDBC,javaMail,远程调用等，都提供了封装，是这些API应用难度大大降低）

### 91.解释一下什么是 aop？

这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。

AOP是Spring提供的关键特性之一。AOP即面向切面编程，是OOP编程的有效补充。

使用AOP技术，可以将一些系统性相关的编程工作，独立提取出来，独立实现，然后通过切面切入进系统。

从而避免了在业务逻辑的代码中混入很多的系统相关的逻辑——比如权限管理，事物管理，日志记录等等。

这些系统性的编程工作都可以独立编码实现，然后通过AOP技术切入进系统即可。从而达到了 将不同的关注点分离出来的效果。

本文深入剖析Spring的AOP的原理。

1. AOP相关的概念

1） *Aspect* ：切面，切入系统的一个切面。比如事务管理是一个切面，权限管理也是一个切面；

2） *Join point* ：连接点，也就是可以进行横向切入的位置；

3） *Advice* ：通知，切面在某个连接点执行的操作(分为: *Before advice* , *After returning advice* , *After throwing advice* , *After (finally) advice* , *Around advice* )；

4） *Pointcut* ：切点，符合切点表达式的连接点，也就是真正被切入的地方；

2. AOP 的实现原理

AOP分为静态AOP和动态AOP。

静态AOP是指AspectJ实现的AOP，他是将切面代码直接编译到Java类文件中。

动态AOP是指将切面代码进行动态织入实现的AOP。

Spring的AOP为动态AOP，实现的技术为： JDK提供的动态代理技术 和 CGLIB(动态字节码增强技术) 。尽管实现技术不一样，但 都是基于代理模式 ， 都是生成一个代理对象 。

#### 1) JDK动态代理

主要使用到 InvocationHandler 接口和 Proxy.newProxyInstance() 方法。

 JDK动态代理要求被代理实现一个接口，只有接口中的方法才能够被代理 。

其方法是将被代理对象注入到一个中间对象，而中间对象实现InvocationHandler接口，

在实现该接口时，可以在 被代理对象调用它的方法时，在调用的前后插入一些代码。

而 Proxy.newProxyInstance() 能够利用中间对象来生产代理对象。

插入的代码就是切面代码。所以使用JDK动态代理可以实现AOP。

我们看个例子：

被代理对象实现的接口，只有接口中的方法才能够被代理：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface UserService &#123;</span><br><span class="line">    public void addUser(User user);</span><br><span class="line">    public User getUser(int id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line">    public void addUser(User user) &#123;</span><br><span class="line">        System.out.println(&quot;add user into database.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public User getUser(int id) &#123;</span><br><span class="line">        User user &#x3D; new User();</span><br><span class="line">        user.setId(id);</span><br><span class="line">        System.out.println(&quot;getUser from database.&quot;);</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



代理中间类：



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">public class ProxyUtil implements InvocationHandler &#123;</span><br><span class="line">    private Object target;    &#x2F;&#x2F; 被代理的对象</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;do sth before....&quot;);</span><br><span class="line">        Object result &#x3D;  method.invoke(target, args);</span><br><span class="line">        System.out.println(&quot;do sth after....&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    ProxyUtil(Object target)&#123;</span><br><span class="line">        this.target &#x3D; target;</span><br><span class="line">    &#125;</span><br><span class="line">    public Object getTarget() &#123;</span><br><span class="line">        return target;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setTarget(Object target) &#123;</span><br><span class="line">        this.target &#x3D; target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



测试：



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import net.aazj.pojo.User;</span><br><span class="line">public class ProxyTest &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Object proxyedObject &#x3D; new UserServiceImpl();    &#x2F;&#x2F; 被代理的对象</span><br><span class="line">        ProxyUtil proxyUtils &#x3D; new ProxyUtil(proxyedObject);</span><br><span class="line">        &#x2F;&#x2F; 生成代理对象，对被代理对象的这些接口进行代理：UserServiceImpl.class.getInterfaces()</span><br><span class="line">        UserService proxyObject &#x3D; (UserService) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), </span><br><span class="line">                    UserServiceImpl.class.getInterfaces(), proxyUtils);</span><br><span class="line">        proxyObject.getUser(1);</span><br><span class="line">        proxyObject.addUser(new User());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



执行结果：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">do sth before....</span><br><span class="line">getUser from database.</span><br><span class="line">do sth after....</span><br><span class="line">do sth before....</span><br><span class="line">add user into database.</span><br><span class="line">do sth after....</span><br><span class="line">我们看到在 UserService接口中的方法 addUser 和 getUser方法的前面插入了我们自己的代码。这就是JDK动态代理实现AOP的原理。</span><br><span class="line"></span><br><span class="line">我们看到该方式有一个要求， 被代理的对象必须实现接口，而且只有接口中的方法才能被代理 。</span><br></pre></td></tr></table></figure>

2）CGLIB （code generate libary）

字节码生成技术实现AOP，其实就是继承被代理对象，然后Override需要被代理的方法，在覆盖该方法时，自然是可以插入我们自己的代码的。

因为需要Override被代理对象的方法，所以自然CGLIB技术实现AOP时，就 必须要求需要被代理的方法不能是final方法，因为final方法不能被子类覆盖 。

我们使用CGLIB实现上面的例子：



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package net.aazj.aop;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import net.sf.cglib.proxy.Enhancer;</span><br><span class="line">import net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line">import net.sf.cglib.proxy.MethodProxy;</span><br><span class="line">public class CGProxy implements MethodInterceptor&#123;</span><br><span class="line">    private Object target;    &#x2F;&#x2F; 被代理对象</span><br><span class="line">    public CGProxy(Object target)&#123;</span><br><span class="line">        this.target &#x3D; target;</span><br><span class="line">    &#125;</span><br><span class="line">    public Object intercept(Object arg0, Method arg1, Object[] arg2, MethodProxy proxy) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;do sth before....&quot;);</span><br><span class="line">        Object result &#x3D; proxy.invokeSuper(arg0, arg2);</span><br><span class="line">        System.out.println(&quot;do sth after....&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    public Object getProxyObject() &#123;</span><br><span class="line">        Enhancer enhancer &#x3D; new Enhancer();</span><br><span class="line">        enhancer.setSuperclass(this.target.getClass());    &#x2F;&#x2F; 设置父类</span><br><span class="line">        &#x2F;&#x2F; 设置回调</span><br><span class="line">        enhancer.setCallback(this);    &#x2F;&#x2F; 在调用父类方法时，回调 this.intercept()</span><br><span class="line">        &#x2F;&#x2F; 创建代理对象</span><br><span class="line">        return enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class CGProxyTest &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Object proxyedObject &#x3D; new UserServiceImpl();    &#x2F;&#x2F; 被代理的对象</span><br><span class="line">        CGProxy cgProxy &#x3D; new CGProxy(proxyedObject);</span><br><span class="line">        UserService proxyObject &#x3D; (UserService) cgProxy.getProxyObject();</span><br><span class="line">        proxyObject.getUser(1);</span><br><span class="line">        proxyObject.addUser(new User());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



输出结果：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">do sth before....</span><br><span class="line">getUser from database.</span><br><span class="line">do sth after....</span><br><span class="line">do sth before....</span><br><span class="line">add user into database.</span><br><span class="line">do sth after....</span><br><span class="line">我们看到达到了同样的效果。</span><br><span class="line">它的原理是生成一个父类 enhancer.setSuperclass( this.target.getClass()) 的子类 enhancer.create() ，然后对父类的方法进行拦截enhancer.setCallback( this) . </span><br><span class="line">对父类的方法进行覆盖，所以父类方法不能是final的。</span><br></pre></td></tr></table></figure>

3） 接下来我们看下spring实现AOP的相关源码：



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;serial&quot;)</span><br><span class="line">public class DefaultAopProxyFactory implements AopProxyFactory, Serializable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException &#123;</span><br><span class="line">        if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">            Class&lt;?&gt; targetClass &#x3D; config.getTargetClass();</span><br><span class="line">            if (targetClass &#x3D;&#x3D; null) &#123;</span><br><span class="line">                throw new AopConfigException(&quot;TargetSource cannot determine target class: &quot; +</span><br><span class="line">                        &quot;Either an interface or a target is required for proxy creation.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (targetClass.isInterface()) &#123;</span><br><span class="line">                return new JdkDynamicAopProxy(config);</span><br><span class="line">            &#125;</span><br><span class="line">            return new ObjenesisCglibAopProxy(config);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            return new JdkDynamicAopProxy(config);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



从上面的源码我们可以看到：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (targetClass.isInterface()) &#123;</span><br><span class="line">                return new JdkDynamicAopProxy(config);</span><br><span class="line">            &#125;</span><br><span class="line">            return new ObjenesisCglibAopProxy(config);</span><br></pre></td></tr></table></figure>

如果被代理对象实现了接口，那么就使用JDK的动态代理技术，反之则使用CGLIB来实现AOP，所以 Spring默认是使用JDK的动态代理技术实现AOP的 。

JdkDynamicAopProxy的实现其实很简单：



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">final class JdkDynamicAopProxy implements AopProxy, InvocationHandler, Serializable &#123;    </span><br><span class="line">@Override</span><br><span class="line">public Object getProxy(ClassLoader classLoader) &#123;</span><br><span class="line">    if (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(&quot;Creating JDK dynamic proxy: target source is &quot; + this.advised.getTargetSource());</span><br><span class="line">    &#125;</span><br><span class="line">    Class&lt;?&gt;[] proxiedInterfaces &#x3D; AopProxyUtils.completeProxiedInterfaces(this.advised);</span><br><span class="line">    findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line">    return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



3. Spring AOP的配置

Spring中AOP的配置一般有两种方法，一种是使用 <aop:config> 标签在xml中进行配置，一种是使用注解以及@Aspect风格的配置。

1） 基于<aop:config>的AOP配置

下面是一个典型的事务AOP的配置：



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;tx:advice id&#x3D;&quot;transactionAdvice&quot; transaction-manager&#x3D;&quot;transactionManager&quot;?&gt;</span><br><span class="line">    &lt;tx:attributes &gt;</span><br><span class="line">        &lt;tx:method name&#x3D;&quot;add*&quot; propagation&#x3D;&quot;REQUIRED&quot; &#x2F;&gt;</span><br><span class="line">        &lt;tx:method name&#x3D;&quot;append*&quot; propagation&#x3D;&quot;REQUIRED&quot; &#x2F;&gt;</span><br><span class="line">        &lt;tx:method name&#x3D;&quot;insert*&quot; propagation&#x3D;&quot;REQUIRED&quot; &#x2F;&gt;</span><br><span class="line">        &lt;tx:method name&#x3D;&quot;save*&quot; propagation&#x3D;&quot;REQUIRED&quot; &#x2F;&gt;</span><br><span class="line">        &lt;tx:method name&#x3D;&quot;update*&quot; propagation&#x3D;&quot;REQUIRED&quot; &#x2F;&gt;</span><br><span class="line">        &lt;tx:method name&#x3D;&quot;get*&quot; propagation&#x3D;&quot;SUPPORTS&quot; &#x2F;&gt;</span><br><span class="line">        &lt;tx:method name&#x3D;&quot;find*&quot; propagation&#x3D;&quot;SUPPORTS&quot; &#x2F;&gt;</span><br><span class="line">        &lt;tx:method name&#x3D;&quot;load*&quot; propagation&#x3D;&quot;SUPPORTS&quot; &#x2F;&gt;</span><br><span class="line">        &lt;tx:method name&#x3D;&quot;search*&quot; propagation&#x3D;&quot;SUPPORTS&quot; &#x2F;&gt;</span><br><span class="line">        &lt;tx:method name&#x3D;&quot;*&quot; propagation&#x3D;&quot;SUPPORTS&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;tx:attributes&gt;</span><br><span class="line">&lt;&#x2F;tx:advice&gt;</span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">    &lt;aop:pointcut id&#x3D;&quot;transactionPointcut&quot; expression&#x3D;&quot;execution(* net.aazj.service..*Impl.*(..))&quot; &#x2F;&gt;</span><br><span class="line">    &lt;aop:advisor pointcut-ref&#x3D;&quot;transactionPointcut&quot; advice-ref&#x3D;&quot;transactionAdvice&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;aop:config&gt;</span><br></pre></td></tr></table></figure>



再看一个例子：



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;aspectBean&quot; class&#x3D;&quot;net.aazj.aop.DataSourceInterceptor&quot;&#x2F;&gt;</span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">    &lt;aop:aspect id&#x3D;&quot;dataSourceAspect&quot; ref&#x3D;&quot;aspectBean&quot;&gt;</span><br><span class="line">        &lt;aop:pointcut id&#x3D;&quot;dataSourcePoint&quot; expression&#x3D;&quot;execution(public * net.aazj.service..*.getUser(..))&quot; &#x2F;&gt;</span><br><span class="line">        &lt;aop:pointcut expression&#x3D;&quot;&quot; id&#x3D;&quot;&quot;&#x2F;&gt;</span><br><span class="line">        &lt;aop:before method&#x3D;&quot;before&quot; pointcut-ref&#x3D;&quot;dataSourcePoint&quot;&#x2F;&gt;</span><br><span class="line">        &lt;aop:after method&#x3D;&quot;&quot;&#x2F;&gt;</span><br><span class="line">        &lt;aop:around method&#x3D;&quot;&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;aop:aspect&gt;</span><br><span class="line">    &lt;aop:aspect&gt;&lt;&#x2F;aop:aspect&gt;</span><br><span class="line">&lt;&#x2F;aop:config&gt;</span><br></pre></td></tr></table></figure>



<aop:aspect> 配置一个切面；

<aop:pointcut>配置一个切点，基于切点表达式；

<aop:before>,<aop:after>,<aop:around>是定义不同类型的advise. a

spectBean 是切面的处理bean：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class DataSourceInterceptor &#123;</span><br><span class="line">    public void before(JoinPoint jp) &#123;</span><br><span class="line">        DataSourceTypeManager.set(DataSources.SLAVE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

2) 基于注解和@Aspect风格的AOP配置

我们以事务配置为例：首先我们启用基于注解的事务配置

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 使用annotation定义事务 --&gt;</span><br><span class="line">    &lt;tx:annotation-driven transaction-manager&#x3D;&quot;transactionManager&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

然后扫描Service包：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:component-scan base-package&#x3D;&quot;net.aazj.service,net.aazj.aop&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

最后在service上进行注解：



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Service(&quot;userService&quot;)</span><br><span class="line">@Transactional</span><br><span class="line">public class UserServiceImpl implements UserService&#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private UserMapper userMapper;</span><br><span class="line">    @Transactional (readOnly&#x3D;true)</span><br><span class="line">    public User getUser(int userId) &#123;</span><br><span class="line">        System.out.println(&quot;in UserServiceImpl getUser&quot;);</span><br><span class="line">        System.out.println(DataSourceTypeManager.get());</span><br><span class="line">        return userMapper.getUser(userId);</span><br><span class="line">    &#125;</span><br><span class="line">    public void addUser(String username)&#123;</span><br><span class="line">        userMapper.addUser(username);</span><br><span class="line">&#x2F;&#x2F;        int i &#x3D; 1&#x2F;0;    &#x2F;&#x2F; 测试事物的回滚</span><br><span class="line">    &#125;</span><br><span class="line">    public void deleteUser(int id)&#123;</span><br><span class="line">        userMapper.deleteByPrimaryKey(id);</span><br><span class="line">&#x2F;&#x2F;        int i &#x3D; 1&#x2F;0;    &#x2F;&#x2F; 测试事物的回滚</span><br><span class="line">    &#125;</span><br><span class="line">    @Transactional (rollbackFor &#x3D; BaseBusinessException.class)</span><br><span class="line">    public void addAndDeleteUser(String username, int id) throws BaseBusinessException&#123;</span><br><span class="line">        userMapper.addUser(username);</span><br><span class="line">        this.m1();</span><br><span class="line">        userMapper.deleteByPrimaryKey(id);</span><br><span class="line">    &#125;</span><br><span class="line">    private void m1() throws BaseBusinessException &#123;</span><br><span class="line">        throw new BaseBusinessException(&quot;xxx&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public int insertUser(User user) &#123;</span><br><span class="line">        return this.userMapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



搞定。这种事务配置方式，不需要我们书写pointcut表达式，而是我们在需要事务的类上进行注解。但是如果我们自己来写切面的代码时，还是要写pointcut表达式。下面看一个例子(自己写切面逻辑)：

首先去扫描 @Aspect 注解定义的 切面：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:component-scan base-package&#x3D;&quot;net.aazj.aop&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

切面代码：



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import org.aspectj.lang.JoinPoint;</span><br><span class="line">import org.aspectj.lang.annotation.Aspect;</span><br><span class="line">import org.aspectj.lang.annotation.Before;</span><br><span class="line">import org.aspectj.lang.annotation.Pointcut;</span><br><span class="line">import org.springframework.core.annotation.Order;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">@Aspect    &#x2F;&#x2F; for aop</span><br><span class="line">@Component &#x2F;&#x2F; for auto scan</span><br><span class="line">@Order(0)  &#x2F;&#x2F; execute before @Transactional</span><br><span class="line">public class DataSourceInterceptor &#123;</span><br><span class="line">    @Pointcut(&quot;execution(public * net.aazj.service..*.get*(..))&quot;)</span><br><span class="line">    public void dataSourceSlave()&#123;&#125;;</span><br><span class="line">    @Before(&quot;dataSourceSlave()&quot;)</span><br><span class="line">    public void before(JoinPoint jp) &#123;</span><br><span class="line">        DataSourceTypeManager.set(DataSources.SLAVE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



我们使用到了 @Aspect 来定义一个切面；

@Component是配合<context:component-scan/>，不然扫描不到；

@Order定义了该切面切入的顺序 ，因为在同一个切点，可能同时存在多个切面，那么在这多个切面之间就存在一个执行顺序的问题。

该例子是一个切换数据源的切面，那么他应该在 事务处理 切面之前执行，所以我们使用 @Order(0) 来确保先切换数据源，然后加入事务处理。

@Order的参数越小，优先级越高，默认的优先级最低：



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Annotation that defines ordering. The value is optional, and represents order value</span><br><span class="line"> * as defined in the &#123;@link Ordered&#125; interface. Lower values have higher priority.</span><br><span class="line"> * The default value is &#123;@code Ordered.LOWEST_PRECEDENCE&#125;, indicating</span><br><span class="line"> * lowest priority (losing to any other specified order value).</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.TYPE, ElementType.METHOD, ElementType.FIELD&#125;)</span><br><span class="line">public @interface Order &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * The order value. Default is &#123;@link Ordered#LOWEST_PRECEDENCE&#125;.</span><br><span class="line">     * @see Ordered#getOrder()</span><br><span class="line">     *&#x2F;</span><br><span class="line">    int value() default Ordered.LOWEST_PRECEDENCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">关于数据源的切换可以参加专门的博文：http:&#x2F;&#x2F;www.cnblogs.com&#x2F;digdeep&#x2F;p&#x2F;4512368.html</span><br></pre></td></tr></table></figure>

3） 切点表达式(pointcut)

上面我们看到，无论是 <aop:config> 风格的配置，还是 @Aspect 风格的配置，切点表达式都是重点。都是我们必须掌握的。

 1>pointcut语法形式(execution)：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern)throws-pattern?)</span><br></pre></td></tr></table></figure>

带有 ? 号的部分是可选的，所以可以简化成： ret-type-pattern name-pattern(param_pattern) 返回类型，方法名称，参数三部分来匹配 。

配置起来其实也很简单： * 表示任意返回类型，任意方法名，任意一个参数类型； .. 连续两个点表示0个或多个包路径，还有0个或多个参数 。就是这么简单。看下例子：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">execution(* net.aazj.service..*.get*(..)) ：表示net.aazj.service包或者子包下的以get开头的方法，参数可以是0个或者多个（参数不限）；</span><br><span class="line">execution(* net.aazj.service.AccountService.*(..)): 表示AccountService接口下的任何方法，参数不限；</span><br><span class="line">注意这里，将类名和包路径是一起来处理的，并没有进行区分，因为类名也是包路径的一部分。</span><br><span class="line">参数param- pattern 部分比较复杂： () 表示没有参数，(..)参数不限，(*,String) 第一个参数不限类型，第二参数为String .</span><br></pre></td></tr></table></figure>

2>within() 语法:

within()只能指定(限定)包路径(类名也可以看做是包路径)，表示某个包下或者子报下的所有方法：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">within(net.aazj.service.*)， within(net.aazj.service..*)，within(net.aazj.service.UserServiceImpl.*)</span><br></pre></td></tr></table></figure>

3>this() 与 target():

this是指代理对象，target是指被代理对象(目标对象)。所以 this() 和 target() 分别限定 代理对象的类型和被代理对象的类型：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this(net.aazj.service.UserService): 实现了UserService的代理对象(中的所有方法)； </span><br><span class="line"></span><br><span class="line">target (net.aazj.service.UserService): 被代理对象 实现了UserService(中的所有方法)；</span><br></pre></td></tr></table></figure>

4> *args():*

限定方法的参数的类型：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">args(net.aazj.pojo.User): 参数为User类型的方法。</span><br><span class="line">5&gt;@target(), @within(), @annotation(), @args():</span><br><span class="line"></span><br><span class="line">这些语法形式都是针对注解的 ，比如 带有某个注解的 类 ， 带有某个注解的 方法， 参数的类型 带有某个注解 ：</span><br><span class="line">@within(org.springframework.transaction.annotation.Transactional) </span><br><span class="line">@target(org.springframework.transaction.annotation.Transactional)</span><br></pre></td></tr></table></figure>

两者都是指被代理对象 类 上有 @Transactional 注解的(类的所有方法)，（两者似乎没有区别？？？）

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@annotation(org.springframework.transaction.annotation.Transactional)：  方法 带有 @Transactional 注解的所有方法 </span><br><span class="line"></span><br><span class="line">@args(org.springframework.transaction.annotation.Transactional)： 参数的类型 带有 @Transactional 注解 的所有方法</span><br></pre></td></tr></table></figure>

6>bean(): 指定某个bean的名称

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bean(userService): bean的id为 &quot;userService&quot; 的所有方法;</span><br><span class="line"></span><br><span class="line">bean(*Service): bean的id为 &quot;Service&quot;字符串结尾的所有方法;</span><br><span class="line"></span><br><span class="line">另外注意上面这些表达式是可以利用 ||, &amp;&amp;, ! 进行自由组合的。比如：execution(public * net.aazj.service..*.getUser(..)) &amp;&amp; args(Integer,..)</span><br></pre></td></tr></table></figure>

4. 向注解处理方法传递参数

有时我们在写注解处理方法时，需要访问被拦截的方法的参数。此时我们可以使用 args() 来传递参数，下面看一个例子：



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">@Component &#x2F;&#x2F; for auto scan</span><br><span class="line">&#x2F;&#x2F;@Order(2)</span><br><span class="line">public class LogInterceptor &#123;    </span><br><span class="line">    @Pointcut(&quot;execution(public * net.aazj.service..*.getUser(..))&quot;)</span><br><span class="line">    public void myMethod()&#123;&#125;;</span><br><span class="line">    @Before(&quot;myMethod()&quot;)</span><br><span class="line">    public void before() &#123;</span><br><span class="line">        System.out.println(&quot;method start&quot;);</span><br><span class="line">    &#125; </span><br><span class="line">    @After(&quot;myMethod()&quot;)</span><br><span class="line">    public void after() &#123;</span><br><span class="line">        System.out.println(&quot;method after&quot;);</span><br><span class="line">    &#125; </span><br><span class="line">    @AfterReturning(&quot;execution(public * net.aazj.mapper..*.*(..))&quot;)</span><br><span class="line">    public void AfterReturning() &#123;</span><br><span class="line">        System.out.println(&quot;method AfterReturning&quot;);</span><br><span class="line">    &#125; </span><br><span class="line">    @AfterThrowing(&quot;execution(public * net.aazj.mapper..*.*(..))&quot;)</span><br><span class="line">&#x2F;&#x2F;  @Around(&quot;execution(public * net.aazj.mapper..*.*(..))&quot;)</span><br><span class="line">    public void AfterThrowing() &#123;</span><br><span class="line">        System.out.println(&quot;method AfterThrowing&quot;);</span><br><span class="line">    &#125; </span><br><span class="line">    @Around(&quot;execution(public * net.aazj.mapper..*.*(..))&quot;)</span><br><span class="line">    public Object Around(ProceedingJoinPoint jp) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;method Around&quot;);</span><br><span class="line">        SourceLocation sl &#x3D; jp.getSourceLocation();</span><br><span class="line">        Object ret &#x3D; jp.proceed();</span><br><span class="line">        System.out.println(jp.getTarget());</span><br><span class="line">        return ret;</span><br><span class="line">    &#125; </span><br><span class="line">    @Before(&quot;execution(public * net.aazj.service..*.getUser(..)) &amp;&amp; args(userId,..)&quot;)</span><br><span class="line">    public void before3(int userId) &#123;</span><br><span class="line">        System.out.println(&quot;userId-----&quot; + userId);</span><br><span class="line">    &#125;  </span><br><span class="line">    @Before(&quot;myMethod()&quot;)</span><br><span class="line">    public void before2(JoinPoint jp) &#123;</span><br><span class="line">        Object[] args &#x3D; jp.getArgs();</span><br><span class="line">        System.out.println(&quot;userId11111: &quot; + (Integer)args[0]);</span><br><span class="line">        System.out.println(jp.getTarget());</span><br><span class="line">        System.out.println(jp.getThis());</span><br><span class="line">        System.out.println(jp.getSignature());</span><br><span class="line">        System.out.println(&quot;method start&quot;);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



方法：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Before(&quot;execution(public * net.aazj.service..*.getUser(..)) &amp;&amp; args(userId,..)&quot;)</span><br><span class="line">    public void before3(int userId) &#123;</span><br><span class="line">        System.out.println(&quot;userId-----&quot; + userId);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

它会拦截 net.aazj.service 包下或者子包下的getUser方法，并且该方法的第一个参数必须是int型的， 那么使用切点表达式args(userId,..) 就可以使我们在切面中的处理方法before3中可以访问这个参数。

before2方法也让我们知道也可以通过 JoinPoint 参数来获得被拦截方法的参数数组。 JoinPoint 是每一个切面处理方法都具有的参数， @Around 类型的具有的参数类型为ProceedingJoinPoint。通过 JoinPoint或者 ProceedingJoinPoint 参数可以访问到被拦截对象的一些信息(参见上面的 before2 方法)。



### 92.解释一下什么是 ioc？

**IOC 是什么？**

Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。如何理解好Ioc呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下：



●**谁控制谁，控制什么：**传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对象的创建；谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。

●**为何是反转，哪些方面反转了：**有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。

用图例说明一下，传统程序设计如图2-1，都是主动去创建相关对象然后再组合起来：

 ![img](https://images2015.cnblogs.com/blog/786283/201705/786283-20170505152010101-745380739.jpg)

图2-1 传统应用程序示意图

当有了IoC/DI的容器后，在客户端类中不再主动去创建这些对象了，如图2-2所示:

 ![img](https://images2015.cnblogs.com/blog/786283/201705/786283-20170505152029836-221841058.jpg)

图2-2有IoC/DI容器后程序结构示意图

**IOC 能做什么？**

IoC不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。

其实IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC容器来创建并注入它所需要的资源了。

IoC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。

**IOC 和DI：**

DI—Dependency Injection，即“依赖注入”：是组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。

理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下：

●**谁依赖于谁：**当然是应用程序依赖于IoC容器；

●**为什么需要依赖：**应用程序需要IoC容器来提供对象需要的外部资源；

●**谁注入谁：**很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象；

**●注入了什么：**就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。

IoC和DI由什么关系呢？其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，**“****依赖注入”****明确描述了“被注入对象依赖IoC****容器配置依赖对象”。**

#### 93.spring 有哪些主要模块？

Spring框架主要有哪些模块

主要七大模块介绍

\1.      Spring AOP  面相切面编程

\2.      Spring ORM  Hibernate|mybatis|JDO

\3.      Spring Core  提供bean工厂 IOC

\4.      Spring Dao  JDBC支持

\5.      Spring Context  提供了关于UI支持,邮件支持等

\6.      Spring Web 提供了web的一些工具类的支持

\7.      Spring MVC  提供了web mvc , webviews , jsp ,pdf ,export



附带版本 参考



\1. Spring Core：

 Core封装包是框架的最基础部分，提供IOC和依赖注入特性。这里的基础概念是BeanFactory，它提供对Factory模式的经典实现来消除对程序性单例模式的需要，并真正地允许你从程序逻辑中分离出依赖关系和配置。

2.Spring Context: 

构建于[Core](http://www.mianwww.com/html/2014/03/19750.html#beans-introduction)封装包基础上的 [Context](http://blog.chinaunix.net/u/9295/ch03s08.html)封装包，提供了一种框架式的对象访问方法，有些象JNDI注册器。Context封装包的特性得自于Beans封装包，并添加了对国际化（I18N）的支持（例如资源绑定），事件传播，资源装载的方式和Context的透明创建，比如说通过Servlet容器。

3．Spring DAO:  [

](http://www.mianwww.com/html/2014/03/19750.html#dao-introduction)

[DAO](http://www.mianwww.com/html/2014/03/19750.html#dao-introduction) (Data Access Object)提供了JDBC的抽象层，它可消除冗长的JDBC编码和解析数据库厂商特有的错误代码。 并且，JDBC封装包还提供了一种比编程性更好的声明性事务管理方法，不仅仅是实现了特定接口，而且对所有的POJOs（plain old Java objects）都适用。

4.Spring ORM: 

[ORM](http://www.mianwww.com/html/2014/03/19750.html#orm-introduction) 封装包提供了常用的“对象/关系”映射APIs的集成层。 其中包括[JPA](http://blog.chinaunix.net/u/9295/ch12s07.html)、[JDO](http://blog.chinaunix.net/u/9295/ch12s03.html)、[Hibernate](http://blog.chinaunix.net/u/9295/ch12s02.html) 和 [iBatis](http://blog.chinaunix.net/u/9295/ch12s06.html) 。利用ORM封装包，可以混合使用所有Spring提供的特性进行“对象/关系”映射，如前边提到的简单声明性事务管理。

5.Spring AOP: 

Spring的 [AOP](http://www.mianwww.com/html/2014/03/19750.html#aop-introduction) 封装包提供了符合AOP Alliance规范的面向方面的编程实现，让你可以定义，例如方法拦截器（method-interceptors）和切点（pointcuts），从逻辑上讲，从而减弱代码的功能耦合，清晰的被分离开。而且，利用source-level的元数据功能，还可以将各种行为信息合并到你的代码中。

6.Spring Web: 

Spring中的 Web 包提供了基础的针对Web开发的集成特性，例如多方文件上传，利用Servlet listeners进行IOC容器初始化和针对Web的ApplicationContext。当与WebWork或Struts一起使用Spring时，这个包使Spring可与其他框架结合。

7.Spring Web MVC: 

Spring中的[MVC](http://www.mianwww.com/html/2014/03/19750.html#mvc-introduction)封装包提供了Web应用的Model-View-Controller（MVC）实现。Spring的MVC框架并不是仅仅提供一种传统的实现，它提供了一种清晰的分离模型，在领域模型代码和Web Form之间。并且，还可以借助Spring框架的其他特性。

### 94.spring 常用的注入方式有哪些？

## 构造方法注入

先简单看一下测试项目的结构，用maven构建的，四个包：
entity：存储实体，里面只有一个User类
dao：数据访问，一个接口，两个实现类
service：服务层，一个接口，一个实现类，实现类依赖于IUserDao
test：测试包 
![这里写图片描述](https://img-blog.csdn.net/20171028215144010?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTkwOTMwMTc0MA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) 
在spring的配置文件中注册UserService，将UserDaoJdbc通过constructor-arg标签注入到UserService的某个有参数的构造方法

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 注册userService --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;userService&quot; class&#x3D;&quot;com.lyu.spring.service.impl.UserService&quot;&gt;</span><br><span class="line">    &lt;constructor-arg ref&#x3D;&quot;userDaoJdbc&quot;&gt;&lt;&#x2F;constructor-arg&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line">&lt;!-- 注册jdbc实现的dao --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;userDaoJdbc&quot; class&#x3D;&quot;com.lyu.spring.dao.impl.UserDaoJdbc&quot;&gt;&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

如果只有一个有参数的构造方法并且参数类型与注入的bean的类型匹配，那就会注入到该构造方法中。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class UserService implements IUserService &#123;</span><br><span class="line"></span><br><span class="line">    private IUserDao userDao;</span><br><span class="line"></span><br><span class="line">    public UserService(IUserDao userDao) &#123;</span><br><span class="line">        this.userDao &#x3D; userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void loginUser() &#123;</span><br><span class="line">        userDao.loginUser();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">@Test</span><br><span class="line">public void testDI() &#123;</span><br><span class="line">    ApplicationContext ac &#x3D; new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">    &#x2F;&#x2F; 获取bean对象</span><br><span class="line">    UserService userService &#x3D; ac.getBean(UserService.class, &quot;userService&quot;);</span><br><span class="line">    &#x2F;&#x2F; 模拟用户登录</span><br><span class="line">    userService.loginUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

测试打印结果：jdbc-登录成功

注：模拟用户登录的loginUser方法其实只是打印了一条输出语句，jdbc实现的类输出的是：jdbc-登录成功，mybatis实现的类输出的是：mybatis-登录成功。 

问题一：如果有多个有参数的构造方法并且每个构造方法的参数列表里面都有要注入的属性，那userDaoJdbc会注入到哪里呢？

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class UserService implements IUserService &#123;</span><br><span class="line"></span><br><span class="line">    private IUserDao userDao;</span><br><span class="line">    private User user;</span><br><span class="line"></span><br><span class="line">    public UserService(IUserDao userDao) &#123;</span><br><span class="line">        System.out.println(&quot;这是有一个参数的构造方法&quot;);</span><br><span class="line">        this.userDao &#x3D; userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public UserService(IUserDao userDao, User user) &#123;</span><br><span class="line">        System.out.println(&quot;这是有两个参数的构造方法&quot;);</span><br><span class="line">        this.userDao &#x3D; userDao;</span><br><span class="line">        this.user &#x3D; user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void loginUser() &#123;</span><br><span class="line">        userDao.loginUser();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

结果：会注入到只有一个参数的构造方法中，并且经过测试注入哪一个构造方法与构造方法的顺序无关

![这里写图片描述](https://img-blog.csdn.net/20171028223755410?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTkwOTMwMTc0MA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

问题二：如果只有一个构造方法，但是有两个参数，一个是待注入的参数，另一个是其他类型的参数，那么这次注入可以成功吗？

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class UserService implements IUserService &#123;</span><br><span class="line"></span><br><span class="line">    private IUserDao userDao;</span><br><span class="line">    private User user;</span><br><span class="line"></span><br><span class="line">    public UserService(IUserDao userDao, User user) &#123;</span><br><span class="line">        this.userDao &#x3D; userDao;</span><br><span class="line">        this.user &#x3D; user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void loginUser() &#123;</span><br><span class="line">        userDao.loginUser();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

结果：失败了，即使在costract-arg标签里面通过name属性指定要注入的参数名userDao也会失败.

![这里写图片描述](https://img-blog.csdn.net/20171028225646345?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTkwOTMwMTc0MA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

问题三：如果我们想向有多个参数的构造方法中注入值该在配置文件中怎么写呢？

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class UserService implements IUserService &#123;</span><br><span class="line"></span><br><span class="line">    private IUserDao userDao;</span><br><span class="line">    private User user;</span><br><span class="line"></span><br><span class="line">    public UserService(IUserDao userDao, User user) &#123;</span><br><span class="line">        this.userDao &#x3D; userDao;</span><br><span class="line">        this.user &#x3D; user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void loginUser() &#123;</span><br><span class="line">        userDao.loginUser();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

参考写法：通过name属性指定要注入的值，与构造方法参数列表参数的顺序无关。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 注册userService --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;userService&quot; class&#x3D;&quot;com.lyu.spring.service.impl.UserService&quot;&gt;</span><br><span class="line">    &lt;constructor-arg name&#x3D;&quot;userDao&quot; ref&#x3D;&quot;userDaoJdbc&quot;&gt;&lt;&#x2F;constructor-arg&gt;</span><br><span class="line">    &lt;constructor-arg name&#x3D;&quot;user&quot; ref&#x3D;&quot;user&quot;&gt;&lt;&#x2F;constructor-arg&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 注册实体User类，用于测试 --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;com.lyu.spring.entity.User&quot;&gt;&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 注册jdbc实现的dao --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;userDaoJdbc&quot; class&#x3D;&quot;com.lyu.spring.dao.impl.UserDaoJdbc&quot;&gt;&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

问题四：如果有多个构造方法，每个构造方法只有参数的顺序不同，那通过构造方法注入多个参数会注入到哪一个呢？

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class UserService implements IUserService &#123;</span><br><span class="line"></span><br><span class="line">    private IUserDao userDao;</span><br><span class="line">    private User user;</span><br><span class="line"></span><br><span class="line">    public UserService(IUserDao userDao, User user) &#123;</span><br><span class="line">        System.out.println(&quot;这是第二个构造方法&quot;);</span><br><span class="line">        this.userDao &#x3D; userDao;</span><br><span class="line">        this.user &#x3D; user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public UserService(User user, IUserDao userDao) &#123;</span><br><span class="line">        System.out.println(&quot;这是第一个构造方法&quot;);</span><br><span class="line">        this.userDao &#x3D; userDao;</span><br><span class="line">        this.user &#x3D; user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void loginUser() &#123;</span><br><span class="line">        userDao.loginUser();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

结果：哪个构造方法在前就注入哪一个，这种情况下就与构造方法顺序有关。

![这里写图片描述](https://img-blog.csdn.net/20171028231611469?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTkwOTMwMTc0MA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

## setter注入

配置文件如下：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 注册userService --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;userService&quot; class&#x3D;&quot;com.lyu.spring.service.impl.UserService&quot;&gt;</span><br><span class="line">    &lt;!-- 写法一 --&gt;</span><br><span class="line">    &lt;!-- &lt;property name&#x3D;&quot;UserDao&quot; ref&#x3D;&quot;userDaoMyBatis&quot;&gt;&lt;&#x2F;property&gt; --&gt;</span><br><span class="line">    &lt;!-- 写法二 --&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;userDao&quot; ref&#x3D;&quot;userDaoMyBatis&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 注册mybatis实现的dao --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;userDaoMyBatis&quot; class&#x3D;&quot;com.lyu.spring.dao.impl.UserDaoMyBatis&quot;&gt;&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

注：上面这两种写法都可以,spring会将name值的每个单词首字母转换成大写，然后再在前面拼接上”set”构成一个方法名,然后去对应的类中查找该方法,通过反射调用,实现注入。

*切记：name属性值与类中的成员变量名以及set方法的参数名都无关，只与对应的set方法名有关，下面的这种写法是可以运行成功的*

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class UserService implements IUserService &#123;</span><br><span class="line"></span><br><span class="line">    private IUserDao userDao1;</span><br><span class="line"></span><br><span class="line">    public void setUserDao(IUserDao userDao1) &#123;</span><br><span class="line">        this.userDao1 &#x3D; userDao1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void loginUser() &#123;</span><br><span class="line">        userDao1.loginUser();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

还有一点需要注意：如果通过set方法注入属性，那么spring会通过默认的空参构造方法来实例化对象，所以如果在类中写了一个带有参数的构造方法，一定要把空参数的构造方法写上，否则spring没有办法实例化对象，导致报错。 
![这里写图片描述](https://img-blog.csdn.net/20171028235528293?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTkwOTMwMTc0MA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

## 基于注解的注入

在介绍注解注入的方式前，先简单了解bean的一个属性autowire，autowire主要有三个属性值：constructor，byName，byType。

- constructor：通过构造方法进行自动注入，spring会匹配与构造方法参数类型一致的bean进行注入，如果有一个多参数的构造方法，一个只有一个参数的构造方法，在容器中查找到多个匹配多参数构造方法的bean，那么spring会优先将bean注入到多参数的构造方法中。



- byName：被注入bean的id名必须与set方法后半截匹配，并且id名称的第一个单词首字母必须小写，这一点与手动set注入有点不同。



- byType：查找所有的set方法，将符合符合参数类型的bean注入。

下面进入正题：注解方式注册bean，注入依赖 

主要有四种注解可以注册bean，每种注解可以任意使用，只是语义上有所差异：

1. @Component：可以用于注册所有bean
2. @Repository：主要用于注册dao层的bean
3. @Controller：主要用于注册控制层的bean
4. @Service：主要用于注册服务层的bean

描述依赖关系主要有两种：

- @Resource：java的注解，默认以byName的方式去匹配与属性名相同的bean的id，如果没有找到就会以byType的方式查找，如果byType查找到多个的话，使用@Qualifier注解（spring注解）指定某个具体名称的bean。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Resource</span><br><span class="line">@Qualifier(&quot;userDaoMyBatis&quot;)</span><br><span class="line">private IUserDao userDao;</span><br><span class="line"></span><br><span class="line">public UserService()&#123;</span><br></pre></td></tr></table></figure>

- @Autowired：spring注解，默认是以byType的方式去匹配与属性名相同的bean的id，如果没有找到，就通过byName的方式去查找，

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">@Qualifier(&quot;userDaoJdbc&quot;)</span><br><span class="line">private IUserDao userDao;</span><br></pre></td></tr></table></figure>

### 95.spring 中的 bean 是线程安全的吗？

Spring容器中的Bean是否线程安全，容器本身并没有提供Bean的线程安全策略，因此可以说Spring容器中的Bean本身不具备线程安全的特性，但是具体还是要结合具体scope的Bean去研究。

Spring 的 bean 作用域（scope）类型
1、singleton:单例，默认作用域。

2、prototype:原型，每次创建一个新对象。

3、request:请求，每次Http请求创建一个新对象，适用于WebApplicationContext环境下。

4、session:会话，同一个会话共享一个实例，不同会话使用不用的实例。

5、global-session:全局会话，所有会话共享一个实例。

线程安全这个问题，要从单例与原型Bean分别进行说明。

原型Bean
对于原型Bean,每次创建一个新对象，也就是线程之间并不存在Bean共享，自然是不会有线程安全的问题。

单例Bean
对于单例Bean,所有线程都共享一个单例实例Bean,因此是存在资源的竞争。

如果单例Bean,是一个无状态Bean，也就是线程中的操作不会对Bean的成员执行查询以外的操作，那么这个单例Bean是线程安全的。比如Spring mvc 的 Controller、Service、Dao等，这些Bean大多是无状态的，只关注于方法本身。

对于有状态的bean，Spring官方提供的bean，一般提供了通过ThreadLocal去解决线程安全的方法，比如RequestContextHolder、TransactionSynchronizationManager、LocaleContextHolder等。
注： Spring容器本身并没有提供线程安全的策略，因此是否线程安全完全取决于Bean本身的特性。

使用ThreadLocal的好处
使得多线程场景下，多个线程对这个单例Bean的成员变量并不存在资源的竞争，因为ThreadLocal为每个线程保存线程私有的数据。



### 96.spring 支持几种 bean 的作用域？

**1、作用域scope配置项**

作用域限定了Spring Bean的作用范围，在Spring配置文件定义Bean时，通过声明scope配置项，可以灵活定义Bean的作用范围。例如，当你希望每次IOC容器返回的Bean是同一个实例时，可以设置scope为singleton；当你希望每次IOC容器返回的Bean实例是一个新的实例时，可以设置scope为prototype。

scope配置项有5个属性，用于描述不同的作用域。

① singleton

使用该属性定义Bean时，IOC容器仅创建一个Bean实例，IOC容器每次返回的是同一个Bean实例。

② prototype

使用该属性定义Bean时，IOC容器可以创建多个Bean实例，每次返回的都是一个新的实例。

③ request

该属性仅对HTTP请求产生作用，使用该属性定义Bean时，每次HTTP请求都会创建一个新的Bean，适用于WebApplicationContext环境。

④ session

该属性仅用于HTTP Session，同一个Session共享一个Bean实例。不同Session使用不同的实例。

⑤ global-session

该属性仅用于HTTP Session，同session作用域不同的是，所有的Session共享一个Bean实例。

下面重点讨论singleton、prototyp作用域，request、session和global-session类作用域放到Spring MVC章节讨论，这里不再做详细讲述。

**2、singleton作用域**

singleton是默认的作用域，当定义Bean时，如果没有指定scope配置项，Bean的作用域被默认为singleton。singleton属于单例模式，在整个系统上下文环境中，仅有一个Bean实例。也就是说，在整个系统上下文环境中，你通过Spring IOC获取的都是同一个实例。

配置Bean为singleton作用域的配置代码如下。

![img](https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=459408754,3889891596&fm=173&app=25&f=JPEG?w=631&h=72)



singleton作用域示例：

（1）课程案例新建SingletonTest类文件，添加下面的代码。

![img](https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=4261033361,518221037&fm=173&app=25&f=JPEG?w=632&h=312&s=E3B033C11AF484491EDDED0B000030C2)

（2）修改IocPrincipal类文件，添加输出EmailNotice和PhoneNotice实例的hashCode，用于判断程序两次从IOC容器中获取的实例是否为同一实例。

![img](https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=2437833293,720355382&fm=173&app=25&f=JPEG?w=615&h=644&s=E3B033C1DABEC04D5051040B0000E0C2)

（3）执行SingletonTest类文件，输出结果如下图所示。

![img](https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=99164145,873208007&fm=173&app=25&f=JPEG?w=554&h=220&s=6F50ED1A879844614649B8DB020050B3)图1 执行SingletonTest类输出结果

从输出结果可以看出，程序两次从IOC容器中获取的EmailNotice和PhoneNotice实例的hashCode是相同的，说明IOC容器返回的是同一个实例。

**3、prototype作用域**

当一个Bean的作用域被定义prototype时，意味着程序每次从IOC容器获取的Bean都是一个新的实例。因此，对有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用singleton作用域。

配置Bean为singleton作用域的配置代码如下。

![img](https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=352243290,1807531736&fm=173&app=25&f=JPEG?w=615&h=74)

prototype作用域示例：

（1）修改dispatcher.xml配置文件，在定义的Bean中添加prototype属性。

![img](https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=3622617802,2362395338&fm=173&app=25&f=JPEG?w=640&h=338&s=E3D033C51AE5816E0278FC0F020030C1)

（3）执行SingletonTest类文件，输出结果如下图所示。

![img](https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=2776636676,4274394321&fm=173&app=25&f=JPEG?w=554&h=236&s=EF50ED1A9F9844495258B8DA020080B3)图2 添加prototype后执行SingletonTest

从输出结果可以看出，程序两次从IOC容器中获取的EmailNotice和PhoneNotice实例的hashCode是不相同的，说明EmailNotice和PhoneNotice添加prototype作用域后，IOC容器每次返回的都是一个新的实例。

**课程小结**

Spring IOC容器创建一个Bean实例时，可以为Bean指定实例的作用域，作用域包括singleton（单例模式）、prototype（原型模式）、request（HTTP请求）、session（会话）、global-session（全局会话）。

本文重点介绍了singleton和prototype模式，这两个模式的作用域在Spring框架中是经常用到的。对于singleton作用域的Bean，IOC容器每次都返回同一个实例，而prototype作用域的Bean，IOC容器每次产生一个新的实例。

### 97.spring 自动装配 bean 有哪些方式？

1.在Spring中，装配Bean有三种方式：
 （1）在XML中进行显式配置
 （2）在java中进行显式配置
 （3）隐式的bean发现和自动装配（一般推荐使用自动装配bean的方式）
 2.自动装配Bean
 （1）实现方式
 a.组件扫描：spring会自动发现应用上下文中所创建的bean。
 b.自动装配：spring自动满足bean之间的依赖。
 3.如何进行组件扫描？
 （1）在类上面使用@Component注解，表示该类会作为组件类，并告知spring需要为这个类创建bean。但是你需要知道在spring中组件扫描默认是不启用的，我们需要使用@ComponentScan注解，该注解可以在spring中启动组件扫描。
 （2）如果不存在其他的配置，@ComponentScan注解会默认扫描与配置类相同的包。
 （3）除了用注解方式启动组件扫描，还可以使用XML来配置启动组件扫描：



![img](https:////upload-images.jianshu.io/upload_images/98382-314d872655b597db.png?imageMogr2/auto-orient/strip|imageView2/2/w/593/format/webp)

默认会扫描base-package包下带有@Component注解的类，并为其创建bean

（4）为组件扫描的bean进行命名
 a.spring会根据类名为其指定一个id，规则是将类名的第一个字母变为小写。
 b.通过给@Component注解传递参数，比如@Component("user")
 c.通过Java依赖注入规范，提供的@Named注解来进行命名，比如@Named("user")
 （5）设置组件扫描的基础包
 上面提到过我们可以使用@ComponentScan注解或者使用XML来配置基础包：
 a.如果需要指定不同的基础包，那么就需要在@ComponentScan注解的value属性指明包的名称,比如@ComponentScan("wonders")
 b.如果需要设置多个，可以采用basePackages属性，比如@ComponentScan(basePackages={"a","b"})，其中多个包名的形式为数组的形式。
 c.上面两种都是将包名设置为String类型，还可以将其指定为包中所包含的类或者接口，比如：@ComponentScan(basePackageClasses={A.class,B.class})
 4.如何进行自动装配？
 我们可以使用@AutoWired注解，该注解不但可以用在构造器上和类的任何方法上，还可以用在属性的Setter方法上。
 spring会尝试满足方法参数上所声明的依赖，假如有且只有一个bean匹配依赖需求的话，那么这个bean就会被装配起来。如果没有匹配的bean，那么在应用上下文创建的时候，spring会抛出一个异常，为了避免异常出现，可以将@AutoWired的required属性设置为false。spring自动尝试装配的时候，如果没有匹配到，这个bean就会处于未装配的状态，此时需要小心NullPointException的发生。

------

在我开发FTP上传的时候，将url,username,password等放在properties文件中，想通过@Value("${username}")来取值的时候，获取不到。
 首先我的FTP上传是一个工具类，所以我在该类上面添加了@Component注解，这样的话，他就会是一个组建类。
 其次我在需要使用上述变量值的时候，声明为private String url，使用@Value注解，通过EL表达式的方式获取不到值。
 最后做了修改，给该变量添加了一个set方法，就可以通过@Value获取到properties属性文件中变量的值。
 5.如何通过Java代码装配Bean？
 （1）创建配置类，使用@Configuration注解，表示该类是一个配置类。
 （2）使用@Bean注解创建Bean，该注解会告诉Spring这个方法将会返回一个对象，该对象要注册为spring引用上下文中的bean，方法体重包含了最终产生的bean实例的逻辑。默认情况下Bean的id和@Bean的注解的方法名一致，也可以通过设置@Bean注解的name属性来设置bean的名字。
 （3）注入，引用创建bean的方法。默认情况下，spring中的bean都是单例的。
 6.如何通过XML来装配Bean？
 （1）创建一个xml文件，以<beans>为根元素创建。在使用xml的时候，需要在配置文件的最上部声明多个xml模式，这些文件定义了配置spring的XML元素。
 （2）使用<bean>元素来声明一个bean，我们可以给其加一个id，来表示bean的id，class属性表示这个类，并且需要使用全限定的类名。
 （3）构造器注入：<constructor-arg>元素或者spring的c命名空间。c命名来声明构造器参数，作为<bean>元素的一个属性。格式如下：



![img](https:////upload-images.jianshu.io/upload_images/98382-44746cdec98f8493.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

c命名空间

第一个是c:，第二个是构造器参数名，后面是"-ref"，最后是要注入的Bean的id
 （4）字面量的注入，可以采用<constructor-arg>元素的value属性，表示该属性表明给定的值以字面量的形式注入到构造器中。c命名的方式为c:参数索引来装配相同的字面量值。其中XML不允许某个元素的多个属性具有相同的名字。
 （5）集合装配，<list>元素是<constructor-arg>的子元素，表明一个包含值的列表将会传递到构造器中，其中<value>元素用来指定列表中的每个元素。也可以使用<ref bean="">的方式来代替<value>元素。<set>元素也可以，只是<list>和<set>元素还是有区别的，<set>元素会忽略掉所有重复的值，存放顺序也不可以保证。
 （6）属性注入，对于强依赖我们一般用构造器注入，对于非强依赖，我们一般选用属性注入的方式。<property>元素name属性和ref属性，通过ref属性来引用bean，通过name属性来注入。其实，我们也可以采用spring 的p命名空间来替代<property>元素。



![img](https:////upload-images.jianshu.io/upload_images/98382-54f922c862730764.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

p-命名空间格式

（7）字面量注入到属性中，<property name="" value="">
 （8）集合注入到属性中，使用<list>元素
 p-命名空间和c-命名空间的最大区别是：c-命名空间带有"-ref"，而p-命名空间是不带有的，以此可以区分是字面量注入还是构造器注入。
 7.Spring的util-命名空间
 （1）<util:constant>：引用某个类型的public static域，并将其暴露为bean。
 （2）<util:list>:创建一个java.util.List类型的bean，其中包含值或引用。
 （3）<util:map>:创建一个java.util.Map类型的bean，其中包含值或引用。
 （4）<util:properties>:创建一个java.util.Properties类型的bean。
 （5）<util:property-path>:引用一个bean的属性，并将其暴露为bean。
 （6）<util:set>:创建一个java.util.Set类型的bean，其中包含值和引用。

### 98.spring 事务实现方式有哪些？

编程式事务管理，在代码中调用 commit()、rollback()等事务管理相关的方法
maven pom.xml文件

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- mysql驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



编程式事务管理，可以通过 java.sql.Connection 控制事务。spring 配置文件

​        

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">	    http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"driver"</span> <span class="attr">class</span>=<span class="string">"com.mysql.jdbc.Driver"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"datasource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.SimpleDriverDataSource"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">ref</span>=<span class="string">"driver"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>jdbc:mysql://localhost:3306/test<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>root<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"3"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>root<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

</beans>
测试代码



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> constxiong.interview.transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	testManualTransaction();<span class="comment">//测试函数式控制事务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testManualTransaction</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">	ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"spring_transaction.xml"</span>);</span><br><span class="line">	DataSource ds = (DataSource)context.getBean(<span class="string">"datasource"</span>);</span><br><span class="line">	Connection conn = ds.getConnection();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		initTable(conn);<span class="comment">//初始化表</span></span><br><span class="line">		conn.setAutoCommit(<span class="keyword">false</span>);<span class="comment">//设置不自动提交事务</span></span><br><span class="line">		queryUsers(conn);<span class="comment">//查询打印用户表</span></span><br><span class="line">		deleteUser(conn);<span class="comment">//删除 id=1 用户</span></span><br><span class="line">		conn.rollback();<span class="comment">//回滚</span></span><br><span class="line">		queryUsers(conn);<span class="comment">//查询打印用户表</span></span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		conn.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initTable</span><span class="params">(Connection conn)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">	conn.createStatement().execute(<span class="string">"drop table if exists user"</span>);</span><br><span class="line">	conn.createStatement().execute(<span class="string">"create table user(id int, username varchar(60)) ENGINE=InnoDB DEFAULT CHARSET=utf8 "</span>);<span class="comment">//是否支持事务与数据库引擎有关，此处删除 ENGINE=InnoDB DEFAULT CHARSET=utf8 可能不支持事务</span></span><br><span class="line">	conn.createStatement().execute(<span class="string">"insert into user values(1, 'user1')"</span>);</span><br><span class="line">	conn.createStatement().execute(<span class="string">"insert into user values(2, 'user2')"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">(Connection conn)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">	conn.createStatement().execute(<span class="string">"delete from user where id = 1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">queryUsers</span><span class="params">(Connection conn)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">	Statement st = conn.createStatement();</span><br><span class="line">	st.execute(<span class="string">"select * from user"</span>);</span><br><span class="line">	ResultSet rs = st.getResultSet();</span><br><span class="line">	<span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">		System.out.print(rs.getString(<span class="string">"id"</span>));</span><br><span class="line">		System.out.print(<span class="string">" "</span>);</span><br><span class="line">		System.out.print(rs.getString(<span class="string">"username"</span>));</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

}
删除用户语句回滚，打印出两个用户

1 user1
2 user2
1 user1
2 user2

基于 TransactionProxyFactoryBean 的声明式事务管理
新增 UserDao 接口



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> constxiong.interview.transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询用户</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; getUsers();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除用户</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteUser</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure>

}
新增 UserDao 实现

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> constxiong.interview.transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.support.JdbcDaoSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">extends</span> <span class="title">JdbcDaoSupport</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询用户</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; getUsers() &#123;</span><br><span class="line">	String sql = <span class="string">"select * from user"</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.getJdbcTemplate().queryForList(sql);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除用户</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteUser</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">	String sql = <span class="string">"delete from user where id = "</span> + id;</span><br><span class="line">	<span class="keyword">int</span> result = <span class="keyword">this</span>.getJdbcTemplate().update(sql);</span><br><span class="line">	<span class="keyword">if</span> (id == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

}
修改 spring 配置文件，添加事务管理器 DataSourceTransactionManager 和事务代理类 TransactionProxyFactoryBean

​        

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">	    http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"driver"</span> <span class="attr">class</span>=<span class="string">"com.mysql.jdbc.Driver"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"datasource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.SimpleDriverDataSource"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">ref</span>=<span class="string">"driver"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>jdbc:mysql://localhost:3306/test<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>root<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"3"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>root<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao"</span> <span class="attr">class</span>=<span class="string">"constxiong.interview.transaction.UserDaoImpl"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"datasource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"tracnsactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"datasource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userProxy"</span> <span class="attr">class</span>=<span class="string">"org.springframework.transaction.interceptor.TransactionProxyFactoryBean"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"transactionManager"</span> <span class="attr">ref</span>=<span class="string">"tracnsactionManager"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"target"</span> <span class="attr">ref</span>=<span class="string">"userDao"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"transactionAttributes"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 主要 key 是方法   </span></span><br><span class="line"><span class="comment">				ISOLATION_DEFAULT  事务的隔离级别</span></span><br><span class="line"><span class="comment">				PROPAGATION_REQUIRED  传播行为</span></span><br><span class="line"><span class="comment">			--&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- -Exception 表示发生指定异常回滚，+Exception 表示发生指定异常提交 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"deleteUser"</span>&gt;</span>-java.lang.RuntimeException<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

测试代码



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> constxiong.interview.transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionTest</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"spring_transaction.xml"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	testUseTransactionProxy(); <span class="comment">//测试使用 spring TransactionProxyFactoryBean</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testUseTransactionProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> UserDao userDao = (UserDao)context.getBean(<span class="string">"userProxy"</span>);</span><br><span class="line">	printUsers(userDao);<span class="comment">//打印用户</span></span><br><span class="line">	userDao.deleteUser(<span class="number">1</span>);<span class="comment">//删除 id=1 用户</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printUsers</span><span class="params">(UserDao userDao)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (Map&lt;String, Object&gt; user : userDao.getUsers()) &#123;</span><br><span class="line">		System.out.println(user);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

}
 结果输出

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;id=<span class="number">1</span>, username=user1&#125;</span><br><span class="line">&#123;id=<span class="number">2</span>, username=user2&#125;</span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.RuntimeException</span><br><span class="line">	at constxiong.interview.transaction.UserDaoImpl.deleteUser(UserDaoImpl.java:<span class="number">28</span>)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">	at java.lang.reflect.Method.invoke(Method.java:<span class="number">498</span>)</span><br><span class="line">	at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:<span class="number">302</span>)</span><br><span class="line">	at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:<span class="number">190</span>)</span><br><span class="line">	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:<span class="number">157</span>)</span><br><span class="line">	at org.springframework.transaction.interceptor.TransactionInterceptor$<span class="number">1</span>.proceedWithInvocation(TransactionInterceptor.java:<span class="number">99</span>)</span><br><span class="line">	at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:<span class="number">281</span>)</span><br><span class="line">	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:<span class="number">96</span>)</span><br><span class="line">	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:<span class="number">179</span>)</span><br><span class="line">	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:<span class="number">208</span>)</span><br><span class="line">	at com.sun.proxy.$Proxy3.deleteUser(Unknown Source)</span><br><span class="line">	at constxiong.interview.transaction.TransactionTest.testUseTransactionProxy(TransactionTest.java:<span class="number">32</span>)</span><br><span class="line">	at constxiong.interview.transaction.TransactionTest.main(TransactionTest.java:<span class="number">13</span>)</span><br></pre></td></tr></table></figure>



基于注解 @Transactional 的声明式事务管理

​    

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">UserDaoImpl 删除用户方法添加注解 <span class="meta">@Transactional</span>(rollbackFor=RuntimeException<span class="class">.<span class="keyword">class</span>) 出现 <span class="title">RuntimeException</span> 回滚</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">package</span> <span class="title">constxiong</span>.<span class="title">interview</span>.<span class="title">transaction</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.support.JdbcDaoSupport;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">extends</span> <span class="title">JdbcDaoSupport</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询用户</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; getUsers() &#123;</span><br><span class="line">	String sql = <span class="string">"select * from user"</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.getJdbcTemplate().queryForList(sql);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除用户</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Transactional</span>(rollbackFor=RuntimeException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">int</span> <span class="title">deleteUser</span>(<span class="title">int</span> <span class="title">id</span>)</span>&#123;</span><br><span class="line">	String sql = <span class="string">"delete from user where id = "</span> + id;</span><br><span class="line">	<span class="keyword">int</span> result = <span class="keyword">this</span>.getJdbcTemplate().update(sql);</span><br><span class="line">	<span class="keyword">if</span> (id == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

}
修改 spring 配置文件，开启 spring 的事务注解能力

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/tx/spring-tx-3.2.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">	    http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"driver"</span> <span class="attr">class</span>=<span class="string">"com.mysql.jdbc.Driver"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"datasource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.SimpleDriverDataSource"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">ref</span>=<span class="string">"driver"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>jdbc:mysql://localhost:3306/test<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>root<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"3"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>root<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao"</span> <span class="attr">class</span>=<span class="string">"constxiong.interview.transaction.UserDaoImpl"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"datasource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"tracnsactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"datasource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 启用事务注解 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"tracnsactionManager"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

测试代码



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> constxiong.interview.transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionTest</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"spring_transaction.xml"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	testAnnotationTransaction();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAnnotationTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	UserDao userDao = (UserDao)context.getBean(<span class="string">"userDao"</span>);</span><br><span class="line">	printUsers(userDao);</span><br><span class="line">	userDao.deleteUser(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printUsers</span><span class="params">(UserDao userDao)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (Map&lt;String, Object&gt; user : userDao.getUsers()) &#123;</span><br><span class="line">		System.out.println(user);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

​    输出结果

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;id=<span class="number">1</span>, username=user1&#125;</span><br><span class="line">&#123;id=<span class="number">2</span>, username=user2&#125;</span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.RuntimeException</span><br><span class="line">	at constxiong.interview.transaction.UserDaoImpl.deleteUser(UserDaoImpl.java:<span class="number">30</span>)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">	at java.lang.reflect.Method.invoke(Method.java:<span class="number">498</span>)</span><br><span class="line">	at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:<span class="number">302</span>)</span><br><span class="line">	at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:<span class="number">190</span>)</span><br><span class="line">	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:<span class="number">157</span>)</span><br><span class="line">	at org.springframework.transaction.interceptor.TransactionInterceptor$<span class="number">1</span>.proceedWithInvocation(TransactionInterceptor.java:<span class="number">99</span>)</span><br><span class="line">	at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:<span class="number">281</span>)</span><br><span class="line">	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:<span class="number">96</span>)</span><br><span class="line">	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:<span class="number">179</span>)</span><br><span class="line">	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:<span class="number">208</span>)</span><br><span class="line">	at com.sun.proxy.$Proxy5.deleteUser(Unknown Source)</span><br><span class="line">	at constxiong.interview.transaction.TransactionTest.testAnnotationTransaction(TransactionTest.java:<span class="number">20</span>)</span><br><span class="line">	at constxiong.interview.transaction.TransactionTest.main(TransactionTest.java:<span class="number">13</span>)</span><br></pre></td></tr></table></figure>



基于 Aspectj AOP 配置（注解）事务
maven pom.xml 添加 Aspectj 的支持

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



去除 UserDaoImpl 注解@Transactional(rollbackFor=RuntimeException.class)

​    

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> constxiong.interview.transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.support.JdbcDaoSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">extends</span> <span class="title">JdbcDaoSupport</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询用户</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; getUsers() &#123;</span><br><span class="line">	String sql = <span class="string">"select * from user"</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.getJdbcTemplate().queryForList(sql);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除用户</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteUser</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">	String sql = <span class="string">"delete from user where id = "</span> + id;</span><br><span class="line">	<span class="keyword">int</span> result = <span class="keyword">this</span>.getJdbcTemplate().update(sql);</span><br><span class="line">	<span class="keyword">if</span> (id == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

}
修改 spring 配置文件，织入切面

​        

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/tx/spring-tx-3.2.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">	    http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"driver"</span> <span class="attr">class</span>=<span class="string">"com.mysql.jdbc.Driver"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"datasource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.SimpleDriverDataSource"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">ref</span>=<span class="string">"driver"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>jdbc:mysql://localhost:3306/test<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>root<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"3"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>root<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao"</span> <span class="attr">class</span>=<span class="string">"constxiong.interview.transaction.UserDaoImpl"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"datasource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"tracnsactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"datasource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"tracnsactionManager"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 为连接点指定事务属性 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"deleteUser"</span> <span class="attr">rollback-for</span>=<span class="string">"java.lang.RuntimeException"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 切入点配置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"point"</span> <span class="attr">expression</span>=<span class="string">"execution(* *constxiong.interview.transaction.UserDao.deleteUser(..))"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"point"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

测试代码



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> constxiong.interview.transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionTest</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"spring_transaction.xml"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	testAspectjTransaction();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAspectjTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	UserDao userDao = (UserDao)context.getBean(<span class="string">"userDao"</span>);</span><br><span class="line">	printUsers(userDao);</span><br><span class="line">	userDao.deleteUser(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printUsers</span><span class="params">(UserDao userDao)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (Map&lt;String, Object&gt; user : userDao.getUsers()) &#123;</span><br><span class="line">		System.out.println(user);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

​    







输出结果

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;id=<span class="number">1</span>, username=user1&#125;</span><br><span class="line">&#123;id=<span class="number">2</span>, username=user2&#125;</span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.RuntimeException</span><br><span class="line">	at constxiong.interview.transaction.UserDaoImpl.deleteUser(UserDaoImpl.java:<span class="number">28</span>)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">	at java.lang.reflect.Method.invoke(Method.java:<span class="number">498</span>)</span><br><span class="line">	at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:<span class="number">302</span>)</span><br><span class="line">	at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:<span class="number">190</span>)</span><br><span class="line">	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:<span class="number">157</span>)</span><br><span class="line">	at org.springframework.transaction.interceptor.TransactionInterceptor$<span class="number">1</span>.proceedWithInvocation(TransactionInterceptor.java:<span class="number">99</span>)</span><br><span class="line">	at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:<span class="number">281</span>)</span><br><span class="line">	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:<span class="number">96</span>)</span><br><span class="line">	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:<span class="number">179</span>)</span><br><span class="line">	at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:<span class="number">92</span>)</span><br><span class="line">	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:<span class="number">179</span>)</span><br><span class="line">	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:<span class="number">208</span>)</span><br><span class="line">	at com.sun.proxy.$Proxy2.deleteUser(Unknown Source)</span><br><span class="line">	at constxiong.interview.transaction.TransactionTest.testAnnotationTransaction(TransactionTest.java:<span class="number">20</span>)</span><br><span class="line">	at constxiong.interview.transaction.TransactionTest.main(TransactionTest.java:<span class="number">13</span>)</span><br></pre></td></tr></table></figure>



![](<https://img-blog.csdnimg.cn/20190718191321593.png>)

### 99.说一下 spring 的事务隔离？

事务特征
⑴ 原子性（Atomicity）
　　原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，这和前面两篇博客介绍事务的功能是一样的概念，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。
⑵ 一致性（Consistency）
　　一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。
　　拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。
⑶ 隔离性（Isolation）
　　隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。
　　即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。
　　关于事务的隔离性数据库提供了多种隔离级别，稍后会介绍到。
⑷ 持久性（Durability）
　　持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。
　　例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。

事务产生的问题
场景：同一个事务内（同一个服务内）

<table>
<thead>
<tr>
<th>名称</th>
<th>数据的状态</th>
<th>实际行为</th>
<th>产生原因</th>
</tr>
</thead>
<tbody>
<tr>
<td>脏读</td>
<td>未提交</td>
<td>打算提交但是数据回滚了，读取了提交的数据</td>
<td>数据的读取</td>
</tr>
<tr>
<td>不可重复读</td>
<td>已提交</td>
<td>读取了修改前的数据</td>
<td>数据的修改</td>
</tr>
<tr>
<td>幻读</td>
<td>已提交</td>
<td>读取了插入前的数据</td>
<td>数据的插入</td>
</tr>
</tbody>
</table>

事务隔离级

<table>
<thead>
<tr>
<th>名称</th>
<th>结果</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td>Read UnCommitted(读未提交)</td>
<td>什么都不解决</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>Read Committed(读提交)</td>
<td>解决了脏读的问题</td>
<td>–</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>Repeatable Read(重复读)</td>
<td>（mysql的默认级别）解决了不可重复读  ）</td>
<td>–</td>
<td>–</td>
<td>√</td>
</tr>
<tr>
<td>Serializable(序列化)</td>
<td>解决所有问题</td>
<td>–</td>
<td>–</td>
<td>–</td>
</tr>
</tbody>
</table>

READ UNCOMMITTED（读未提交数据）：允许事务读取未被其他事务提交的变更数据，会出现脏读、不可重复读和幻读问题。
READ COMMITTED（读已提交数据）：只允许事务读取已经被其他事务提交的变更数据，可避免脏读，仍会出现不可重复读和幻读问题。
REPEATABLE READ（可重复读）：确保事务可以多次从一个字段中读取相同的值，在此事务持续期间，禁止其他事务对此字段的更新，可以避免脏读和不可重复读，仍会出现幻读问题。
SERIALIZABLE（序列化）：确保事务可以从一个表中读取相同的行，在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作，可避免所有并发问题，但性能非常低。
Spring隔离级别

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int ISOLATION_DEFAULT &#x3D; -1;   默认采用数据库的隔离级</span><br><span class="line">int ISOLATION_READ_UNCOMMITTED &#x3D; Connection.TRANSACTION_READ_UNCOMMITTED;   &#x2F;&#x2F;0000 0001 -&gt; 1 </span><br><span class="line">int ISOLATION_READ_COMMITTED &#x3D; Connection.TRANSACTION_READ_COMMITTED;       &#x2F;&#x2F;0000 0010-&gt; 2</span><br><span class="line">int ISOLATION_REPEATABLE_READ &#x3D; Connection.TRANSACTION_REPEATABLE_READ;     &#x2F;&#x2F;0000 0100-&gt; 4</span><br><span class="line">int ISOLATION_SERIALIZABLE &#x3D; Connection.TRANSACTION_SERIALIZABLE;          &#x2F;&#x2F; 0000 1000-&gt; 8</span><br></pre></td></tr></table></figure>

spring事务7种传播行为
一、Propagation ：
　　key属性确定代理应该给哪个方法增加事务行为。这样的属性最重要的部份是传播行为。有以下选项可供使用：
PROPAGATION_REQUIRED–支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。
PROPAGATION_SUPPORTS–支持当前事务，如果当前没有事务，就以非事务方式执行。
PROPAGATION_MANDATORY–支持当前事务，如果当前没有事务，就抛出异常。
PROPAGATION_REQUIRES_NEW–新建事务，如果当前存在事务，把当前事务挂起。
PROPAGATION_NOT_SUPPORTED–以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
PROPAGATION_NEVER–以非事务方式执行，如果当前存在事务，则抛出异常。

### 100.说一下 spring mvc 运行流程？

![](<https://img-blog.csdnimg.cn/2019071914205413.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM4NzYwMDY5,size_16,color_FFFFFF,t_70>)

1.客户端浏览器向前端控制器（DispatcherServlet）发出请求。

2.DispatcherServlet接收到请求后，调用处理器映射器（HandlerMapping）。

3.HandlerMapping根据请求url查找相应的处理器（Handler，也称后端控制器），返回处理器对象（Handler），并且如果有处理器拦截器（HandlerInterceptor）的话，会将处理器对象（Handler）和处理器拦截器对象（HandlerInterceptor）一并返回给DispatcherServlet。

4.DispatcherServlet拿到这些信息后，会调用处理器适配器（HandlerAdapter），HandlerAdapter会执行Handler，Handler执行处理DispatcherServlet发来的请求，生成ModelAndView对象返回给HandlerAdapter。

5.HandlerAdapter将ModelAndView对象返回给DispatcherServlet。

6.DispatcherServlet在拿到ModelAndView对象之后，将ModelAndView对象发给视图解析器（ViewResolver）。

7.ViewResolver将ModelAndView对象进行解析，生成View对象，将View对象返回给DispatcherServlet。

8.DispatcherServlet拿到View对象，对jsp页面进行渲染（将模型数据填充到视图中），将渲染后的页面呈现给用户。

### 101.spring mvc 有哪些组件？

前端控制器（DispatcherServlet）：主要负责捕获来自客户端的请求和调度各个组件。

处理器映射器（HandlerMapping）：根据url查找后端控制器Handler。

处理器适配器（HandlerAdapter）：执行后端控制器（Handler），拿到后端控制器返回的结果ModelAndView后将结果返回给前端控制器DispatcherServlet。

后端控制器（处理器）（Handler）：主要负责处理前端请求，完成业务逻辑，生成ModelAndView对象返回给HandlerAdapter。

视图解析器（ViewResolver）：主要负责将从DispatcherServlet中拿到的ModelAndView对象进行解析，生成View对象返回给DispatcherServlet。

### 102.@RequestMapping 的作用是什么？

@RequestMapping是一个用来处理请求地址映射的注解，可用于类或者方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。
@RequestMapping注解有六个属性，下面进行详细的说明。
1.value, method
value:指定请求的实际地址，指定的地址可以是URI Template模式。
method:指定请求的method类型，GET、POST、PUT、DELETE等。
2.consumes, produces
consumes:指定处理请求的提交内容类型（Content-Type），例如application/json,text/html。
produces:指定返回的内容类型，仅当request请求头中的（Accept）类型中包含该指定类型才返回。
3.params, headers
params:指定request中必须包含某些参数值才让该方法处理。
headers:指定request中必须包含某些指定的header值，才能让该方法处理请求



### 103.@Autowired 的作用是什么？

@Autowired 是一个注释，它可以对类成员变量、方法及构造函数进行标注，让 spring 完成 bean 自动装配的工作。
@Autowired 默认是按照类去匹配，配合 @Qualifier 指定按照名称去装配 bean。

常见用法



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> blog.service.ArticleService;</span><br><span class="line"><span class="keyword">import</span> blog.service.TagService;</span><br><span class="line"><span class="keyword">import</span> blog.service.TypeService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"><span class="comment">//成员属性字段使用 @Autowired，无需字段的 set 方法</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> TypeService typeService;</span><br><span class="line"><span class="comment">//set 方法使用 @Autowired</span></span><br><span class="line"><span class="keyword">private</span> ArticleService articleService;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setArticleService</span><span class="params">(ArticleService articleService)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.articleService = articleService;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//构造方法使用 @Autowired</span></span><br><span class="line"><span class="keyword">private</span> TagService tagService;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TestController</span><span class="params">(TagService tagService)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.tagService = tagService; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

​    







## 十一、Spring Boot/Spring Cloud

### 104.什么是 spring boot？

Spring Boot使创建独立的、基于生产级Spring的应用程序变得很容易，您可以“直接运行”这些应用程序。

我们对Spring平台和第三方库有自己的见解，这样您就可以轻松入门了。大多数Spring引导应用程序只需要很少的Spring配置。

- 

105.为什么要用 spring boot？

#### Spring Boot特点

- 搭建项目快，几秒钟就可以搭建完成；
- 让测试变的简单，内置了JUnit、Spring Boot Test等多种测试框架，方便测试；
- Spring Boot让配置变的简单，Spring Boot的核心理念：约定大约配置，约定了某种命名规范，可以不用配置，就可以完成功能开发，比如模型和表名一致就可以不用配置，直接进行CRUD（增删改查）的操作，只有表名和模型不一致的时候，配置名称即可；
- 内嵌容器，省去了配置Tomcat的繁琐；
- 方便监控，使用Spring Boot Actuator组件提供了应用的系统监控，可以查看应用配置的详细信息；

SpringBoot的缺点

SpringBoot仅适用于全新Spring项目。将一个传统Spring Framework项目转换为Spring Boot应用程序是一个非常困难和耗时的过程。
集成度较高，使用过程中不太容易了解底层。（我的一位96年毕业的学长，现在带领着一百人的团队做开发。他回来给我们分享了一些话：SpringBoot把程序员变”傻“了，在面试新人的时候说他们都不会偏向于底层一点的东西，比如说SpringMVC。他建议我们在学习SpringBoot的时候，先去学习一下SpringMVC）



### 106.spring boot 核心配置文件是什么？

Spring Boot 的核心配置文件是 application 和 bootstrap 配置文件。
application 配置文件这个容易理解，主要用于 Spring Boot 项目的自动化配置。
bootstrap 配置文件有以下几个应用场景。
使用 Spring Cloud Config 配置中心时，
这时需要在 bootstrap 配置文件中添加连接到配置中心的配置属性来加载外部配置中心的配置信息；
一些固定的不能被覆盖的属性；
一些加密/解密的场景；

107.spring boot 配置文件有哪几种类型？它们有什么区别？

### 108.spring boot 有哪些方式可以实现热部署？

热部署，就是在应用正在运行的时候升级软件，却不需要重新启动应用。

**1、第一种**

在maven项目下，在pox.xml文件中的build中添加spring-loaded依赖，如图：

![img](https://static.oschina.net/uploads/space/2018/0107/120342_SGsN_2358326.png)

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springloaded&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.8.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

然后以CMD命令切换到项目文件目录下，以maven的方式运行项目，命令：mvn spring-boot:run

**2、第二种**

第二种和第一种采用的同样方式，不过需要将spring-loaded下载下来，可到maven仓库下载：

下载地址：<http://mvnrepository.com/artifact/org.springframework/springloaded>
![img](https://static.oschina.net/uploads/space/2018/0107/114054_uDht_2358326.png)

将下面这局代码放到VM arguments中，如图：

-javaagent:D:\maven_jar\springloaded-1.2.8.RELEASE.jar -noverify

注意：红色字为你的jar包所在位置

![img](https://static.oschina.net/uploads/space/2018/0107/114736_CzQ8_2358326.png)

然后直接RUN启动就行了！

**3、第三种**

依赖spring-boot-devtools实现，将以下代码放到dependencies中：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<!-- optional=true,依赖不会传递，该项目依赖devtools；之后依赖SpringBoot1项目的项目如果想要使用devtools，需要重新引入 -->

依赖完，直接运行ApplicationBoot就行了，如图：

![img](https://static.oschina.net/uploads/space/2018/0107/120610_Me6v_2358326.png)

### 109.jpa 和 hibernate 有什么区别？

在学习框架的过程中，发现学的东西很多，但是感觉他们之间的联系区别都不是很了解，知道JPA可以去实现持久化数据到数据库当中，Hibernate也有这样的功能，总以为他们之间是一种平级的关系，拥有同样的作用，是一种可以相互替代的关系，就像你吃饭时，选择吃米饭和吃面条一样，然而，在进行了一番搜索之后，发现并不是那么回事儿。

JPA本身是一种规范，它的本质是一种ORM规范（不是ORM框架，因为JPA并未提供ORM实现，只是制定了规范）因为JPA是一种规范，所以，只是提供了一些相关的接口，但是接口并不能直接使用，JPA底层需要某种JPA实现，JPA现在就是Hibernate功能的一个子集

Hibernate 从3.2开始，就开始兼容JPA。Hibernate3.2获得了Sun TCK的 JPA(Java  Persistence API) 兼容认证。**JPA和Hibernate之间的关系，可以简单的理解为JPA是标准接口，Hibernate是实现，并不是对标关系，借用下图可以看清楚他们之间的关系，Hibernate属于遵循JPA规范的一种实现，但是JPA是Hibernate遵循的规范之一，Hibernate还有其他实现的规范**，所以它们的关系更像是JPA是一种做面条的规范，而Hibernate是一种遵循做面条的规范的汤面，他不仅遵循了做面条的规范，同时也会遵循做汤和调料的其他规范，他们之间并不是吃面条和吃米饭的关系

![img](https://images2018.cnblogs.com/blog/1436045/201808/1436045-20180817162031268-1675607816.png)

1.JPA

  JPA全称： Java Persistence API，JPA通过JDK 5.0注解或XML描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。
  JPA的出现有两个原因：
  其一，简化现有Java EE和Java SE应用的对象持久化的开发工作；
  其二，Sun希望整合对ORM技术，实现持久化领域的统一。

 Sun之所以提出JPA规范，其目的是以官方身份来统一各种ORM框架的规范，包括著名的Hibernate、TopLink等

 不过JPA规范给开发者带来了福音：开发者面向JPA规范的接口，但底层的JPA实现可以任意切换：觉得Hibernate好的，可以选择Hibernate JPA实现；觉得TopLink好的，可以选择TopLink JPA实现……这样开发者可以避免为使用Hibernate学习一套ORM框架，为使用TopLink又要再学习一套ORM框架

  JPA提供的技术：
  (1)ORM映射元数据
  JPA支持XML和JDK 5.0注解两种元数据的形式，元数据描述对象和表之间的映射关系，框架据此将实体对象持
  久化到数据库表中；
  (2)JPA 的API
  用来操作实体对象，执行CRUD操作，框架在后台替我们完成所有的事情，开发者从繁琐的JDBC和SQL代码中解
  脱出来。
  (3)查询语言
  通过面向对象而非面向数据库的查询语言查询数据，避免程序的SQL语句紧密耦合

\2. Hibernate

  JPA是需要Provider来实现其功能的，Hibernate就是JPA Provider中很强的一个。

  例如： 

  (1)实体对象的状态，在Hibernate有自由、持久、游离三种，JPA里有new，managed，detached，removed，而这些状态都是一一对应的。

  (2)flush方法，都是对应的，

  (3)Query query = manager.createQuery(sql)，它在Hibernate里写法上是session，而在JPA中变成了  manager

\3.  JPA和Hibernate之间的关系，可以简单的理解为JPA是标准接口，Hibernate是实现。

  那么Hibernate是如何实现与JPA 的这种关系的呢？

  Hibernate主要是通过三个组件来实现的，及hibernate-annotation、hibernate-entitymanager和hibernate-core。

  (1)hibernate-annotation是Hibernate支持annotation方式配置的基础，它包括了标准的JPA annotation以及  Hibernate自身特殊功能的annotation。

  (2)hibernate-core是Hibernate的核心实现，提供了Hibernate所有的核心功能。

  (3)hibernate-entitymanager实现了标准的JPA，可以把它看成hibernate-core和JPA之间的适配器，它并不直接提供ORM的功能，而是对hibernate-core进行封装，使得Hibernate符合JPA的规范。

　　总的来说，JPA是规范，Hibernate是框架，JPA是持久化规范，而Hibernate实现了JPA。

题外的一些思考：如果抛开JPA直接使用Hibernate的注解来定义一个实例，很快发现了几个问题：

1. jpa中有Entity, Table，hibernate中也有，但是内容不同
2. jpa中有Column,OneToMany等，Hibernate中没有，也没有替代品

​          hibernate对jpa的支持，不是另提供了一套专用于jpa的注解。一些重要的注解如Column, OneToMany等，hibernate没有提供，这说明jpa的注解已经是hibernate 的核心，hibernate只提供了一些补充，而不是两套注解。要是这样，hibernate对jpa的支持还真够足量，我们要使用hibernate注解就必定要使用jpa。

两个额外的问题：

第一个是问如果想用hibernate注解，是不是一定会用到jpa的。网友的回答：“是。如果hibernate认为jpa的注解够用，就直接用。否则会弄一个自己的出来作为补充”

第二个是问，jpa和hibernate都提供了Entity，我们应该用哪个，还是说可以两个一起用？网友回答说“Hibernate的Entity是继承了jpa的，所以如果觉得jpa的不够用，直接使用hibernate的即可”

### 110.什么是 spring cloud？

从字面理解，Spring Cloud 就是致力于分布式系统、云服务的框架。

Spring Cloud 是整个 Spring 家族中新的成员，是最近云服务火爆的必然产物。

Spring Cloud 为开发人员提供了快速构建分布式系统中一些常见模式的工具，例如：

配置管理
服务注册与发现
断路器
智能路由
服务间调用
负载均衡
微代理
控制总线
一次性令牌
全局锁
领导选举
分布式会话
集群状态
分布式消息
……
使用 Spring Cloud 开发人员可以开箱即用的实现这些模式的服务和应用程序。这些服务可以任何环境下运行，包括分布式环境，也包括开发人员自己的笔记本电脑以及各种托管平台。

Spring Cloud 与 Spring Boot
Spring Cloud 基于 Spring Boot 来进行构建服务。这样，开发Spring Cloud 组件时，就能依托 Spring Boot 来实现快速开发。

有关 Spring Boot 内容，可见笔者的视频课程《基于Spring Boot的博客系统实战》（https://waylau.com/spring-boot-blog-video-release/）。

Spring Cloud 与微服务
Spring Cloud 是构建分布式系统的利器，而微服务是当下最火热的分布式系统的类型之一，所以，Spring Cloud 天然是支持微服务的构建的。

在早些年，国内互联网公司盛行采用 Dubbo 来架构微服务。如今，有了更好的选择，那就是 Spring Cloud。有数据显示，Spring Cloud不管是在国内，还是国外，用户数都呈现出爆发式增长。而且，Dubbo 主要只是为了解决服务通信、服务注册等问题，而 Spring Cloud 却是提供微服务架构的完整的解决方案。

那么什么是微服务？

所谓微服务，就是：

微服务架构风格就像是把小的服务开发成单一应用的形式， 运行在其自己的进程中，并采用轻量级的机制进行通信（一般是 HTTP 资源 API）。这些服务都是围绕业务能力来构建，通过全自动部署工具来实现独立部署。这些服务，其可以使用不同的编程语言和不同的数据存储技术，并保持最小化集中管理。

更多有关微服务的理论，可见笔者的博客：https://waylau.com/ahout-microservices/ 。

Spring Cloud 如何实现微服务
说了那么多理论，那么微服务架构如何真实的落地呢？课程
《基于Spring Cloud的微服务实战》（https://waylau.com/spring-cloud-video-release/）给出了真实的答案。

在《基于Spring Cloud的微服务实战》课程中，作者基于Spring Boot + Spring Cloud 技术栈来实现了一个完整的天气预报系统。在课程中，先从 Spring Boot 入手，从0到1 快速搭建了具备高并发能力、界面友好的天气预报系统。而后剖析单块架构的利弊，从而引入微服务架构的概念，并实从1到0实现微服务的拆分。最后引入Spring Cloud 技术来实现对这些微服务的治理，重点讲解了服务注册与发现、服务交互、服务消费、负载均衡、API网关、配置中心、服务熔断、自动扩展等方面的话题。



通过学习该课程，学员不但可以学会 Spring Boot 及 Spring Cloud 最新的周边技术栈（本课程基于最新的 Spring Boot 2.0.0.M4 以及 Spring Cloud Finchley.M2），掌握如何运用上述技术进行整合，搭建框架的能力，熟悉单体架构及微服务架构的特点，并最终实现掌握构建微服务架构的实战能力。

搭建 Spring Cloud 微服务系统需要哪些技术
本课程所涉及的相关的技术有 ：

XML解析：JABX
JSON序列化:Jackson
缓存：Redis
定时器：Quartz Scheduler
Java模版技术Thymeleaf
前端样式：Bootstrap
API网关：Zuul
服务注册与发现：Eureka Server、Eureka Client
服务交互：RestTemplate、Apache HttpClient
服务消费：Ribbon、OpenFeign
负载均衡：Ribbon
配置中心：Config Server、Config Client
服务熔断：Hystrix
项目构建：Gradle

### 111.spring cloud 断路器的作用是什么？

<https://www.jianshu.com/p/74cea05b8ee7>

在微服务架构中，存在着那么多的服务单元，若一个单元出现故障，就会因依赖关系形成故障蔓延，最终导致整个系统的瘫痪，这样的架构相较传统架构就更加的不稳定。为了解决这样的问题，因此产生了断路器模式。

**什么是断路器**

　　断路器模式源于Martin Fowler的[Circuit Breaker](http://martinfowler.com/bliki/CircuitBreaker.html)一文。“断路器”本身是一种开关装置，用于在电路上保护线路过载，当线路中有电器发生短路时，“断路器”能够及时的切断故障电路，防止发生过载、发热、甚至起火等严重后果。

　　在分布式架构中，断路器模式的作用也是类似的，当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个错误响应，而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延。

**Netflix Hystrix**

　　在Spring Cloud中使用了[Hystrix](https://github.com/Netflix/Hystrix) 来实现断路器的功能。Hystrix是Netflix开源的微服务框架套件之一，该框架目标在于通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备拥有回退机制和断路器功能的线程和信号隔离，请求缓存和请求打包，以及监控和配置等功能。

　　接下来我们就以一个简单的例子，介绍一下Spring cloud Hystrix的使用

　　首先在工程中添加spring cloud hystrix的依赖：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

　　在工程的启动类中加入@EnableCircuitBreaker开启熔断器功能

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@EnableCircuitBreaker</span><br><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @LoadBalanced</span><br><span class="line">    public RestTemplate restTemplate()&#123;</span><br><span class="line">        return new RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        SpringApplication.run(Application.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

　　这里也可以使用SpringCloud对应的@SpringCloudApplication注解来修饰启动类，从代码可以看到，该注解包含了其他的三个注解，也就以为着一个标准的SpringCloud程序包含着服务发现和熔断机制。

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@EnableCircuitBreaker</span><br><span class="line">public @interface SpringCloudApplication &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

　　新增`ComputeService`类，在使用ribbon消费服务的函数上增加`@HystrixCommand`注解来指定回调方法

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class ComputeService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    @HystrixCommand(fallbackMethod &#x3D; &quot;addServiceFallback&quot;)</span><br><span class="line">    public String addService()&#123;</span><br><span class="line">        return restTemplate.getForEntity(&quot;http:&#x2F;&#x2F;COMPUTE-SERVICE&#x2F;add?a&#x3D;10&amp;b&#x3D;20&quot;, String.class).getBody();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String addServiceFallback() &#123;</span><br><span class="line">        return &quot;error&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

　　提供rest接口的Controller改为调用ComputeService的addService

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class ConsumerController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ComputeService computeService;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;add&quot;, method &#x3D; RequestMethod.GET)</span><br><span class="line">    public String add() &#123;</span><br><span class="line">        return computeService.addService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

　　验证断路器的回调

- 依次启动eureka-server、compute-service、eureka-ribbon工程
- 访问<http://localhost:1111/>可以看到注册中心的状态
- 访问<http://localhost:3333/add>，页面显示：30
- 关闭compute-service服务后再访问<http://localhost:3333/add>，页面显示：error

#### Feign使用Hystrix

　　注意这里说的是“使用”，没有错，我们不需要在Feigh工程中引入Hystix，Feign中已经依赖了Hystrix，我们可以在未做任何改造前，尝试下面你的操作：

- 依次启动eureka-server、compute-service、eureka-feign工程
- 访问<http://localhost:1111/>可以看到注册中心的状态
- 访问<http://localhost:3333/add>，调用eureka-feign的服务，该服务会去调用compute-service的服务，计算出10+20的值，页面显示30
- 关闭compute-service服务，访问<http://localhost:3333/add>，我们获得了下面的报错信息

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Whitelabel Error Page</span><br><span class="line"></span><br><span class="line">This application has no explicit mapping for &#x2F;error, so you are seeing this as a fallback.</span><br><span class="line"></span><br><span class="line">Sat Jun 25 22:10:05 CST 2016</span><br><span class="line">There was an unexpected error (type&#x3D;Internal Server Error, status&#x3D;500).</span><br><span class="line">add timed-out and no fallback available.</span><br></pre></td></tr></table></figure>

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

　　如果您够仔细，会发现与在ribbon中的报错是不同的，看到`add timed-out and no fallback available`这句，或许您已经猜到什么，看看我们的控制台，可以看到报错信息来自`hystrix-core-1.5.2.jar`，所以在这个工程中，我们要学习的就是如何使用Feign中集成的Hystrix。

　　使用`@FeignClient`注解中的fallback属性指定回调类

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@FeignClient(value &#x3D; &quot;compute-service&quot;, fallback &#x3D; ComputeClientHystrix.class)</span><br><span class="line">public interface ComputeClient &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(method &#x3D; RequestMethod.GET, value &#x3D; &quot;&#x2F;add&quot;)</span><br><span class="line">    Integer add(@RequestParam(value &#x3D; &quot;a&quot;) Integer a, @RequestParam(value &#x3D; &quot;b&quot;) Integer b);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

　　创建回调类`ComputeClientHystrix`，实现`@FeignClient`的接口，此时实现的方法就是对应`@FeignClient`接口中映射的fallback函数。

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class ComputeClientHystrix implements ComputeClient &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Integer add(@RequestParam(value &#x3D; &quot;a&quot;) Integer a, @RequestParam(value &#x3D; &quot;b&quot;) Integer b) &#123;</span><br><span class="line">        return -9999;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

　　再用之前的方法验证一下，是否在compute-service服务不可用的情况下，页面返回了-9999。

### 112.spring cloud 的核心组件有哪些？

Spring Cloud由众多子项目组成，如Spring Cloud Config、Spring Cloud Netflix、Spring Cloud Consul 等，提供了搭建分布式系统及微服务常用的工具，如配置管理、服务发现、断路器、智能路由、微代理、控制总线、一次性token、全局锁、选主、分布式会话和集群状态等，满足了构建微服务所需的所有解决方案。

服务发现——Netflix Eureka

客服端负载均衡——Netflix Ribbon

断路器——Netflix Hystrix

服务网关——Netflix Zuul

分布式配置——Spring Cloud Config

**Eureka**



![img](https:////upload-images.jianshu.io/upload_images/13418826-ecbb93b34ae6dc5f.png?imageMogr2/auto-orient/strip|imageView2/2/w/625/format/webp)

2eur.png

一个RESTful服务，用来定位运行在AWS地区（Region）中的中间层服务。由两个组件组成：Eureka服务器和Eureka客户端。Eureka服务器用作服务注册服务器。Eureka客户端是一个java客户端，用来简化与服务器的交互、作为轮询负载均衡器，并提供服务的故障切换支持。Netflix在其生产环境中使用的是另外的客户端，它提供基于流量、资源利用率以及出错状态的加权负载均衡。

**Ribbon**

Ribbon，主要提供客户侧的软件负载均衡算法。



![img](https:////upload-images.jianshu.io/upload_images/13418826-2ec177b8072baa21.png?imageMogr2/auto-orient/strip|imageView2/2/w/717/format/webp)

3ri.png

Ribbon客户端组件提供一系列完善的配置选项，比如连接超时、重试、重试算法等。Ribbon内置可插拔、可定制的负载均衡组件。下面是用到的一些负载均衡策略：

- 简单轮询负载均衡
- 加权响应时间负载均衡
- 区域感知轮询负载均衡
- 随机负载均衡

Ribbon中还包括以下功能：

- 易于与服务发现组件（比如Netflix的Eureka）集成
- 使用Archaius完成运行时配置
- 使用JMX暴露运维指标，使用Servo发布
- 多种可插拔的序列化选择
- 异步和批处理操作（即将推出）
- 自动SLA框架（即将推出）
- 系统管理/指标控制台（即将推出）

**Hystrix**



![img](https:////upload-images.jianshu.io/upload_images/13418826-526001b574692c6c.png?imageMogr2/auto-orient/strip|imageView2/2/w/557/format/webp)

41h.png

断路器可以防止一个应用程序多次试图执行一个操作，即很可能失败，允许它继续而不等待故障恢复或者浪费 CPU 周期，而它确定该故障是持久的。断路器模式也使应用程序能够检测故障是否已经解决。如果问题似乎已经得到纠正，应用程序可以尝试调用操作。欢迎大家一起学习研究相关技术愿意了解源码的朋友直接求求交流分享技术：2147775633



![img](https:////upload-images.jianshu.io/upload_images/13418826-0cbcafdff135dfcf.png?imageMogr2/auto-orient/strip|imageView2/2/w/598/format/webp)

42h.png

断路器增加了稳定性和灵活性，以一个系统，提供稳定性，而系统从故障中恢复，并尽量减少此故障的对性能的影响。它可以帮助快速地拒绝对一个操作，即很可能失败，而不是等待操作超时（或者不返回）的请求，以保持系统的响应时间。如果断路器提高每次改变状态的时间的事件，该信息可以被用来监测由断路器保护系统的部件的健康状况，或以提醒管理员当断路器跳闸，以在打开状态。



![img](https:////upload-images.jianshu.io/upload_images/13418826-2db5b757de5abc38.png?imageMogr2/auto-orient/strip|imageView2/2/w/646/format/webp)

43h.png

流程图



![img](https:////upload-images.jianshu.io/upload_images/13418826-e3a53f6ab0e51889.png?imageMogr2/auto-orient/strip|imageView2/2/w/800/format/webp)

44h.png

**Zuul**



![img](https:////upload-images.jianshu.io/upload_images/13418826-a30180f2faacb8dc.png?imageMogr2/auto-orient/strip|imageView2/2/w/561/format/webp)

51z.png

类似nginx，反向代理的功能，不过netflix自己增加了一些配合其他组件的特性。

**Spring Cloud Config**



![img](https:////upload-images.jianshu.io/upload_images/13418826-842214bc1df8f310.png?imageMogr2/auto-orient/strip|imageView2/2/w/498/format/webp)

52z.png

这个还是静态的，得配合Spring Cloud Bus实现动态的配置更新。



## 十二、Hibernate

113.为什么要使用 hibernate？

114.什么是 ORM 框架？

115.hibernate 中如何在控制台查看打印的 sql 语句？

116.hibernate 有几种查询方式？

117.hibernate 实体类可以被定义为 final 吗？

118.在 hibernate 中使用 Integer 和 int 做映射有什么区别？

119.hibernate 是如何工作的？

120.get()和 load()的区别？

121.说一下 hibernate 的缓存机制？

122.hibernate 对象有哪些状态？

123.在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？

124.hibernate 实体类必须要有无参构造函数吗？为什么？

## 十三、Mybatis

### 125.mybatis 中 #{}和 ${}的区别是什么？

**区别**

1.#将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。如：order by #user_id#，如果传入的值是111,那么解析成sql时的值为order by "111", 如果传入的值是id，则解析成的sql为order by "id".

2.将传入的数据直接显示生成在sql中。如：orderby将传入的数据直接显示生成在sql中。如：orderbyuser_id$，如果传入的值是111,那么解析成sql时的值为order by user_id, 如果传入的值是id，则解析成的sql为order by id.

3.#方式能够很大程度防止sql注入。

4.$方式无法防止Sql注入。

5.$方式一般用于传入数据库对象，例如传入表名.
　　
6.一般能用#的就别用$.

MyBatis排序时使用order by 动态参数时需要注意，用$而不是#



**实例讲解**：

动态 sql 是 mybatis 的主要特性之一，在 mapper 中定义的参数传到 xml 中之后，在查询之前 mybatis 会对其进行动态解析。mybatis 为我们提供了两种支持动态 sql 的语法：#{} 以及 ${}。

在下面的语句中，如果 name 的值为 zhangsan，则两种方式无任何区别：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from user where name &#x3D; #&#123;name&#125;;</span><br><span class="line">select * from user where name &#x3D; $&#123;name&#125;;</span><br></pre></td></tr></table></figure>

其解析之后的结果均为

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where name &#x3D; &#39;zhangsan&#39;;</span><br></pre></td></tr></table></figure>

但是 #{} 和 ${} 在预编译中的处理是不一样的。

\#{} 在预处理时，会把参数部分用一个占位符 ? 代替，变成如下的 sql 语句：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where name &#x3D; ?;</span><br></pre></td></tr></table></figure>

而 ${} 则只是简单的字符串替换，在动态解析阶段，该 sql 语句会被解析成

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where name &#x3D; &#39;zhangsan&#39;;</span><br></pre></td></tr></table></figure>

以上，#{} 的参数替换是发生在 DBMS 中，而 ${} 则发生在动态解析过程中。



那么，在使用过程中我们应该使用哪种方式呢？

答案是：优先使用 #{}。因为 ${} 会导致 sql 注入的问题。

看下面的例子：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from $&#123;tableName&#125; where name &#x3D; #&#123;name&#125;</span><br></pre></td></tr></table></figure>



在这个例子中，如果表名为

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user; delete user; --</span><br></pre></td></tr></table></figure>



则动态解析之后 sql 如下：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user; delete user; -- where name &#x3D; ?;</span><br></pre></td></tr></table></figure>



--之后的语句被注释掉，而原本查询用户的语句变成了查询所有用户信息+删除用户表的语句，会对数据库造成重大损伤，极大可能导致服务器宕机。

但是表名用参数传递进来的时候，只能使用 ${} 。这也提醒我们在这种用法中要小心sql注入的问题。

### 126.mybatis 有几种分页方式？

**数组分页**

查询出全部数据，然后再list中截取需要的部分。

mybatis接口

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; queryStudentsByArray();</span><br></pre></td></tr></table></figure>

xml配置文件

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id&#x3D;&quot;queryStudentsByArray&quot;  resultMap&#x3D;&quot;studentmapper&quot;&gt;</span><br><span class="line">       select * from student</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure>

service

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">接口</span><br><span class="line">List&lt;Student&gt; queryStudentsByArray(int currPage, int pageSize);</span><br><span class="line">实现接口</span><br><span class="line"> @Override</span><br><span class="line">    public List&lt;Student&gt; queryStudentsByArray(int currPage, int pageSize) &#123;</span><br><span class="line">        &#x2F;&#x2F;查询全部数据</span><br><span class="line">        List&lt;Student&gt; students &#x3D; studentMapper.queryStudentsByArray();</span><br><span class="line">        &#x2F;&#x2F;从第几条数据开始</span><br><span class="line">        int firstIndex &#x3D; (currPage - 1) * pageSize;</span><br><span class="line">        &#x2F;&#x2F;到第几条数据结束</span><br><span class="line">        int lastIndex &#x3D; currPage * pageSize;</span><br><span class="line">        return students.subList(firstIndex, lastIndex); &#x2F;&#x2F;直接在list中截取</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

controller

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@ResponseBody</span><br><span class="line">@RequestMapping(&quot;&#x2F;student&#x2F;array&#x2F;&#123;currPage&#125;&#x2F;&#123;pageSize&#125;&quot;)</span><br><span class="line">public List&lt;Student&gt; getStudentByArray(@PathVariable(&quot;currPage&quot;) int currPage, @PathVariable(&quot;pageSize&quot;) int pageSize) &#123;</span><br><span class="line">    List&lt;Student&gt; student &#x3D; StuServiceIml.queryStudentsByArray(currPage, pageSize);</span><br><span class="line">    return student;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

**sql分页**

mybatis接口

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; queryStudentsBySql(Map&lt;String,Object&gt; data);</span><br></pre></td></tr></table></figure>

xml文件

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id&#x3D;&quot;queryStudentsBySql&quot; parameterType&#x3D;&quot;map&quot; resultMap&#x3D;&quot;studentmapper&quot;&gt;</span><br><span class="line">        select * from student limit #&#123;currIndex&#125; , #&#123;pageSize&#125;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure>

service

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">接口</span><br><span class="line">List&lt;Student&gt; queryStudentsBySql(int currPage, int pageSize);</span><br><span class="line">实现类</span><br><span class="line">public List&lt;Student&gt; queryStudentsBySql(int currPage, int pageSize) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; data &#x3D; new HashedMap();</span><br><span class="line">        data.put(&quot;currIndex&quot;, (currPage-1)*pageSize);</span><br><span class="line">        data.put(&quot;pageSize&quot;, pageSize);</span><br><span class="line">        return studentMapper.queryStudentsBySql(data);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



[springjdbctemplete写分页语句](https://www.cnblogs.com/aeolian/p/9228907.html)

**拦截器分页**

创建拦截器，拦截mybatis接口方法id以ByPage结束的语句

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">package com.autumn.interceptor;</span><br><span class="line"></span><br><span class="line">import org.apache.ibatis.executor.Executor;</span><br><span class="line">import org.apache.ibatis.executor.parameter.ParameterHandler;</span><br><span class="line">import org.apache.ibatis.executor.resultset.ResultSetHandler;</span><br><span class="line">import org.apache.ibatis.executor.statement.StatementHandler;</span><br><span class="line">import org.apache.ibatis.mapping.MappedStatement;</span><br><span class="line">import org.apache.ibatis.plugin.*;</span><br><span class="line">import org.apache.ibatis.reflection.MetaObject;</span><br><span class="line">import org.apache.ibatis.reflection.SystemMetaObject;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Properties;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Intercepts 说明是一个拦截器</span><br><span class="line"> * @Signature 拦截器的签名</span><br><span class="line"> * type 拦截的类型 四大对象之一( Executor,ResultSetHandler,ParameterHandler,StatementHandler)</span><br><span class="line"> * method 拦截的方法</span><br><span class="line"> * args 参数,高版本需要加个Integer.class参数,不然会报错</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Intercepts(&#123;@Signature(type &#x3D; StatementHandler.class, method &#x3D; &quot;prepare&quot;, args &#x3D; &#123;Connection.class&#125;)&#125;)</span><br><span class="line">public class MyPageInterceptor implements Interceptor &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;每页显示的条目数</span><br><span class="line">    private int pageSize;</span><br><span class="line">    &#x2F;&#x2F;当前现实的页数</span><br><span class="line">    private int currPage;</span><br><span class="line">    &#x2F;&#x2F;数据库类型</span><br><span class="line">    private String dbType;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Invocation invocation) throws Throwable &#123;</span><br><span class="line">        &#x2F;&#x2F;获取StatementHandler，默认是RoutingStatementHandler</span><br><span class="line">        StatementHandler statementHandler &#x3D; (StatementHandler) invocation.getTarget();</span><br><span class="line">        &#x2F;&#x2F;获取statementHandler包装类</span><br><span class="line">        MetaObject MetaObjectHandler &#x3D; SystemMetaObject.forObject(statementHandler);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;分离代理对象链</span><br><span class="line">        while (MetaObjectHandler.hasGetter(&quot;h&quot;)) &#123;</span><br><span class="line">            Object obj &#x3D; MetaObjectHandler.getValue(&quot;h&quot;);</span><br><span class="line">            MetaObjectHandler &#x3D; SystemMetaObject.forObject(obj);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (MetaObjectHandler.hasGetter(&quot;target&quot;)) &#123;</span><br><span class="line">            Object obj &#x3D; MetaObjectHandler.getValue(&quot;target&quot;);</span><br><span class="line">            MetaObjectHandler &#x3D; SystemMetaObject.forObject(obj);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;获取连接对象</span><br><span class="line">        &#x2F;&#x2F;Connection connection &#x3D; (Connection) invocation.getArgs()[0];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;object.getValue(&quot;delegate&quot;);  获取StatementHandler的实现类</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;获取查询接口映射的相关信息</span><br><span class="line">        MappedStatement mappedStatement &#x3D; (MappedStatement) MetaObjectHandler.getValue(&quot;delegate.mappedStatement&quot;);</span><br><span class="line">        String mapId &#x3D; mappedStatement.getId();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;statementHandler.getBoundSql().getParameterObject();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;拦截以.ByPage结尾的请求，分页功能的统一实现</span><br><span class="line">        if (mapId.matches(&quot;.+ByPage$&quot;)) &#123;</span><br><span class="line">            &#x2F;&#x2F;获取进行数据库操作时管理参数的handler</span><br><span class="line">            ParameterHandler parameterHandler &#x3D; (ParameterHandler) MetaObjectHandler.getValue(&quot;delegate.parameterHandler&quot;);</span><br><span class="line">            &#x2F;&#x2F;获取请求时的参数</span><br><span class="line">            Map&lt;String, Object&gt; paraObject &#x3D; (Map&lt;String, Object&gt;) parameterHandler.getParameterObject();</span><br><span class="line">            &#x2F;&#x2F;也可以这样获取</span><br><span class="line">            &#x2F;&#x2F;paraObject &#x3D; (Map&lt;String, Object&gt;) statementHandler.getBoundSql().getParameterObject();</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;参数名称和在service中设置到map中的名称一致</span><br><span class="line">            currPage &#x3D; (int) paraObject.get(&quot;currPage&quot;);</span><br><span class="line">            pageSize &#x3D; (int) paraObject.get(&quot;pageSize&quot;);</span><br><span class="line"></span><br><span class="line">            String sql &#x3D; (String) MetaObjectHandler.getValue(&quot;delegate.boundSql.sql&quot;);</span><br><span class="line">            &#x2F;&#x2F;也可以通过statementHandler直接获取</span><br><span class="line">            &#x2F;&#x2F;sql &#x3D; statementHandler.getBoundSql().getSql();</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;构建分页功能的sql语句</span><br><span class="line">            String limitSql;</span><br><span class="line">            sql &#x3D; sql.trim();</span><br><span class="line">            limitSql &#x3D; sql + &quot; limit &quot; + (currPage - 1) * pageSize + &quot;,&quot; + pageSize;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;将构建完成的分页sql语句赋值个体&#39;delegate.boundSql.sql&#39;，偷天换日</span><br><span class="line">            MetaObjectHandler.setValue(&quot;delegate.boundSql.sql&quot;, limitSql);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;调用原对象的方法，进入责任链的下一级</span><br><span class="line">        return invocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获取代理对象</span><br><span class="line">    @Override</span><br><span class="line">    public Object plugin(Object o) &#123;</span><br><span class="line">        &#x2F;&#x2F;生成object对象的动态代理对象</span><br><span class="line">        return Plugin.wrap(o, this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;设置代理对象的参数</span><br><span class="line">    @Override</span><br><span class="line">    public void setProperties(Properties properties) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果项目中分页的pageSize是统一的，也可以在这里统一配置和获取，这样就不用每次请求都传递pageSize参数了。参数是在配置拦截器时配置的。</span><br><span class="line">        String limit1 &#x3D; properties.getProperty(&quot;limit&quot;, &quot;10&quot;);</span><br><span class="line">        this.pageSize &#x3D; Integer.valueOf(limit1);</span><br><span class="line">        this.dbType &#x3D; properties.getProperty(&quot;dbType&quot;, &quot;mysql&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



 配置文件SqlMapConfig.xml



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line"></span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin interceptor&#x3D;&quot;com.autumn.interceptor.MyPageInterceptor&quot;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;limit&quot; value&#x3D;&quot;10&quot;&#x2F;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;dbType&quot; value&#x3D;&quot;mysql&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;plugin&gt;</span><br><span class="line">    &lt;&#x2F;plugins&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>



mybatis配置



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--接口--&gt;</span><br><span class="line">List&lt;AccountExt&gt; getAllBookByPage(@Param(&quot;currPage&quot;)Integer pageNo,@Param(&quot;pageSize&quot;)Integer pageSize);</span><br><span class="line">&lt;!--xml配置文件--&gt;</span><br><span class="line">  &lt;sql id&#x3D;&quot;getAllBooksql&quot; &gt;</span><br><span class="line">    acc.id, acc.cateCode, cate_name, user_id,u.name as user_name, money, remark, time</span><br><span class="line">  &lt;&#x2F;sql&gt;</span><br><span class="line">  &lt;select id&#x3D;&quot;getAllBook&quot; resultType&#x3D;&quot;com.autumn.pojo.AccountExt&quot; &gt;</span><br><span class="line">    select</span><br><span class="line">    &lt;include refid&#x3D;&quot;getAllBooksql&quot; &#x2F;&gt;</span><br><span class="line">    from account as acc</span><br><span class="line">  &lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure>



service

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;AccountExt&gt; getAllBookByPage(String pageNo,String pageSize) &#123;</span><br><span class="line">    return accountMapper.getAllBookByPage(Integer.parseInt(pageNo),Integer.parseInt(pageSize));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

controller



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;getAllBook&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public Page getAllBook(String pageNo,String pageSize,HttpServletRequest request,HttpServletResponse response)&#123;</span><br><span class="line">    pageNo&#x3D;pageNo&#x3D;&#x3D;null?&quot;1&quot;:pageNo;   &#x2F;&#x2F;当前页码</span><br><span class="line">    pageSize&#x3D;pageSize&#x3D;&#x3D;null?&quot;5&quot;:pageSize;   &#x2F;&#x2F;页面大小</span><br><span class="line">    &#x2F;&#x2F;获取当前页数据</span><br><span class="line">    List&lt;AccountExt&gt; list &#x3D; bookService.getAllBookByPage(pageNo,pageSize);</span><br><span class="line">    &#x2F;&#x2F;获取总数据大小</span><br><span class="line">    int totals &#x3D; bookService.getAllBook();</span><br><span class="line">    &#x2F;&#x2F;封装返回结果</span><br><span class="line">    Page page &#x3D; new Page();</span><br><span class="line">    page.setTotal(totals+&quot;&quot;);</span><br><span class="line">    page.setRows(list);</span><br><span class="line">    return page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



Page实体类



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.autumn.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Autumn on 2018/6/21.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Page</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String pageNo = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> String pageSize = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> String total = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> List rows = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTotal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTotal</span><span class="params">(String total)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.total = total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List <span class="title">getRows</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rows;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRows</span><span class="params">(List rows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rows = rows;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPageNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pageNo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPageNo</span><span class="params">(String pageNo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pageNo = pageNo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPageSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pageSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPageSize</span><span class="params">(String pageSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pageSize = pageSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



前端

bootstrap-table接受数据格式



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;total&quot;: 3,</span><br><span class="line">  &quot;rows&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;id&quot;: 0,</span><br><span class="line">      &quot;name&quot;: &quot;Item 0&quot;,</span><br><span class="line">      &quot;price&quot;: &quot;$0&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;id&quot;: 1,</span><br><span class="line">      &quot;name&quot;: &quot;Item 1&quot;,</span><br><span class="line">      &quot;price&quot;: &quot;$1&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



boostrap-table用法



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">  var $table &#x3D; $(&#39;#table&#39;);</span><br><span class="line">  $table.bootstrapTable(&#123;</span><br><span class="line">  url: &quot;&#x2F;$&#123;appName&#125;&#x2F;manager&#x2F;bookController&#x2F;getAllBook&quot;,</span><br><span class="line">  method: &#39;post&#39;,</span><br><span class="line">  contentType: &quot;application&#x2F;x-www-form-urlencoded&quot;,</span><br><span class="line">  dataType: &quot;json&quot;,</span><br><span class="line">  pagination: true, &#x2F;&#x2F;分页</span><br><span class="line">  sidePagination: &quot;server&quot;, &#x2F;&#x2F;服务端处理分页</span><br><span class="line">  pageList: [5, 10, 25],</span><br><span class="line">  pageSize: 5,</span><br><span class="line">  pageNumber:1,</span><br><span class="line">  &#x2F;&#x2F;toolbar:&quot;#tb&quot;,</span><br><span class="line">  singleSelect: false,</span><br><span class="line">  queryParamsType : &quot;limit&quot;,</span><br><span class="line">  queryParams: function queryParams(params) &#123;   &#x2F;&#x2F;设置查询参数</span><br><span class="line">    var param &#x3D; &#123;</span><br><span class="line">      pageNo: params.offset&#x2F;params.limit+1,  &#x2F;&#x2F;offset为数据开始索引,转换为显示当前页</span><br><span class="line">      pageSize: params.limit  &#x2F;&#x2F;页面大小</span><br><span class="line">    &#125;;</span><br><span class="line">    console.info(params);   &#x2F;&#x2F;查看参数是什么</span><br><span class="line">    console.info(param);   &#x2F;&#x2F;查看自定义的参数</span><br><span class="line">    return param;</span><br><span class="line">  &#125;,</span><br><span class="line">  cache: false,</span><br><span class="line">  &#x2F;&#x2F;data-locale: &quot;zh-CN&quot;, &#x2F;&#x2F;表格汉化</span><br><span class="line">  &#x2F;&#x2F;search: true, &#x2F;&#x2F;显示搜索框</span><br><span class="line">  columns: [</span><br><span class="line">          &#123;</span><br><span class="line">              checkbox: true</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">              title: &#39;消费类型&#39;,</span><br><span class="line">              field: &#39;cate_name&#39;,</span><br><span class="line">              valign: &#39;middle&#39;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">              title: &#39;消费金额&#39;,</span><br><span class="line">              field: &#39;money&#39;,</span><br><span class="line">              valign: &#39;middle&#39;,</span><br><span class="line">              formatter:function(value,row,index)&#123;</span><br><span class="line">                  if(!isNaN(value))&#123;   &#x2F;&#x2F;是数字</span><br><span class="line">                      return value&#x2F;100;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">              title: &#39;备注&#39;,</span><br><span class="line">              field: &#39;remark&#39;,</span><br><span class="line">              valign: &#39;middle&#39;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">              title: &#39;消费时间&#39;,</span><br><span class="line">              field: &#39;time&#39;,</span><br><span class="line">              valign: &#39;middle&#39;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">              title: &#39;操作&#39;,</span><br><span class="line">              field: &#39;&#39;,</span><br><span class="line">              formatter:function(value,row,index)&#123;</span><br><span class="line">                  var f &#x3D; &#39;&lt;a href&#x3D;&quot;#&quot; class&#x3D;&quot;btn btn-gmtx-define1&quot; onclick&#x3D;&quot;delBook(\&#39;&#39;+ row.id +&#39;\&#39;)&quot;&gt;删除&lt;&#x2F;a&gt; &#39;;</span><br><span class="line">                  return f;</span><br><span class="line">                 &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

**RowBounds分页**

数据量小时，RowBounds不失为一种好办法。但是数据量大时，实现拦截器就很有必要了。

mybatis接口加入RowBounds参数



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;UserBean&gt; <span class="title">queryUsersByPage</span><span class="params">(String userName, RowBounds rowBounds)</span></span>;</span><br><span class="line"></span><br><span class="line">service   </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span>(isolation = Isolation.READ_COMMITTED, propagation = Propagation.SUPPORTS)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;RoleBean&gt; <span class="title">queryRolesByPage</span><span class="params">(String roleName, <span class="keyword">int</span> start, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> roleDao.queryRolesByPage(roleName, <span class="keyword">new</span> RowBounds(start, limit));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

### 127.RowBounds 是一次性查询全部结果吗？为什么？

Mybatis可以通过传递RowBounds对象，来进行数据库数据的分页操作，然而遗憾的是，该分页操作是对ResultSet结果集进行分页，也就是人们常说的逻辑分页，而非物理分页。

### 128.mybatis 逻辑分页和物理分页的区别是什么？

**1.物理分页**

物理分页就是数据库本身提供了分页方式，如MySQL的limit，oracle的rownum ，好处是效率高，不好的地方就是不同数据库有不同的搞法。

**2.逻辑分页**

逻辑分页利用游标分页，好处是所有数据库都统一，坏处就是效率低。

**3.常用ORM框架采用的分页技术**

①：hibernate采用的是物理分页；

②：MyBatis使用RowBounds实现的分页是逻辑分页,也就是先把数据记录全部查询出来,然在再根据offset和limit截断记录返回（数据量大的时候会造成内存溢出），不过可以用插件或其他方式能达到物理分页效果。

 **mybatis的物理分页插件：**

常见的两种： Mybatis-Paginator Mybatis-PageHelper

   为了在数据库层面上实现物理分页,又不改变原来MyBatis的函数逻辑,可以编写plugin截获MyBatis Executor的statementhandler,重写SQL来执行查询

分页结论：
1.物理分页速度上并不一定快于逻辑分页，逻辑分页速度上也并不一定快于物理分页。
2.物理分页总是优于逻辑分页：没有必要将属于数据库端的压力加诸到应用端来，就算速度上存在优势,然而其它性能上的优点足以弥补这个缺点。
3.在分页工作前，有必要了解使用数据库本身的一些sql语句特点更好的分页

### 129.mybatis 是否支持延迟加载？延迟加载的原理是什么？

  MyBatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。

在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。

它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，

那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。

### 130.说一下 mybatis 的一级缓存和二级缓存？

# 1.一级缓存

一级缓存是SqlSession级别的缓存。在操作数据库时需要构造 sqlSession对象，在对象中有一个(内存区域)数据结构（HashMap）用于存储缓存数据。不同的sqlSession之间的缓存数据区域（HashMap）是互相不影响的。

Mybatis默认开启一级缓存。

一级缓存的作用域是同一个SqlSession，在同一个sqlSession中两次执行相同的sql语句，第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从缓存中获取数据将不再从数据库查询，从而提高查询效率。当一个sqlSession结束后该sqlSession中的一级缓存也就不存在了。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCache1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">      SqlSessionsqlSession = sqlSessionFactory.openSession();<span class="comment">//创建代理对象</span></span><br><span class="line">      UserMapperuserMapper = sqlSession.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//下边查询使用一个SqlSession</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//第一次发起请求，查询id为1的用户</span></span><br><span class="line">      Useruser1 = userMapper.findUserById(<span class="number">1</span>);</span><br><span class="line">      System.out.println(user1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//    如果sqlSession去执行commit操作（执行插入、更新、删除），清空SqlSession中的一级缓存，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//更新user1的信息</span></span><br><span class="line">      user1.setUsername(<span class="string">"测试用户22"</span>);</span><br><span class="line">      userMapper.updateUser(user1);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//执行commit操作去清空缓存</span></span><br><span class="line">      sqlSession.commit();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//第二次发起请求，查询id为1的用户</span></span><br><span class="line">      Useruser2 = userMapper.findUserById(<span class="number">1</span>);</span><br><span class="line">      System.out.println(user2);</span><br><span class="line">     </span><br><span class="line">      sqlSession.close();</span><br><span class="line"> &#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627</span></span><br></pre></td></tr></table></figure>

如果不commit的错误流程为：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">开始执行时，开启事务，创建SqlSession对象</span><br><span class="line">第一次调用mapper的方法findUserById(1)</span><br><span class="line">更新数据</span><br><span class="line">第二次调用mapper的方法findUserById(1)，从一级缓存中取数据</span><br><span class="line">aop控制 只要方法结束，sqlSession关闭 sqlsession关闭后就销毁数据结构，清空缓存</span><br><span class="line">Service结束sqlsession关闭</span><br><span class="line">123456</span><br></pre></td></tr></table></figure>

因为上面有commmit操作，所以正确流程

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">开始执行时，开启事务，创建SqlSession对象</span><br><span class="line">第一次调用mapper的方法findUserById(1)</span><br><span class="line">更新数据</span><br><span class="line">清空commit</span><br><span class="line">第二次调用mapper的方法findUserById(1)，从一级缓存中无数据，从数据库中取数据</span><br><span class="line">aop控制 只要方法结束，sqlSession关闭 sqlsession关闭后就销毁数据结构，清空缓存</span><br><span class="line">Service结束sqlsession关闭</span><br><span class="line">1234567</span><br></pre></td></tr></table></figure>

只要是在同一个sqlssesion中，一级缓存才会生效，如果sqlssesion.commit()或者是sqlsession.close()就会清空sqlssion，一级缓存也随之消失。

**2.二级缓存**

二级缓存介绍

二级缓存是mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession去操作数据库得到数据会存在二级缓存区域，多个SqlSession可以共用二级缓存，二级缓存是多个SqlSession共享的。

UserMapper有一个二级缓存区域（按namespace分，如果namespace相同则使用同一个相同的二级缓存区），其它mapper也有自己的二级缓存区域（按namespace分）。

也是就是说拥有相同的namespace的UserMapper共享一个二级缓存

开启缓存

SqlMapConfig.xml中

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span><span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 全局配置参数，需要时再设置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开启二级缓存  默认值为true --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"></span><br><span class="line">12345678</span><br></pre></td></tr></table></figure>

在UserMapper.xml中开启二缓存，UserMapper.xml下的sql执行完成会存储到它的缓存区域（HashMap）。

下面是开启redis缓存：

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"cn.mybatis.xml.mapper.UserMapper"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">&lt;!-- redis配置项 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">"org.mybatis.caches.redis.RedisCache"</span> /&gt;</span> </span><br><span class="line">    ...</span><br><span class="line">12345</span><br></pre></td></tr></table></figure>

至于具体的redis与mybatis的整合请参见：<https://blog.csdn.net/magi1201/article/details/85635878>

如何使用二级缓存

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Userimplements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Serializable实现序列化，为了将来反序列化</span></span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="comment">// 二级缓存测试</span></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCache2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      SqlSessionsqlSession1 = sqlSessionFactory.openSession();</span><br><span class="line">      SqlSessionsqlSession2 = sqlSessionFactory.openSession();</span><br><span class="line">      SqlSessionsqlSession3 = sqlSessionFactory.openSession();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 创建代理对象</span></span><br><span class="line">      UserMapperuserMapper1 = sqlSession1.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 第一次发起请求，查询id为1的用户</span></span><br><span class="line">      Useruser1 = userMapper1.findUserById(<span class="number">1</span>);</span><br><span class="line">      System.out.println(user1);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//这里执行关闭操作，将sqlsession中的数据写到二级缓存区域</span></span><br><span class="line">      sqlSession1.close();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//使用sqlSession3执行commit()操作</span></span><br><span class="line">      UserMapperuserMapper3 = sqlSession3.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      Useruser  = userMapper3.findUserById(<span class="number">1</span>);</span><br><span class="line">      user.setUsername(<span class="string">"张明明"</span>);</span><br><span class="line">      userMapper3.updateUser(user);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//执行提交，清空UserMapper下边的二级缓存</span></span><br><span class="line">      sqlSession3.commit();</span><br><span class="line">      sqlSession3.close();</span><br><span class="line"></span><br><span class="line">      UserMapperuserMapper2 = sqlSession2.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 第二次发起请求，查询id为1的用户</span></span><br><span class="line">      Useruser2 = userMapper2.findUserById(<span class="number">1</span>);</span><br><span class="line">      System.out.println(user2);</span><br><span class="line"></span><br><span class="line">      sqlSession2.close();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334353637</span></span><br></pre></td></tr></table></figure>

执行流程：

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sqlsession1中使用findUserById(<span class="number">1</span>)</span><br><span class="line">关闭sqlsession1</span><br><span class="line">sqlsession3中使用findUserById(<span class="number">1</span>)，从缓存中取出数据</span><br><span class="line">sqlSession3.commit();</span><br><span class="line">sqlSession3.close()</span><br><span class="line">sqlSession2中使用findUserById(<span class="number">1</span>)无法拿到数据（commit刷新二级缓存）</span><br><span class="line">sqlSession2.close()</span><br></pre></td></tr></table></figure>

### 131.mybatis 和 hibernate 的区别有哪些？

### 132.mybatis 有哪些执行器（Executor）？

#### Mybatis有三种基本的Executor执行器:

#### **SimpleExecutor、ReuseExecutor、BatchExecutor。**  

**SimpleExecutor：**每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。

**ReuseExecutor：**执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map内，供下一次使用。简言之，就是重复使用Statement对象。

**BatchExecutor：**执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。

作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。

------

Mybatis中如何指定使用哪一种Executor执行器？

答：在Mybatis配置文件中，可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数。





### 133.mybatis 分页插件的实现原理是什么？

**1. SQL 分页**

<select id="queryStudentsBySql" parameterType="map" resultMap="studentmapper"> 

​           **select \* from student limit #{currIndex} , #{pageSize}**

</select>

\2. [使用拦截器分页](http://www.cnblogs.com/aeolian/p/9229149.html)

创建拦截器，拦截mybatis接口方法id以ByPage结束的语句

​         String sql = (String) MetaObjectHandler.getValue("delegate.boundSql.sql");

​            //也可以通过statementHandler直接获取

​            //sql = statementHandler.getBoundSql().getSql();

​            //构建分页功能的sql语句            String limitSql;

​            sql = sql.trim();

​            limitSql = sql + " limit " + (currPage - 1) * pageSize + "," + pageSize;

​            //将构建完成的分页sql语句赋值个体'delegate.boundSql.sql'，偷天换日           MetaObjectHandler.setValue("delegate.boundSql.sql", limitSql);



------

<configuration>

​      **<plugins>**

​                   **<plugin interceptor="com.autumn.interceptor.MyPageInterceptor">**

​                               **<property name="limit" value="10"/>**

​                               **<property name="dbType" value="mysql"/>**

​                  **</plugin>**

​          **</plugins>**

</configuration>



**通过自定义插件的形式实现分页，也是最好的，也叫做分页拦截器。实现步骤如下：**

**插件支持MySQL和Oracle两种数据库，通过方法名关键字ListPage去匹配，有才进行分页处理，并且不用在Mapping中写分页代码。**

**<?xml version="1.0" encoding="UTF-8" ?>**

<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN"

"http://mybatis.org/dtd/mybatis-3-config.dtd">

<configuration>

​    <typeAliases>

​        <typeAlias alias="PageInfo" type="com.jsoft.testmybatis.util.PageInfo" />

​    </typeAliases>

​    <plugins>

​        <plugin interceptor="com.jsoft.testmybatis.util.PagePlugin">

​            <property name="dialect" value="mysql" />

​            <property name="pageSqlId" value=".*ListPage.*" />

​        </plugin>

​    </plugins>

</configuration>







------

**3. RowBounds分页**

Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。



数据量小时，RowBounds不失为一种好办法。但是数据量大时，实现拦截器就很有必要了。

mybatis接口加入RowBounds参数

(1)Dao:

​     public List queryUsersByPage(String userName**, RowBounds rowBounds**);

(2)Service:

   @Override

​    @Transactional(isolation = Isolation.READ_COMMITTED, propagation = Propagation.SUPPORTS)

​    publicList queryRolesByPage(String roleName,intstart,int limit) {

​        returnroleDao.queryRolesByPage(roleName,new RowBounds(start, limit));

​    }



------

分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。

举例：select * from student，拦截sql后重写为：select t.* from （select * from student）t limit 0，10



### 134.mybatis 如何编写一个自定义插件？

Mybatis插件原理和执行流程
对四大对象和插件有了一定了解后，这里我就开始简单实现一个自定义插件，来拦截四大对象，实现拦截器功能。
步骤：

1. 编写Interceptor的实现类
2. 使用@Intercepts注解完成插件签名 说明插件的拦截四大对象之一的哪一个对象的哪一个方法
3. 将写好的插件注册到全局配置文件中
   编写Interceptor的实现类（dao层）以及注解声明
   注解参数：

type：拦截对象（四大对象之一）
method：拦截对象的方法
args：当前方法的参数列表
1
2
3
编写Interceptor的实现类：



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@Intercepts(&#123;</span><br><span class="line">    @Signature(type&#x3D;StatementHandler.class,method&#x3D;&quot;parameterize&quot;,args&#x3D;java.sql.Statement.class)</span><br><span class="line">&#125;)</span><br><span class="line">public class MyfirstPlugin implements Interceptor &#123;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 拦截目标对象的目标方法的执行；</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public Object intercept(Invocation invocation) throws Throwable &#123;</span><br><span class="line">    &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">    System.out.println(&quot;要拦截的方法&quot;+invocation+invocation.getMethod());</span><br><span class="line">    Object prObject &#x3D; invocation.proceed();</span><br><span class="line">    return prObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 包装目标对象的：包装：为目标对象创建一个代理对象</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public Object plugin(Object target) &#123;</span><br><span class="line">    &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">    System.out.println(&quot;包装的对象&quot;+target.toString());</span><br><span class="line">    Object wrap &#x3D; Plugin.wrap(target, this);</span><br><span class="line">    return wrap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * setProperties：</span><br><span class="line"> *      将插件注册时 的property属性设置进来</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public void setProperties(Properties properties) &#123;</span><br><span class="line">    &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">    System.out.println(properties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

}

全局配置文件：
<plugins>
    <plugin interceptor="dao.MyfirstPlugin">
    <property name="root" value="jjc"/>
    <property name="pwdword" value="123456"/>
    </plugin>
</plugins>  

注意：
如果是 两个不同的插件对同一个对象的同一个方法进行拦截的时候
第一个插件的plugin方法的参数是未包装对象
第二个插件的plugin方法的参数是第一个插件包装后的对象

举一个栗子：当你查询id为2的内容 结果显示id为4的内容
查看id内容存放位置：
包装的对象org.apache.ibatis.executor.statement.RoutingStatementHandler@7c541c15
根据以上的内容知道创建的StatementHandler接口实现类是RoutingStatementHandler 是中间类
然后 找到这个类 ：默认是PREPARED

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> PREPARED:</span><br><span class="line">        delegate = <span class="keyword">new</span> PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        再进入PreparedStatementHandler类：</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parameterize</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    parameterHandler.setParameters((PreparedStatement) statement);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



  parameterHandler是BaseStatementHandler的属性
  相当于parameterHandler是PreparedStatementHandler的属性

这个接口实现类是：DefaultParameterHandler

DefaultParameterHandler类中属性：

  Object parameterObject封装的就是参数值
  MappedStatement mappedStatement封装当前对象的增删改查详细信息的
  BoundSql boundSql封装sql的详细信息的

编写截目标对象的目标方法的执行：

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">       <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">       System.out.println(<span class="string">"要拦截的方法"</span>+invocation+invocation.getMethod());</span><br><span class="line">       <span class="comment">//得到当前对象</span></span><br><span class="line">       Object target = invocation.getTarget();</span><br><span class="line">       System.out.println(<span class="string">"拦截的对象："</span>+target);</span><br><span class="line">       <span class="comment">//拿到：StatementHandler==&gt;ParameterHandler===&gt;parameterObject</span></span><br><span class="line">       <span class="comment">//拿到target的元数据</span></span><br><span class="line">       MetaObject metaobject = SystemMetaObject.forObject(target);</span><br><span class="line">       Object value = metaobject.getValue(<span class="string">"parameterHandler.parameterObject"</span>);</span><br><span class="line">       System.out.println(<span class="string">"当前参数值："</span>+value);</span><br><span class="line">       <span class="comment">//修改完sql语句要用的参数</span></span><br><span class="line">       metaobject.setValue(<span class="string">"parameterHandler.parameterObject"</span>, <span class="number">4</span>);</span><br><span class="line">       <span class="comment">//执行原来的方法</span></span><br><span class="line">       Object prObject = invocation.proceed();</span><br><span class="line">       <span class="keyword">return</span> prObject;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>





## 十四、RabbitMQ

135.rabbitmq 的使用场景有哪些？

136.rabbitmq 有哪些重要的角色？

137.rabbitmq 有哪些重要的组件？

138.rabbitmq 中 vhost 的作用是什么？

139.rabbitmq 的消息是怎么发送的？

140.rabbitmq 怎么保证消息的稳定性？

141.rabbitmq 怎么避免消息丢失？

142.要保证消息持久化成功的条件有哪些？

143.rabbitmq 持久化有什么缺点？

144.rabbitmq 有几种广播类型？

145.rabbitmq 怎么实现延迟消息队列？

146.rabbitmq 集群有什么用？

147.rabbitmq 节点的类型有哪些？

148.rabbitmq 集群搭建需要注意哪些问题？

149.rabbitmq 每个节点是其他节点的完整拷贝吗？为什么？

150.rabbitmq 集群中唯一一个磁盘节点崩溃了会发生什么情况？

151.rabbitmq 对集群节点停止顺序有要求吗？

## 十五、Kafka

152.kafka 可以脱离 zookeeper 单独使用吗？为什么？

153.kafka 有几种数据保留的策略？

154.kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka 将如何处理？

155.什么情况会导致 kafka 运行变慢？

156.使用 kafka 集群需要注意什么？

## 十六、Zookeeper

157.zookeeper 是什么？

158.zookeeper 都有哪些功能？

159.zookeeper 有几种部署模式？

160.zookeeper 怎么保证主从节点的状态同步？

161.集群中为什么要有主节点？

162.集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？

163.说一下 zookeeper 的通知机制？

## 十七、MySql

### 164.数据库的三范式是什么？

数据库中三大范式的定义如下：

1、第一范式：

当关系模式R的所有属性都不能在分解为更基本的数据单位时，称R是满足第一范式的，简记为1NF。满足第一范式是关系模式规范化的最低要求，否则，将有很多基本操作在这样的关系模式中实现不了。

2、第二范式：

如果关系模式R满足第一范式，并且R得所有非主属性都完全依赖于R的每一个候选关键属性，称R满足第二范式，简记为2NF。

3、第三范式：

设R是一个满足第一范式条件的关系模式，X是R的任意属性集，如果X非传递依赖于R的任意一个候选关键字，称R满足第三范式，简记为3NF。

### 165.一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 mysql 数据库，又插入了一条数据，此时 id 是几？

一般情况下，我们创建的表的类型是InnoDB，如果新增一条记录（不重启mysql的情况下），这条记录的id是8；但是如果重启（文中提到的）MySQL的话，这条记录的ID是6。因为InnoDB表只把自增主键的最大ID记录到内存中，所以重启数据库或者对表OPTIMIZE操作，都会使最大ID丢失。

但是，如果我们使用表的类型是MylSAM，那么这条记录的ID就是8。因为MylSAM表会把自增主键的最大ID记录到数据文件里面，重启MYSQL后，自增主键的最大ID也不会丢失。

注：如果在这7条记录里面删除的是中间的几个记录（比如删除的是3,4两条记录），重启MySQL数据库后，insert一条记录后，ID都是8。因为内存或者数据库文件存储都是自增主键最大ID



### 166.如何获取当前数据库版本？

一种方法：

打开mysql在命令提示符上输入  select version();如图

![](<https://img-blog.csdn.net/20180123170452767?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfNDA2NDYxNDM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast>)



第二种方法：在cmd里面输入 mysql -V 来获取mysql版本号如图

 ![](<https://img-blog.csdn.net/20180123172427642?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfNDA2NDYxNDM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast>)

注意：在命令提示符里面mysql后面少一个空格会报错。找了半个小时才发现自己少写了一个空格，在百度过程中有学到了俩个知识点。



命令提示符返回上一级 输入cd..   如图

 ![](<https://img-blog.csdn.net/20180123172845110?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfNDA2NDYxNDM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast>)

命令提示符返回c盘，输入cd\  如图

![](<https://img-blog.csdn.net/20180123172943062?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfNDA2NDYxNDM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast>)

### 167.说一下 ACID 是什么？



1. 原子性(Atomicity)：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。   

​    2. 一致性(Consistency)：在一个事务执行之前和执行之后数据库都必须处于一致性状态。如果事务成功完成，那么系统中所有变化将正确应用。如果事务出错，那么系统中的所有变化自动回滚。   

​    3. 隔离性(Isolation)：在并发环境中，当不同的事务同时操作相同的数据时，每个事务都有各自的完成数据空间。数据更新时，数据所处的状态要么是更新前的状态，要么是更新后的状态。   

​    4. 持久性(Durability)：只要事务成功结束，它对数据库所做的更新就必须永久保存下来。

### 168.char 和 varchar 的区别是什么？

数据库中char和varchar的区别为：长度不同、效率不同、存储不同。

一、长度不同

1、char类型：char类型的长度是固定的。

2、varchar类型：varchar类型的长度是可变的。

二、效率不同

1、char类型：char类型每次修改的数据长度相同，效率更高。

2、varchar类型：varchar类型每次修改的数据长度不同，效率更低。

[![img](https://iknow-pic.cdn.bcebos.com/83025aafa40f4bfb952dde2e0c4f78f0f63618ce?x-bce-process=image/resize,m_lfit,w_600,h_800,limit_1)](https://iknow-pic.cdn.bcebos.com/83025aafa40f4bfb952dde2e0c4f78f0f63618ce)

三、存储不同

1、char类型：char类型存储的时候是初始预计字符串再加上一个记录字符串长度的字节，占用空间较大。

2、varchar类型：varchar类型存储的时候是实际字符串再加上一个记录字符串长度的字节，占用空间较小。

### 169.float 和 double 的区别是什么？

\1. 范围

float和double的范围是由指数的位数来决定的。

float的指数位有8位，而double的指数位有11位，分布如下：

float：

1bit（符号位） 8bits（指数位） 23bits（尾数位）

double：

1bit（符号位） 11bits（指数位） 52bits（尾数位）

于是，float的指数范围为-127~+128，而double的指数范围为-1023~+1024，并且指数位是按补码的形式来划分的。

其中负指数决定了浮点数所能表达的绝对值最小的非零数；而正指数决定了浮点数所能表达的绝对值最大的数，也即决定了浮点数的取值范围。

float的范围为-2^128 ~ +2^128，也即-3.40E+38 ~ +3.40E+38；double的范围为-2^1024 ~ +2^1024，也即-1.79E+308 ~ +1.79E+308。

\2.  精度

float和double的精度是由尾数的位数来决定的。浮点数在内存中是按科学计数法来存储的，其整数部分始终是一个隐含着的“1”，由于它是不变的，故不能对精度造成影响。

float：2^23 = 8388608，一共七位，这意味着最多能有7位[有效数字](https://www.baidu.com/s?wd=%E6%9C%89%E6%95%88%E6%95%B0%E5%AD%97&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)，但绝对能保证的为6位，也即float的精度为6~7位[有效数字](https://www.baidu.com/s?wd=%E6%9C%89%E6%95%88%E6%95%B0%E5%AD%97&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)；

double：2^52 = 4503599627370496，一共16位，同理，double的精度为15~16位。

**扩展资料：**

单精度浮点数在机内占4个字节，用32位二进制描述。

双精度浮点数在机内占8个字节，用64位二进制描述。

浮点数在机内用指数型式表示，分解为：数符，尾数，指数符，指数四部分。

数符占1位二进制，表示数的正负。

指数符占1位二进制，表示指数的正负。

尾数表示浮点数[有效数字](https://www.baidu.com/s?wd=%E6%9C%89%E6%95%88%E6%95%B0%E5%AD%97&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)，0.xxxxxxx,但不存开头的0和点

指数存指数的有效数字。

指数占多少位，尾数占多少位，由计算机系统决定。

可能是数符加尾数占24位，指数符加指数占8位 -- float.

数符加尾数占48位，指数符加指数占16位 -- double.

### 170.mysql 的内连接、左连接、右连接有什么区别？

1.内连接,显示两个表中有联系的所有数据;

2.左链接,以左表为参照,显示所有数据,右表中没有则以null显示

3.右链接,以右表为参照显示数据，,左表中没有则以null显示

### 171.mysql 索引是怎么实现的？

在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的，本文主要讨论MyISAM和InnoDB两个存储引擎的索引实现方式。

**MyISAM索引实现**

MyISAM引擎使用B+Tree作为索引结构。

MyISAM会按照数据插入的顺序分配行号，从0开始，然后按照数据插入的顺序存储在磁盘上。因为行是定长的，所以可以从表的开头跳过相应的字节找到需要的行。

![mark](http://songwenjie.vip/blog/180812/7BikF0D2H6.png?imageslim)

MyISAM的一级索引（主键索引），一个节点包含多个内部节点，索引中的每个叶子节点包含“行号”。假设我们以col1为主键，则下图是一个MyISAM表的主索引（Primary key）示意。

![mark](http://songwenjie.vip/blog/180812/31JJAJEIk5.png?imageslim)

可以看出MyISAM的索引文件仅仅保存数据记录的**行号**，然后通过此行号回表查询需要的数据。

那col2列上的索引（辅助索引）又会怎么样呢？有什么特别之处吗?答案是否定的，和一级索引（主键索引）没有什么区别。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在col2上建立一个辅助索引，则此索引的结构如下图所示：

![mark](http://songwenjie.vip/blog/180812/b9I0C4Jg0d.png?imageslim)

因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。MyISAM的索引方式索引和数据存放是分开的，非聚集”的，所以也叫做非聚集索引。

## InnoDB索引实现

虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。因为InnoDB支持聚簇索引（主键索引），聚簇索引就是表，所以InnoDB不用像MyISAM那样需要独立的行存储。也就是说，InnoDB的数据文件本身就是索引文件。

聚簇索引的每一个叶子节点都包含了主键值、事务ID、用于事务和MVCC的回滚指针以及**所有的剩余列**。假设我们以col1为主键，则下图是一个InnoDB表的聚簇索引（主键索引）（Primary key）示意。

![mark](http://songwenjie.vip/blog/180812/Jhi2c5AfEA.png?imageslim)

与MyISAM不同的是，InnoDB的二级索引和聚簇索引很不相同。**InnoDB的二级索引的叶子节点存储的不是行号（行指针），而是主键列**。这种策略的缺点是二级索引需要两次索引查找，第一次在二级索引中查找主键，第二次在聚簇索引中通过主键查找需要的数据行。

画外音：可以通过我们前面提到过的**索引覆盖**来避免回表查询，这样就只需要一次回表查询，对于InnoDB而言，就是只需要一次索引查找就可以查询到需要的数据记录，因为需要的数据记录已经被索引到二级索引中，直接就可以找到。

好处是InnoDB在移动行时无需更新一级索引中的这个”指针“，因为主键是不会改变的，但是行指针却会改变。

InnoDB的二级索引示意如图：

![mark](http://songwenjie.vip/blog/180812/g3AjIfH058.png?imageslim)

### 使用InnoDB主键应该知道的事项

因为InnoDB的索引的方式通过主键聚集数据，严重依赖主键。索引如果没有定义主键，那么InnoDB会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB会隐式定义一个主键来作为聚簇索引。

**聚簇索引的优点有：**

1.可以把相关数据存储在一起，减少数据查询时的磁盘I/O

2.数据访问更快，因为聚簇索引就是表，索引和数据保存在一个B+Tree中

3.使用索引覆盖的查询时可以直接使用页节点中的主键值

**聚簇索引的缺点有：**

1.插入速度严重依赖插入顺序

2.更新聚簇索引列的代价很高，因为会强制InnoDB把更新的列移动到新的位置

3.基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能会导致“页分裂”。当行的主键值要求必须将这一行插入到已满的页中时，存储引擎会将该页分裂为两个页面来容纳该行，这就是一次页分裂操作，页分裂会导致表占用更多的存储空间。

画外音：关于**页**，我们在上一篇文章中也提到过。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页。存和磁盘以页为单位交换数据。**数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次磁盘I/O就可以完全载入**。

基于聚簇索引以上的这些特点，**在InnoDB中，我们应该尽量使用和应用无关的主键，例如自增主键，这样可以保证数据行是按照顺序写入的**。而不是使用GUID、UUID生成随机的主键。

**向聚簇索引中插入顺序的索引值：**

每条新纪录总是在前一条记录的后面插入：

![mark](http://songwenjie.vip/blog/180812/FEKCdaLBB1.png?imageslim)

当页被插满后，继续插入到新的页：

![mark](http://songwenjie.vip/blog/180812/54FALd4lEf.png?imageslim)

**向聚簇索引中插入随机的索引值：**

新的记录可能被插入到之前记录的中间，导致需要强制移动之前的记录：

![mark](http://songwenjie.vip/blog/180812/JEBjiIl9DF.png?imageslim)

被写满且已经刷到磁盘上的页可能会被重新读取用于再次插入，此时还需要进行页分裂：

![mark](http://songwenjie.vip/blog/180812/5FDHedLec5.png?imageslim)

**总结**

MyISAM和InnoDB两个存储引擎的索引虽然都是使用的B+Tree数据结构，但是在具体实现上还是存在不小差别的。InnoDB支持聚簇索引，聚簇索引就是表，所以InnoDB不用像MyISAM那样需要独立的行存储。也就是说，InnoDB的数据文件本身就是索引文件。而MyISAM的数据文件和索引文件是分开存储的。可以通过MyISAM和InnoDB如何存放表的抽象图帮助快速理解。

**InnoDB（聚簇）表分布：**

![mark](http://songwenjie.vip/blog/180812/CAgGhaeKJ0.png?imageslim)

**MyISAM（非聚簇）表分布：**

![mark](http://songwenjie.vip/blog/180812/k652Keea4A.png?imageslim)



### 172.怎么验证 mysql 的索引是否满足需求？

需要根据查询需求来决定配置索引的类型，一旦确定索引类型之后，可以使用 explain 查看 SQL 执行计划，确认索引是否满足需求。

我有一个 zje 表

我先用一个普通的 select语句，用explain解析，看看有什么显示：

explain select * from zje；

![](<https://img-blog.csdn.net/20170212201918965>)

主要关注的是，type 和 key：

type = ALL ：表示全表扫描

type = const ：表示通过索引一次就找到了



key = NULL：表示没有使用索引

key = primary ：表示使用了主键

key一般=使用了主键/索引的名字



下面的图是使用了索引的：

select * from zje where math<60；

![](<https://img-blog.csdn.net/20170212203634581>)

其中 key = math的 math就是索引名

### 173.说一下数据库的事务隔离？

以上介绍完事务的四大特性(简称ACID)，现在重点来说明下事务的隔离性，当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性，在介绍数据库提供的各种隔离级别之前，我们先看看如果不考虑事务的隔离性，会发生的几种问题：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190607110946513.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1emhvbmdtaW4wNQ==,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190607111249225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1emhvbmdtaW4wNQ==,size_16,color_FFFFFF,t_70)
3、幻读：一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。如果事务中都使用快照读，那么就不会产生幻读现象，但是快照读和当前读混用就会产生幻读。关于快照读与当前读可参见[《InnoDB对MVCC的实现》](https://blog.csdn.net/fuzhongmin05/article/details/91351933)。

幻读和不可重复读都是读取了另一条已经提交的事务（这点就与脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。

### 四种隔离级别

标准SQL规范中，定义了四个事务隔离级别：

- Read uncommitted (读未提交)：最低级别，以上问题均无法解决。
- Read committed (读已提交)：读已提交，可避免脏读情况发生。
- Repeatable Read（可重复读）：确保事务可以多次从一个字段中读取相同的值，在此事务持续期间，禁止其他事务对此字段的更新，可以避免脏读和不可重复读，仍会出现幻读问题。
- Serializable （串行化）：最严格的事务隔离级别，要求所有事务被串行执行，不能并发执行，可避免脏读、不可重复读、幻读情况的发生。

这四种隔离级别，分别有可能产生问题总结如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190607112139338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1emhvbmdtaW4wNQ==,size_16,color_FFFFFF,t_70)

很多人容易搞混不可重复读和幻读，确实这两者有些相似。但不可重复读重点在于update和delete，而幻读的重点在于insert。避免不可重复读需要锁行（某一行在select操作时，不允许update与delete）就行，避免幻读则需要锁表。如果使用锁机制来实现这两种隔离级别，在可重复读中，该sql第一次读取到数据后，就将这些数据加锁，其它事务无法修改这些数据，就可以实现可重复读了。但这种方法却无法锁住insert的数据，所以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，这时事务A就会发现莫名其妙多了一条之前没有的数据，幻读不能通过行锁来避免，需要Serializable隔离级别 ，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。所以说不可重复读和幻读最大的区别，就在于如何通过锁机制来解决他们产生的问题。

以上四种隔离级别最高的是Serializable级别，最低的是Read uncommitted级别，当然隔离级别越高，越能保证数据的完整性和统一性，但是执行效率就越低，对并发性能的影响也越大。像Serializable这样的级别，就是以锁表的方式（类似于Java多线程中的锁）使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。

各类流行的数据库都实现了一些SQL标准中的事务隔离级别，但是他们的实现也是极其不一样的。Oracle仅仅实现了RC 和 SERIALIZABLE隔离级别。默认采用RC隔离级别，解决了脏读。但是允许不可重复读和幻读。其SERIALIZABLE则解决了脏读、不可重复读、幻读。而MySQL默认采用RR隔离级别，SQL标准是要求RR解决不可重复读的问题，但是因为MySQL采用了间隙锁（gap lock），所以实际上MySQL的RR隔离级别也解决了幻读的问题。那么MySQL的SERIALIZABLE是怎么回事呢？MySQL的SERIALIZABLE采用了经典的实现方式，对读和写都加锁。

查看MySQL数据库当前事务的隔离级别：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select @@tx_isolation;</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190607112916662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1emhvbmdtaW4wNQ==,size_16,color_FFFFFF,t_70)
在MySQL数据库中设置事务的隔离级别：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set  [glogal | session]  transaction isolation level 隔离级别名称;</span><br><span class="line">set tx_isolation&#x3D;’隔离级别名称;’</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190607113055243.png)

### 互联网项目中MySQL用什么事务隔离级别

Mysql默认的事务隔离级别是可重复读(Repeatable Read)，那互联网项目中Mysql也是用默认隔离级别，不做修改么？ OK，不是的，我们在项目中一般用读已提交(Read Commited)这个隔离级别！ 居然是读已提交。

我们先来思考一个问题，在Oracle、SqlServer中都是选择读已提交(Read Commited)作为默认的隔离级别，为什么Mysql不选择读已提交(Read Commited)作为默认隔离级别，而选择可重复读(Repeatable Read)作为默认的隔离级别呢？

我们先明白一点！项目中是不用读未提交(Read UnCommitted)和串行化(Serializable)两个隔离级别，原因有二： 采用读未提交(Read UnCommitted)，一个事务读到另一个事务未提交读数据，这个不用多说吧，从逻辑上都说不过去！采用串行化(Serializable)，每个次读操作都会加锁，快照读失效，一般是使用Mysql自带的分布式事务功能时才使用该隔离级别！也就是说，我们该纠结都只有一个问题，究竟隔离级别是用读已经提交呢还是可重复读？ 接下来对这两种级别进行对比，讲讲我们为什么选读已提交(Read Commited)作为事务隔离级别！

### 174.说一下 mysql 常用的引擎？

在MySQL数据库中，常用的引擎主要就是2个：Innodb和MyIASM。

a.Innodb引擎，Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。它本身实际上是基于Mysql后台的完整的系统。Mysql运行的时候，Innodb会在内存中建立缓冲池，用于缓冲数据和索引。但是，该引擎是不支持全文搜索的。同时，启动也比较的慢，它是不会保存表的行数的。当进行Select count(*) from table指令的时候，需要进行扫描全表。所以当需要使用数据库的事务时，该引擎就是首选。由于锁的粒度小，写操作是不会锁定全表的。所以在并发度较高的场景下使用会提升效率的。

b.MyIASM引擎，它是MySql的默认引擎，但不提供事务的支持，也不支持行级锁和外键。因此当执行Insert插入和Update更新语句时，即执行写操作的时候需要锁定这个表。所以会导致效率会降低。不过和Innodb不同的是，MyIASM引擎是保存了表的行数，于是当进行Select count(*) from table语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的。可以将MyIASM作为数据库引擎的首先。

补充2点：

c.大容量的数据集时趋向于选择Innodb。因为它支持事务处理和故障的恢复。Innodb可以利用数据日志来进行数据的恢复。主键的查询在Innodb也是比较快的。

d.大批量的插入语句时（这里是INSERT语句）在MyIASM引擎中执行的比较的快，但是UPDATE语句在Innodb下执行的会比较的快，尤其是在并发量大的时候。

2.两种引擎所使用的索引的数据结构是什么？

答案:都是B+树!

MyIASM引擎，B+树的数据结构中存储的内容实际上是实际数据的地址值。也就是说它的索引和实际数据是分开的，只不过使用索引指向了实际数据。这种索引的模式被称为非聚集索引。

Innodb引擎的索引的数据结构也是B+树，只不过数据结构中存储的都是实际的数据，这种索引有被称为聚集索引。

### 175.说一下 mysql 的行锁和表锁？

一、表锁

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  特点：偏向MyISAM存储引擎，开销小，加锁快；无死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</span><br><span class="line"></span><br><span class="line"> 我们在编辑表，或者执行修改表的事情了语句的时候，一般都会给表加上表锁，可以避免一些不同步的事情出现，表锁分为两种，一种是读锁，一种是写锁。</span><br><span class="line"></span><br><span class="line">我们可以手动给表加上这两种锁，语句是：</span><br></pre></td></tr></table></figure>

lock table 表名 read(write); 
释放所有表的锁：

unlock tables;
查看加锁的表：

show open tables;

如图所示，in_use为1的就是加锁的表。

加读锁（共享锁）：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> 我们给表加上读锁会有什么效果呢？</span><br><span class="line"></span><br><span class="line"> 1、我们加读锁的这个进程可以读加读锁的表，但是不能读其他的表。</span><br><span class="line"></span><br><span class="line"> 2、加读锁的这个进程不能update加读锁的表。</span><br><span class="line"></span><br><span class="line">3、其他进程可以读加读锁的表（因为是共享锁），也可以读其他表</span><br><span class="line"></span><br><span class="line">4、其他进程update加读锁的表会一直处于等待锁的状态，直到锁被释放后才会update成功。</span><br></pre></td></tr></table></figure>

加写锁（独占锁）：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、加锁进程可以对加锁的表做任何操作（CURD）。</span><br><span class="line"></span><br><span class="line">2、其他进程则不能查询加锁的表，需等待锁释放</span><br></pre></td></tr></table></figure>

总结：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">读锁会阻塞写，但是不会堵塞读。而写锁则会把读和写都堵塞。（特别注意进程）</span><br></pre></td></tr></table></figure>

分析：

show status like 'table%';
输入上述命令，可得：



Table_locks_immediate：产生表级锁定的次数，表示可以立即获取锁的查询次数，每立即获取锁值加1 。
Table_locks_waited：出现表级锁定争用而发生等待的次数(不能立即获取锁的次数，每等待一次锁值加1)，此值高则说明存在着较严重的表级锁争用情况。

二、行锁

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">特点：偏向InnoDB存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</span><br></pre></td></tr></table></figure>

行锁支持事务，所以  有关事务的知识下篇博客再总结。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 行为：</span><br><span class="line"></span><br><span class="line">1、当我们对一行进行更新但是不提交的时候，其他进程也对该行进行更新则需要进行等待，这就是行锁。</span><br><span class="line"></span><br><span class="line">2、如果我们对一行进行更新，其他进程更新别的行是不会受影响的。</span><br></pre></td></tr></table></figure>

行锁升级为表锁：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当我们的行锁涉及到索引失效的时候，会触发表锁的行为。</span><br></pre></td></tr></table></figure>

Session_1    Session_2
正常情况，各自锁定各自的行，互相不影响，一个2000另一个3000     

由于在column字段b上面建了索引，如果没有正常使用，会导致行锁变表锁     
比如没加单引号导致索引失效，行锁变表锁



被阻塞，等待。只到Session_1提交后才阻塞解除，完成更新



所以，由此，我们还是要善用索引查询啊。

间隙锁：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。</span><br><span class="line"></span><br><span class="line">因为Query执行过程中通过过范围查找的话，他会锁定整个范围内所有的索引键值，即使这个键值并不存在。</span><br><span class="line"></span><br><span class="line">间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害</span><br></pre></td></tr></table></figure>

优化建议：

   尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁。
   合理设计索引，尽量缩小锁的范围
   尽可能较少检索条件，避免间隙锁
   尽量控制事务大小，减少锁定资源量和时间长度
  尽可能低级别事务隔离



### 176.说一下乐观锁和悲观锁？

何谓悲观锁与乐观锁
乐观锁对应于生活中乐观的人总是想着事情往好的方向发展，悲观锁对应于生活中悲观的人总是想着事情往坏的方向发展。这两种人各有优缺点，不能不以场景而定说一种人好于另外一种人。

悲观锁
总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。

乐观锁
总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。

两种锁的使用场景
从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。

乐观锁常见的两种实现方式
乐观锁一般会使用版本号机制或CAS算法实现。

1. 版本号机制
   一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。

举一个简单的例子：

假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。当需要对账户信息表进行更新的时候，需要首先读取version字段。

操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 $50（ $100-$50 ）。
在操作员 A 操作的过程中，操作员B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。
操作员 A 完成了修改工作，提交更新之前会先看数据库的版本和自己读取到的版本是否一致，一致的话，就会将数据版本号加1（ version=2 ），连同帐户扣除后余额（ balance=$50 ），提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。
操作员 B 完成了操作，提交更新之前会先看数据库的版本和自己读取到的版本是否一致，但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 2 ，而自己读取到的版本号为1 ，不满足 “ 当前最后更新的version与操作员第一次读取的版本号相等 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。
这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员A 的操作结果的可能。

2. CAS算法
   即compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS算法涉及到三个操作数

需要读写的内存值 V
进行比较的值 A
拟写入的新值 B
当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。

乐观锁的缺点
ABA 问题是乐观锁一个常见的问题

1 ABA 问题
如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 "ABA"问题。

JDK 1.5 以后的 AtomicStampedReference 类就提供了此种能力，其中的 compareAndSet 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。

2 循环时间长开销大
自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。

3 只能保证一个共享变量的原子操作
CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作。

CAS与synchronized的使用情景
简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多）

对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。
对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。
补充： Java并发编程这个领域中synchronized关键字一直都是元老级的角色，很久之前很多人都会称它为 “重量级锁” 。但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 偏向锁 和 轻量级锁 以及其它各种优化之后变得在某些情况下并不是那么重了。synchronized的底层实现主要依靠 Lock-Free 的队列，基本思路是 自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。



### 177.mysql 问题排查都有哪些手段？

**MySQL 问题排查都有哪些手段？**

- 使用 show processlist 命令查看当前所有连接信息。
- 使用 explain 命令查询 SQL 语句执行计划。
- 开启慢查询日志，查看慢查询的 SQL。



178.如何做 mysql 的性能优化？

**如何做 MySQL 的性能优化？**

- 为搜索字段创建索引。
- 避免使用 select *，列出需要查询的字段。
- 垂直分割分表。
- 选择正确的存储引擎。

## 十八、Redis

179.redis 是什么？都有哪些使用场景？

180.redis 有哪些功能？

181.redis 和 memecache 有什么区别？

182.redis 为什么是单线程的？

183.什么是缓存穿透？怎么解决？

184.redis 支持的数据类型有哪些？

185.redis 支持的 java 客户端都有哪些？

186.jedis 和 redisson 有哪些区别？

187.怎么保证缓存和数据库数据的一致性？

188.redis 持久化有几种方式？

189.redis 怎么实现分布式锁？

190.redis 分布式锁有什么缺陷？

191.redis 如何做内存优化？

192.redis 淘汰策略有哪些？

193.redis 常见的性能问题有哪些？该如何解决？





## 十九、JVM

### 194.说一下 jvm 的主要组成部分？及其作用？

1. Java虚拟机内存的五大区域
   Java的运行离不开Java虚拟机的支持，今天我就跟大家探讨一下Java虚拟机的一些基础知识。
   JVM内存区域分为五个部分，分别是堆，方法区，虚拟机栈，本地方法栈，程序计数器。

  ![](<https://img-blog.csdn.net/20180419222132924?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI0NDk5NjE1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70>)

1. 堆。 堆是Java对象的存储区域，任何用new字段分配的Java对象实例和数组，都被分配在堆上，Java堆可使用-Xms -Xmx进行内存控制，值得一提的是从JDK1.7版本之后，运行时常量池从方法区移到了堆上。
2. 方法区。它用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据，方法区在JDK1.7版本及以前被称为永久代，从JDK1.8永久代被移除。
3. 虚拟机栈。虚拟机栈中执行每个方法的时候，都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。
4. 本地方法栈。与虚拟机栈发挥的作用相似，相比于虚拟机栈为Java方法服务，本地方法栈为虚拟机使用的Native方法服务，执行每个本地方法的时候，都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。
5. 程序计数器。指示Java虚拟机下一条需要执行的字节码指令。
   以上五个区域是Java虚拟机内存划分情况，其中方法区和堆被JVM中多个线程共享，比如类的静态常量就被存放在方法区，供类对象之间共享，虚拟机栈，本地方法栈，pc寄存器是每个线程独立拥有的，不会与其他线程共享。
   所以Java在通过new创建一个类对象实例的时候，一方面会在虚拟机栈中创建一个该对象的引用，另一方面会在堆上创建类对象的实例，然后将对象引用指向该对象的实例。对象引用存放在每一个方法对应的栈帧中。

### 195.说一下 jvm 运行时数据区？

**线程私有的数据区**

### 程序计数器

- 作用 
  记录当前线程所执行到的字节码的行号。字节码解释器工作的时候就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。
- 意义 
  JVM的多线程是通过线程轮流切换并分配处理器来实现的，对于我们来说的并行事实上一个处理器也只会执行一条线程中的指令。所以，为了保证各线程指令的安全顺利执行，每条线程都有独立的私有的程序计数器。
- 存储内容 
  当线程中执行的是一个Java方法时，程序计数器中记录的是正在执行的线程的虚拟机字节码指令的地址。 
  当线程中执行的是一个本地方法时，程序计数器中的值为空。
- 可能出现异常 
  此内存区域是唯一一个在JVM上不会发生内存溢出异常（OutOfMemoryError）的区域。

### 虚拟机栈

- 作用 
  描述Java方法执行的内存模型。每个方法在执行的同时都会开辟一段内存区域用于存放方法运行时所需的数据，成为栈帧，一个栈帧包含如：局部变量表、操作数栈、动态链接、方法出口等信息。

- 意义 
  JVM是基于栈的，所以每个方法从调用到执行结束，就对应着一个栈帧在虚拟机栈中入栈和出栈的整个过程。

- 存储内容 
  局部变量表（编译期可知的各种基本数据类型、引用类型和指向一条字节码指令的returnAddress类型）、操作数栈、动态链接、方法出口等信息。 
  值得注意的是：局部变量表所需的内存空间在编译期间完成分配。在方法运行的阶段是不会改变局部变量表的大小的。

- 可能出现的异常

  如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。 
  如果在动态扩展内存的时候无法申请到足够的内存，就会抛出OutOfMemoryError异常。

  ### 本地方法栈

- 作用 
  为JVM所调用到的Nativa即本地方法服务。

- 可能出现的异常 
  和虚拟机栈出现的异常很相像。

**所有线程共有的数据区**

### Java堆

- 作用 
  所有线程共享一块内存区域，在虚拟机开启的时候创建。
- 意义 
  1、存储对象实例，更好地分配内存。 
  2、垃圾回收（GC）。堆是垃圾收集器管理的主要区域。更好地回收内存。 
  -存储内容 
  存放对象实例，几乎所有的对象实例都在这里进行分配。堆可以处于物理上不连续的内存空间，只要逻辑上是连续的就可以。 
  值得注意的是：在JIT编译器等技术的发展下，所有对象都在堆上进行分配已变得不那么绝对。有些对象实例也可以分配在栈中。
- 可能出现的异常 
  实现堆可以是固定大小的，也可以通过设置配置文件设置该为可扩展的。 
  如果堆上没有内存进行分配，并无法进行扩展时，将会抛出OutOfMemoryError异常。

### 方法区

- 作用 
  用于存储运行时常量池、已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
- 意义 
  对运行时常量池、常量、静态变量等数据做出了规定。
- 存储内容 
  运行时常量池（具有动态性）、已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
- 可能出现的异常 
  当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常

### 196.说一下堆栈的区别？

堆栈与堆区别为：空间不同、地址方向不同、释放不同。

一、空间不同

1、堆栈：堆栈是自动分配变量，以及函数调用的时候所使用的一些空间。

2、堆：堆是是由malloc之类函数分配的空间所在地。

二、地址方向不同

1、堆栈：堆栈的地址方向是由高向低减少性扩展，有总长度大小限制。 

2、堆：堆的地址方向是由低向高增长性扩展，没有总长度大小限制。 

[![img](https://iknow-pic.cdn.bcebos.com/8ad4b31c8701a18b9562d438912f07082838fe38?x-bce-process=image/resize,m_lfit,w_600,h_800,limit_1)](https://iknow-pic.cdn.bcebos.com/8ad4b31c8701a18b9562d438912f07082838fe38)

三、释放不同

1、堆栈：堆栈由编译器自动释放，存放函数的参数值，局部变量的值等。

2、堆：堆由程序员人工进行释放， 若程序员不释放，程序结束时可能由OS回收 

### 197.队列和栈是什么？有什么区别？

队列（Queue）：是限定只能在表的一端进行插入和另一端删除操作的线性表
栈（Stack）：是限定之能在表的一端进行插入和删除操作的线性表

队列和栈的规则
队列：先进先出
栈：先进后出
队列和栈的遍历数据速度
队列：基于地址指针进行遍历，而且可以从头部或者尾部进行遍历，但不能同时遍历，无需开辟空间，因为在遍历的过程中不影响数据结构，所以遍历速度要快
栈：只能从顶部取数据，也就是说最先进入栈底的，需要遍历整个栈才能取出来，遍历数据时需要微数据开辟临时空间，保持数据在遍历前的一致性



### 198.什么是双亲委派模型？

当需要加载一个类的时候，子类加载器并不会马上去加载，而是依次去请求父类加载器加载，一直往上请求到最高类加载器：启动类加载器。当启动类加载器加载不了的时候，依次往下让子类加载器进行加载。当达到最底下的时候，如果还是加载不到该类，就会出现ClassNotFound的情况。

好处：保证了程序的安全性。例子：比如我们重新写了一个String类，加载的时候并不会去加载到我们自己写的String类，因为当请求上到最高层的时候，启动类加载器发现自己能够加载String类，因此就不会加载到我们自己写的String类了。



### 199.说一下类加载的执行过程？

一个Java文件从编码完成到最终执行，一般主要包括两个过程

编译

运行

编译，即把我们写好的java文件，通过javac命令编译成字节码，也就是我们常说的.class文件。

运行，则是把编译声称的.class文件交给Java虚拟机(JVM)执行。

而我们所说的类加载过程即是指JVM虚拟机把.class文件中类信息加载进内存，并进行解析生成对应的class对象的过程。

举个通俗点的例子来说，JVM在执行某段代码时，遇到了class A， 然而此时内存中并没有class A的相关信息，于是JVM就会到相应的class文件中去寻找class A的类信息，并加载进内存中，这就是我们所说的类加载过程。

由此可见，JVM不是一开始就把所有的类都加载进内存中，而是只有第一次遇到某个需要运行的类时才会加载，且只加载一次。

类加载
类加载的过程主要分为三个部分：

加载

链接

初始化

而链接又可以细分为三个小部分：

验证

准备

解析



加载
简单来说，加载指的是把class字节码文件从各个来源通过类加载器装载入内存中。

这里有两个重点：

字节码来源。一般的加载来源包括从本地路径下编译生成的.class文件，从jar包中的.class文件，从远程网络，以及动态代理实时编译

类加载器。一般包括启动类加载器，扩展类加载器，应用类加载器，以及用户的自定义类加载器。

注：为什么会有自定义类加载器？

一方面是由于java代码很容易被反编译，如果需要对自己的代码加密的话，可以对编译后的代码进行加密，然后再通过实现自己的自定义类加载器进行解密，最后再加载。

另一方面也有可能从非标准的来源加载代码，比如从网络来源，那就需要自己实现一个类加载器，从指定源进行加载。

验证
主要是为了保证加载进来的字节流符合虚拟机规范，不会造成安全错误。

包括对于文件格式的验证，比如常量中是否有不被支持的常量？文件中是否有不规范的或者附加的其他信息？

对于元数据的验证，比如该类是否继承了被final修饰的类？类中的字段，方法是否与父类冲突？是否出现了不合理的重载？

对于字节码的验证，保证程序语义的合理性，比如要保证类型转换的合理性。

对于符号引用的验证，比如校验符号引用中通过全限定名是否能够找到对应的类？校验符号引用中的访问性（private，public等）是否可被当前类访问？

准备
主要是为类变量（注意，不是实例变量）分配内存，并且赋予初值。

特别需要注意，初值，不是代码中具体写的初始化的值，而是Java虚拟机根据不同变量类型的默认初始值。

比如8种基本类型的初值，默认为0；引用类型的初值则为null；常量的初值即为代码中设置的值，final static tmp = 456， 那么该阶段tmp的初值就是456

解析
将常量池内的符号引用替换为直接引用的过程。

两个重点：

符号引用。即一个字符串，但是这个字符串给出了一些能够唯一性识别一个方法，一个变量，一个类的相关信息。

直接引用。可以理解为一个内存地址，或者一个偏移量。比如类方法，类变量的直接引用是指向方法区的指针；而实例方法，实例变量的直接引用则是从实例的头指针开始算起到这个实例变量位置的偏移量

举个例子来说，现在调用方法hello()，这个方法的地址是1234567，那么hello就是符号引用，1234567就是直接引用。

在解析阶段，虚拟机会把所有的类名，方法名，字段名这些符号引用替换为具体的内存地址或偏移量，也就是直接引用。

初始化
这个阶段主要是对类变量初始化，是执行类构造器的过程。

换句话说，只对static修饰的变量或语句进行初始化。

如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。

如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。

总结
类加载过程只是一个类生命周期的一部分，在其前，有编译的过程，只有对源代码编译之后，才能获得能够被虚拟机加载的字节码文件；在其后还有具体的类使用过程，当使用完成之后，还会在方法区垃圾回收的过程中进行卸载。如果想要了解Java类整个生命周期的话，可以自行上网查阅相关资料，这里不再多做赘述。

在面试过程中类加载过程虽然是一个老生常谈的问题，但是往往从这个问题还可以衍生出很多其他重要的知识点，已经罗列在下文中，如果大家感兴趣的话，可以自行学习，小编也会在之后的文章中，对其中的一些问题进行解答和总结。



### 200.怎么判断对象是否可以被回收？

内容基本来自周志明 深入理解[Java](http://lib.csdn.net/base/java)虚拟机 第二版 第三章 。这本书还可以，不过好像也没什么其他中文的关于jvm比较好的书了

jvm要做垃圾回收时，首先要判断一个对象是否还有可能被使用。那么如何判断一个对象是否还有可能被用到？

如果我们的程序无法再引用到该对象，那么这个对象就肯定可以被回收，这个状态称为不可达。当对象不可达，该对象就可以作为回收对象被垃圾回收器回收。

那么这个可达还是不可达如何判断呢？

答案就是GC roots ，也就是根对象，如果从一个对象没有到达根对象的路径，或者说从根对象开始无法引用到该对象，该对象就是不可达的。

以下三类对象在jvm中作为GC roots，来判断一个对象是否可以被回收 
(通常来说我们只要知道虚拟机栈和静态引用就够了)

- 虚拟机栈(JVM stack)中引用的对象(准确的说是虚拟机栈中的栈帧(frames)) 
  我们知道，每个方法执行的时候，jvm都会创建一个相应的栈帧(栈帧中包括操作数栈、局部变量表、运行时常量池的引用)，栈帧中包含这在方法内部使用的所有对象的引用(当然还有其他的基本类型数据)，当方法执行完后，该栈帧会从虚拟机栈中弹出，这样一来，临时创建的对象的引用也就不存在了，或者说没有任何gc roots指向这些临时对象，这些对象在下一次GC时便会被回收掉
- 方法区中类静态属性引用的对象 
  静态属性是该类型(class)的属性，不单独属于任何实例，因此该属性自然会作为gc roots。只要这个class存在，该引用指向的对象也会一直存在。class 也是会被回收的，在面后说明
- 本地方法栈(Native Stack)引用的对象

一个class要被回收准确的说应该是卸载，必须同时满足以下三个条件

- 堆中不存在该类的任何实例
- 加载该类的classloader已经被回收
- 该类的java.lang.Class对象没有在任何地方被引用，也就是说无法通过反射再带访问该类的信息

------

这篇内容太少了，在说几句java中的四种引用类型

其实这四类引用的区别就在于GC时是否回收该对象

- - 强引用(Strong) 就是我们平时使用的方式 A a = new A();强引用的对象是不会被回收的
  - 软引用(Soft) 在jvm要内存溢出(OOM)时，会回收软引用的对象，释放更多内存
  - 弱引用(Weak) 在下次GC时，弱引用的对象是一定会被回收的
  - 虚引用(Phantom) 对对象的存在时间没有任何影响，也无法引用对象实力，唯一的作用就是在该对象被回收时收到一个系统通知
- **如何判断对象是否存活？**
- 首先说为什么要判断是否存活，当垃圾收集器在对堆进行回收前，第一就是要确定对象哪些是还在被引用的或者后面还需要被引用的，即存活，哪些是已经“死去”（即不可能再被任何途径使用）
- **1、引用计数算法**
- 在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1，引用失效时就减1.任何时刻计数器为0的对象就是不可能再被使用的。这个方法效率挺高，大部分情况下也是很不错的算法。
- **但是在JVM中会很难解决对象之间相互循环引用的问题**，就如果两个对象之间相互调用，这时候就会发生类似死锁的情况，即这个地方相互调用会使得引用计数法始终认为有对象在引用当前对象，就一直计数值大于或等于1，也就无法通知GC收集器回收它们。但是实际的情况是这两个对象后面已经不再调用，所以这个方法虽然简单高效，但不是我们的首选。**虚拟机也不是通过这个算法来判断对象是否存活的**。
- **2、可达性分析算法**
- 使用一系列的GC Roots的对象（包括：虚拟机栈中引用的对象，方法区中类静态属性引用的对象，方法区中常量引用的对象，本地方法栈中JNI引用的对象）作为起点，从节点开始向下搜索，当没有被GCRoots链接到的对象就可以回收，如下图的对象4和5就判断为可回收对象。
- ![img](https://img2018.cnblogs.com/blog/1646058/201905/1646058-20190522111429032-319436978.png)
- 
- 
- 在JDK1.2之后，Java对引用这个概念进行了扩充，也就是对象不仅仅只有引用和没有引用两个概念，而是扩展到了4个：
- 强引用：类似于“Object obj=new Object（）”只要强引用在，垃圾收集器永远不会回收掉被引用的对象。
- 软引用：是用来描述一些还有用但是并非必需的对象，对于软引用对象，在内存溢出异常之前，会把这些对象列进回收范围之中进行第二次回收。
- 弱引用，比软引用更弱一点，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集发生时无论内存是否足够，**都会只回收弱引用的对象。**
- 虚引用，最弱的引用关系，对象是否有虚引用对其生存时间是没有影响的。唯一目的就是能在这个对象被收集器回收时收到**一个系统通知**。
- 对象要想真正宣告“死亡”需要至少两次的标记过程，当对象在可达性分析时候发现没有被GC Roots链到那么对象就会进行第一次标记并且进行第一次筛选，筛选的条件就是判断该对象有没有必要执行finalize()方法，需要执行的话就会把对象放入F-Queue的对列中去执行该对象中的finalize()方法。如果finalize()方法让对象重新被GC Roots链到那么对象就重新活下来，否则就会进行第二次标记，等待垃圾回收的到来

### 201.java 中都有哪些引用类型？

**引用与对象**

每种编程语言都有自己操作内存中元素的方式，例如在 C 和 C++ 里是通过指针，而在 Java 中则是通过“引用”。
在 Java 中一切都被视为了对象，但是我们操作的标识符实际上是对象的一个引用（reference）。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建一个引用，引用可以独立存在，并不一定需要与一个对象关联</span><br><span class="line">String s;</span><br></pre></td></tr></table></figure>

通过将这个叫“引用”的标识符指向某个对象，之后便可以通过这个引用来实现操作对象了。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str &#x3D; new String(&quot;abc&quot;);</span><br><span class="line">System.out.println(str.toString());</span><br></pre></td></tr></table></figure>

在 JDK1.2 之前，Java中的定义很传统：如果 reference 类型的数据中存储的数值代表的是另外一块内存的起始地址，就称为这块内存代表着一个引用。
Java 中的垃圾回收机制在判断是否回收某个对象的时候，都需要依据“引用”这个概念。
在不同垃圾回收算法中，对引用的判断方式有所不同：

- 引用计数法：为每个对象添加一个引用计数器，每当有一个引用指向它时，计数器就加1，当引用失效时，计数器就减1，当计数器为0时，则认为该对象可以被回收（目前在Java中已经弃用这种方式了）。
- 可达性分析算法：从一个被称为 GC Roots 的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连时，则说明此对象不可用。

JDK1.2 之前，一个对象只有“已被引用”和"未被引用"两种状态，这将无法描述某些特殊情况下的对象，比如，当内存充足时需要保留，而内存紧张时才需要被抛弃的一类对象。

**四种引用类型**

所以在 JDK.1.2 之后，Java 对引用的概念进行了扩充，将引用分为了：强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4 种，这 4 种引用的强度依次减弱。

**一，强引用**

Java中默认声明的就是强引用，比如：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj &#x3D; new Object(); &#x2F;&#x2F;只要obj还指向Object对象，Object对象就不会被回收</span><br><span class="line">obj &#x3D; null;  &#x2F;&#x2F;手动置null</span><br></pre></td></tr></table></figure>

只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足时，JVM也会直接抛出OutOfMemoryError，不会去回收。如果想中断强引用与对象之间的联系，可以显示的将强引用赋值为null，这样一来，JVM就可以适时的回收对象了

**二，软引用**

软引用是用来描述一些非必需但仍有用的对象。**在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常**。这种特性常常被用来实现缓存技术，比如网页缓存，图片缓存等。
在 JDK1.2 之后，用java.lang.ref.SoftReference类来表示软引用。

下面以一个例子来进一步说明强引用和软引用的区别：
在运行下面的Java代码之前，需要先配置参数 -Xms2M -Xmx3M，将 JVM 的初始内存设为2M，最大可用内存为 3M。

首先先来测试一下强引用，在限制了 JVM 内存的前提下，下面的代码运行正常

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class TestOOM &#123;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         testStrongReference();</span><br><span class="line">    &#125;</span><br><span class="line">    private static void testStrongReference() &#123;</span><br><span class="line">        &#x2F;&#x2F; 当 new byte为 1M 时，程序运行正常</span><br><span class="line">        byte[] buff &#x3D; new byte[1024 * 1024 * 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

但是如果我们将

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byte[] buff &#x3D; new byte[1024 * 1024 * 1];</span><br></pre></td></tr></table></figure>

替换为创建一个大小为 2M 的字节数组

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byte[] buff &#x3D; new byte[1024 * 1024 * 2];</span><br></pre></td></tr></table></figure>

则内存不够使用，程序直接报错，强引用并不会被回收
![img](https://img2018.cnblogs.com/blog/662236/201809/662236-20180922194052676-1646914311.png)

接着来看一下软引用会有什么不一样，在下面的示例中连续创建了 10 个大小为 1M 的字节数组，并赋值给了软引用，然后循环遍历将这些对象打印出来。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class TestOOM &#123;</span><br><span class="line">    private static List&lt;Object&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         testSoftReference();</span><br><span class="line">    &#125;</span><br><span class="line">    private static void testSoftReference() &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            byte[] buff &#x3D; new byte[1024 * 1024];</span><br><span class="line">            SoftReference&lt;byte[]&gt; sr &#x3D; new SoftReference&lt;&gt;(buff);</span><br><span class="line">            list.add(sr);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.gc(); &#x2F;&#x2F;主动通知垃圾回收</span><br><span class="line">        </span><br><span class="line">        for(int i&#x3D;0; i &lt; list.size(); i++)&#123;</span><br><span class="line">            Object obj &#x3D; ((SoftReference) list.get(i)).get();</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

打印结果：
![img](https://img2018.cnblogs.com/blog/662236/201809/662236-20180922194016719-117632363.png)

我们发现无论循环创建多少个软引用对象，打印结果总是只有最后一个对象被保留，其他的obj全都被置空回收了。
这里就说明了在内存不足的情况下，软引用将会被自动回收。
值得注意的一点 , 即使有 byte[] buff 引用指向对象, 且 buff 是一个strong reference, 但是 SoftReference sr 指向的对象仍然被回收了，这是因为Java的编译器发现了在之后的代码中, buff 已经没有被使用了, 所以自动进行了优化。
如果我们将上面示例稍微修改一下：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private static void testSoftReference() &#123;</span><br><span class="line">    byte[] buff &#x3D; null;</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">        buff &#x3D; new byte[1024 * 1024];</span><br><span class="line">        SoftReference&lt;byte[]&gt; sr &#x3D; new SoftReference&lt;&gt;(buff);</span><br><span class="line">        list.add(sr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.gc(); &#x2F;&#x2F;主动通知垃圾回收</span><br><span class="line">    </span><br><span class="line">    for(int i&#x3D;0; i &lt; list.size(); i++)&#123;</span><br><span class="line">        Object obj &#x3D; ((SoftReference) list.get(i)).get();</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;buff: &quot; + buff.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

则 buff 会因为强引用的存在，而无法被垃圾回收，从而抛出OOM的错误。
![img](https://img2018.cnblogs.com/blog/662236/201809/662236-20180922194030314-105853688.png)

如果一个对象惟一剩下的引用是软引用，那么该对象是软可及的（softly reachable）。垃圾收集器并不像其收集弱可及的对象一样尽量地收集软可及的对象，相反，它只在真正 “需要” 内存时才收集软可及的对象。

**三，弱引用**

弱引用的引用强度比软引用要更弱一些，**无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收**。在 JDK1.2 之后，用 java.lang.ref.WeakReference 来表示弱引用。
我们以与软引用同样的方式来测试一下弱引用：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private static void testWeakReference() &#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">        byte[] buff &#x3D; new byte[1024 * 1024];</span><br><span class="line">        WeakReference&lt;byte[]&gt; sr &#x3D; new WeakReference&lt;&gt;(buff);</span><br><span class="line">        list.add(sr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.gc(); &#x2F;&#x2F;主动通知垃圾回收</span><br><span class="line">    </span><br><span class="line">    for(int i&#x3D;0; i &lt; list.size(); i++)&#123;</span><br><span class="line">        Object obj &#x3D; ((WeakReference) list.get(i)).get();</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

打印结果：
![img](https://img2018.cnblogs.com/blog/662236/201809/662236-20180922194112309-477100844.png)

可以发现所有被弱引用关联的对象都被垃圾回收了。

**四，虚引用**

虚引用是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收，在 JDK1.2 之后，用 PhantomReference 类来表示，通过查看这个类的源码，发现它只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个null，也就是说将永远无法通过虚引用来获取对象，虚引用必须要和 ReferenceQueue 引用队列一起使用。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class PhantomReference&lt;T&gt; extends Reference&lt;T&gt; &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Returns this reference object&#39;s referent.  Because the referent of a</span><br><span class="line">     * phantom reference is always inaccessible, this method always returns</span><br><span class="line">     * &lt;code&gt;null&lt;&#x2F;code&gt;.</span><br><span class="line">     *</span><br><span class="line">     * @return  &lt;code&gt;null&lt;&#x2F;code&gt;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public T get() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    public PhantomReference(T referent, ReferenceQueue&lt;? super T&gt; q) &#123;</span><br><span class="line">        super(referent, q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

那么传入它的构造方法中的 ReferenceQueue 又是如何使用的呢？

**五，引用队列（ReferenceQueue）**

引用队列可以与软引用、弱引用以及虚引用一起配合使用，当垃圾回收器准备回收一个对象时，如果发现它还有引用，那么就会在回收对象之前，把这个引用加入到与之关联的引用队列中去。程序可以通过判断引用队列中是否已经加入了引用，来判断被引用的对象是否将要被垃圾回收，这样就可以在对象被回收之前采取一些必要的措施。

与软引用、弱引用不同，虚引用必须和引用队列一起使用。

### 202.说一下 jvm 有哪些垃圾回收算法？

目前来说Java堆中的对象是分为新生代和老年代，对于新生代中的对象采用的是复制算法清理

**1、复制算法**

　　它将可用内存空间划分为一块较大的Eden空间和两块较小的From Survivor（S0）和To Survivor（S1）空间。每次使用时只使用Eden和其中一块S区。比如这次使用的是S0区。回收时将Eden和S0区中的中还存活的对象一次性复制到S1中最后再清理Eden和S0中的对象，HotSpot虚拟机默认Eden:S0:S1之间大小比例是8:1:1，这是因为新生代中对象大多数甚至98%的都是“朝生夕死”。如果S区的大小不够那么就会依赖老年代的内存进行分配担保。

![img](https://img2018.cnblogs.com/blog/1646058/201905/1646058-20190522151541178-408970712.png)

**2、对象从新生代变成老年代的判定方法**

　　每经历一次Minor GC（复制算法回收对象）就会让对象的年龄加一，当对象年龄为15时就会把新生代的对象放入老年代中。

　　如果Survivor区中的存放不下的对象就会放入老年代中：对象会优先在Eden区中分配，而后通过一次Minor GC就让对象进入Survivor区中，当Survivor区中存放不下该对象时就会将该对象放入老年代。

　　新生成的大对象也会直接放入老年代中（可以通过-XX:+PretenuerSizeThreshold设置）超过这个size的对象一生成就会放入老年代。





**3、标记—清理与标记—整理算法**

　　在老年代中因为对象存活率高，没有额外的空间对它进行分配担保，所以会采用标记—清理或标记—整理算法来进行回收对象

　　**标记—清理算法**：首先标记出所有需要回收的对象，在标记完成之后统一回收所有标记的对象

![img](https://img2018.cnblogs.com/blog/1646058/201905/1646058-20190522152046125-1934176031.png)



　　**标记—整理算法**：先标记所有可回收对象，让存活的对象向一端移动，然后直接清理掉端边界以外的内存

![img](https://img2018.cnblogs.com/blog/1646058/201905/1646058-20190522152106849-298639200.png)

　　上面的标记过程都是根据可达性分析算法中对象标记判定来实现的。

### 203.说一下 jvm 有哪些垃圾回收器？

**一、垃圾收集器概述**

![img](https://images2015.cnblogs.com/blog/35158/201612/35158-20161207103025522-848238713.jpg)

如上图所示，垃圾回收算法一共有7个，3个属于年轻代、三个属于年老代，G1属于横跨年轻代和年老代的算法。

JVM会从年轻代和年老代各选出一个算法进行组合，**连线**表示哪些算法可以组合使用



**二、各个垃圾收集器说明**

**1、Serial(年轻代）**

1. 年轻代收集器，可以和Serial Old、CMS组合使用
2. 采用复制算法
3. 使用单线程进行垃圾回收，回收时会导致Stop The World，用户进程停止
4. client模式年轻代默认算法
5. GC日志关键字：**DefNew(Default New Generation)**
6. 图示（Serial+Serial Old)
   ![img](https://images2015.cnblogs.com/blog/35158/201612/35158-20161207103026679-2009041499.jpg)

**2、ParNew****(年轻代）**

1. 新生代收集器，可以和Serial Old、CMS组合使用
2. 采用复制算法
3. 使用多线程进行垃圾回收，回收时会导致Stop The World，其它策略和Serial一样
4. server模式年轻代默认算法
5. 使用-XX:ParallelGCthreads参数来限制垃圾回收的线程数
6. GC日志关键字：**ParNew(Parallel New Generation)**
7. 图示（ParNew + Serail Old）



**3、Paralle Scavenge****(年轻代）**

1. 新生代收集器，可以和Serial Old、Parallel组合使用，不能和CMS组合使用
2. 采用复制算法
3. 使用多线程进行垃圾回收，回收时会导致Stop The World
4. 关注系统**吞吐量**
5. 1. -XX:MaxGCPauseMillis：设置大于0的毫秒数，收集器尽可能在该时间内完成垃圾回收
   2. -XX:GCTimeRatio：大于0小于100的整数，即垃圾回收时间占总时间的比率，设置越小则希望垃圾回收所占时间越小，CPU能花更多的时间进行系统操作，提高吞吐量
   3. -XX:UseAdaptiveSizePolicy：参数开关，启动后系统动态自适应调节各参数，如-Xmn、-XX：SurvivorRatio等参数，这是和ParNew收集器重要的区别
6. GC日志关键字：**PSYoungGen**



**4、Serial Old****(年老代）**

1. 年老代收集器，可以和所有的年轻代收集器组合使用(Serial收集器的年老代版本）

2. 采用 ”标记-整理“算法，会对垃圾回收导致的内存碎片进行整理

3. 使用单线程进行垃圾回收，回收时会导致Stop The World，用户进程停止

4. GC日志关键字：**Tenured**

5. 图示（Serial+Serial Old)





**5、Parallel** **Old(年老代）**

1. 年老代收集器，只能和Parallel Scavenge组合使用(Parallel Scavenge收集器的年老代版本）

2. 采用 ”标记-整理“算法，会对垃圾回收导致的内存碎片进行整理

3. 关注**吞吐量**的系统可以将Parallel Scavenge+Parallel Old组合使用

4. GC日志关键字：**ParOldGen**

5. 图示(Parallel Scavenge+Parallel Old)





**6、CMS(Concurrent Mark Sweep****年老代）**

1. 年老代收集器，可以和Serial、ParNew组合使用
2. 采用 ”标记-清除“算法，可以通过设置参数在垃圾回收时进行内存碎片的整理
   1、UserCMSCompactAtFullCollection：默认开启，FullGC时进行内存碎片整理，整理时用户进程需停止，即发生Stop The World
   2、CMSFullGCsBeforeCompaction：设置执行多少次不压缩的Full GC后，执行一个带压缩的（默认为0，表示每次进入Full GC时都进行碎片整理）
3. CMS是并发算法，表示垃圾回收和用户进行同时进行，但是不是所有阶段都同时进行，在初始标记、重新标记阶段还是需要Stop the World。CMS垃圾回收分这四个阶段
   1、初始标记（CMS Initial mark）    **Stop the World**   仅仅标记一下GC Roots能直接关联到的对象，速度快
   2、并发标记（CMS concurrent mark） 进行GC Roots Tracing，时间长，不发生用户进程停顿
   3、重新标记（CMS remark）          **Stop the World**   修正并发标记期间因用户程序继续运行导致标记变动的那一部分对象的标记记录，停顿时间较长，但远比并发标记时间短
   4、并发清除（CMS concurrent sweep） 清除的同时用户进程会导致新的垃圾，时间长，不发生用户进程停顿
4. 适合于对**响应时间要求高**的系统
5. GC日志关键字：CMS-initial-mark、CMS-concurrent-mark-start、CMS-concurrent-mark、CMS-concurrent-preclean-start、CMS-concurrent-preclean、CMS-concurrent-sweep、CMS-concurrent-reset等等
6. 缺点
   1、对CPU资源非常敏感
   2、CMS收集器无法处理浮动垃圾，即清除时用户进程同时产生的垃圾，只能等到下次GC时回收
   3、因为是使用“标记-清除”算法，所以会产生大量碎片
7. 图示





**7、G1**

1. G1收集器由于没有使用过，所以从网上找了一些教程供大家了解
2. 1. 并行与并发
   2. 分代收集
   3. 空间整合
   4. 可预测的停顿
3. <http://blog.csdn.net/renfufei/article/details/41897113>
4. <http://blog.csdn.net/woshiqjs/article/details/7290513> 





**三、各垃圾收集参数设置**

![img](https://images2015.cnblogs.com/blog/35158/201612/35158-20161207103048991-479552960.jpg)







### 204.详细介绍一下 CMS 垃圾回收器？

垃圾回收器组合
young    Tenured    JVM options
Serial    Serial    -XX:+UseSerialGC
Parallel Scavenge    Serial    -XX:+UseParallelGC -XX:-UseParallelOldGC
Parallel Scavenge    Parallel Old    -XX:+UseParallelGC -XX:+UseParallelOldGC
Parallel New或Serial    CMS    -XX:+UseParNewGC -XX:+UseConcMarkSweepGC
G1        -XX:+UseG1GC
垃圾回收器从线程运行情况分类有三种

串行回收，Serial回收器，单线程回收，全程stw；
并行回收，名称以Parallel开头的回收器，多线程回收，全程stw；
并发回收，cms与G1，多线程分阶段回收，只有某阶段会stw；
CMS垃圾回收特点
cms只会回收老年代和永久带（1.8开始为元数据区，需要设置CMSClassUnloadingEnabled），不会收集年轻带；
cms是一种预处理垃圾回收器，它不能等到old内存用尽时回收，需要在内存用尽前，完成回收操作，否则会导致并发回收失败；所以cms垃圾回收器开始执行回收操作，有一个触发阈值，默认是老年代或永久带达到92%；
3.
CMS
cms是最常用的垃圾垃圾回收器，下面分析下CMS垃圾回收器工作原理；

CMS 处理过程有七个步骤：

1. 初始标记(CMS-initial-mark) ,会导致swt；
2. 并发标记(CMS-concurrent-mark)，与用户线程同时运行；
3. 预清理（CMS-concurrent-preclean），与用户线程同时运行；
4. 可被终止的预清理（CMS-concurrent-abortable-preclean） 与用户线程同时运行；
5. 重新标记(CMS-remark) ，会导致swt；
6. 并发清除(CMS-concurrent-sweep)，与用户线程同时运行；
7. 并发重置状态等待下次CMS的触发(CMS-concurrent-reset)，与用户线程同时运行；
   cms运行流程图如下所示：

下面抓取一下gc信息，来进行详细分析，首先将jvm中加入以下运行参数：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintCommandLineFlags                  [0]</span><br><span class="line">-XX:+UseConcMarkSweepGC                     [1]   </span><br><span class="line">-XX:+UseCMSInitiatingOccupancyOnly          [2]</span><br><span class="line">-XX:CMSInitiatingOccupancyFraction&#x3D;80       [3]</span><br><span class="line">-XX:+CMSClassUnloadingEnabled               [4]</span><br><span class="line">-XX:+UseParNewGC                            [5]</span><br><span class="line">-XX:+CMSParallelRemarkEnabled               [6]</span><br><span class="line">-XX:+CMSScavengeBeforeRemark                [7]</span><br><span class="line">-XX:+UseCMSCompactAtFullCollection          [8]</span><br><span class="line">-XX:CMSFullGCsBeforeCompaction&#x3D;0            [9]</span><br><span class="line">-XX:+CMSConcurrentMTEnabled                 [10]</span><br><span class="line">-XX:ConcGCThreads&#x3D;4                         [11] </span><br><span class="line">-XX:+ExplicitGCInvokesConcurrent            [12]</span><br><span class="line">-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses    [13]</span><br><span class="line">-XX:+CMSParallelInitialMarkEnabled          [14]</span><br><span class="line"></span><br><span class="line">-XX:+PrintGCDetails                         [15]</span><br><span class="line">-XX:+PrintGCCause                           [16]</span><br><span class="line">-XX:+PrintGCTimeStamps                      [17]</span><br><span class="line">-XX:+PrintGCDateStamps                      [18]</span><br><span class="line">-Xloggc:..&#x2F;logs&#x2F;gc.log                      [19]</span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError             [20]</span><br><span class="line">-XX:HeapDumpPath&#x3D;..&#x2F;dump                    [21]</span><br></pre></td></tr></table></figure>

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
先来介绍下下面几个参数的作用：

0. [0]打印出启动参数行
1. [1]参数指定使用CMS垃圾回收器；
2. [2]、[3]参数指定CMS垃圾回收器在老年代达到80%的时候开始工作，如果不指定那么默认的值为92%；
3. [4]开启永久带（jdk1.8以下版本）或元数据区（jdk1.8及其以上版本）收集，如果没有设置这个标志，一旦永久代或元数据区耗尽空间也会尝试进行垃圾回收，但是收集不会是并行的，而再一次进行Full GC；
4. [5] 使用cms时默认这个参数就是打开的，不需要配置，cms只回收老年代，年轻带只能配合Parallel New或Serial回收器；
5. [6] 减少Remark阶段暂停的时间，启用并行Remark，如果Remark阶段暂停时间长，可以启用这个参数
6. [7] 如果Remark阶段暂停时间太长，可以启用这个参数，在Remark执行之前，先做一次ygc。因为这个阶段，年轻带也是cms的gcroot，cms会扫描年轻带指向老年代对象的引用，如果年轻带有大量引用需要被扫描，会让Remark阶段耗时增加；
7. [8]、[9]两个参数是针对cms垃圾回收器碎片做优化的，CMS是不会移动内存的， 运行时间长了，会产生很多内存碎片， 导致没有一段连续区域可以存放大对象，出现”promotion failed”、”concurrent mode failure”, 导致fullgc，启用UseCMSCompactAtFullCollection 在FULL GC的时候， 对年老代的内存进行压缩。-XX:CMSFullGCsBeforeCompaction=0 则是代表多少次FGC后对老年代做压缩操作，默认值为0，代表每次都压缩, 把对象移动到内存的最左边，可能会影响性能,但是可以消除碎片；
   106.641: [GC 106.641: [ParNew (promotion failed): 14784K->14784K(14784K), 0.0370328 secs]106.678: [CMS106.715: [CMS-concurrent-mark: 0.065/0.103 secs] [Times: user=0.17 sys=0.00, real=0.11 secs]
   (concurrent mode failure): 41568K->27787K(49152K), 0.2128504 secs] 52402K->27787K(63936K), [CMS Perm : 2086K->2086K(12288K)], 0.2499776 secs] [Times: user=0.28 sys=0.00, real=0.25 secs]
8. [11]定义并发CMS过程运行时的线程数。比如value=4意味着CMS周期的所有阶段都以4个线程来执行。尽管更多的线程会加快并发CMS过程，但其也会带来额外的同步开销。因此，对于特定的应用程序，应该通过测试来判断增加CMS线程数是否真的能够带来性能的提升。如果未设置这个参数，JVM会根据并行收集器中的-XX:ParallelGCThreads参数的值来计算出默认的并行CMS线程数：
   ParallelGCThreads = (ncpus <=8 ? ncpus : 8+(ncpus-8)*5/8) ，ncpus为cpu个数，
   ConcGCThreads =(ParallelGCThreads + 3)/4
   这个参数一般不要自己设置，使用默认就好，除非发现默认的参数有调整的必要；
9. [12]、[13]开启foreground CMS GC，CMS gc 有两种模式，background和foreground，正常的cms gc使用background模式，就是我们平时说的cms gc；当并发收集失败或者调用了System.gc()的时候，就会导致一次full gc，这个fullgc是不是cms回收，而是Serial单线程回收器，加入了参数[12]后，执行full gc的时候，就变成了CMS foreground gc，它是并行full gc，只会执行cms中stop the world阶段的操作，效率比单线程Serial full GC要高；需要注意的是它只会回收old，因为cms收集器是老年代收集器；而正常的Serial收集是包含整个堆的，加入了参数[13],代表永久带也会被cms收集；
10. [14] 开启初始标记过程中的并行化，进一步提升初始化标记效率;
11. [15]、[16]、[17]、[18] 、[19]是打印gc日志，其中[16]在jdk1.8之后无需设置
12. [20]、[21]则是内存溢出时dump堆

下面就是该参数设置打印出来的gc信息，一些非关键的信息已经去掉，如时间：

//第一步 初始标记 这一步会停顿
[GC (CMS Initial Mark) [1 CMS-initial-mark: 299570K(307200K)] 323315K(491520K), 0.0026208 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
         vmop                    [threads: total initially_running wait_to_block]    [time: spin block sync cleanup vmop] page_trap_count
0.345: CMS_Initial_Mark                 [      10          0              1    ]      [     0     0     0     0     2    ]  0   
Total time for which application threads were stopped: 0.0028494 seconds

//第二步 并发标记
[CMS-concurrent-mark-start]
[CMS-concurrent-mark: 0.012/0.012 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 

//第三步 预清理
[CMS-concurrent-preclean-start]
[CMS-concurrent-preclean: 0.001/0.001 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 

//第四步 可被终止的预清理
[CMS-concurrent-abortable-preclean-start]
[CMS-concurrent-abortable-preclean: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 

//第五步 重新标记
[GC (CMS Final Remark) [YG occupancy: 72704 K (184320 K)][Rescan (parallel) , 0.0009069 secs][weak refs processing, 0.0000083 secs][class unloading, 0.0002626 secs][scrub symbol table, 0.0003789 secs][scrub string table, 0.0001326 secs][1 CMS-remark: 299570K(307200K)] 372275K(491520K), 0.0017842 secs] [Times: user=0.05 sys=0.00, real=0.00 secs] 
         vmop                    [threads: total initially_running wait_to_block]    [time: spin block sync cleanup vmop] page_trap_count
0.360: CMS_Final_Remark                 [      10          0              1    ]      [     0     0     0     0     1    ]  0   
Total time for which application threads were stopped: 0.0018800 seconds
//第六步 清理
[CMS-concurrent-sweep-start]
[CMS-concurrent-sweep: 0.007/0.007 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 

//第七步 重置
[CMS-concurrent-reset-start]
[CMS-concurrent-reset: 0.002/0.002 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
初始标记
这是CMS中两次stop-the-world事件中的一次。这一步的作用是标记存活的对象，有两部分：

1. 标记老年代中所有的GC Roots对象，如下图节点1；
2. 标记年轻代中活着的对象引用到的老年代的对象（指的是年轻带中还存活的引用类型对象，引用指向老年代中的对象）如下图节点2、3；



在Java语言里，可作为GC Roots对象的包括如下几种：

1. 虚拟机栈(栈桢中的本地变量表)中的引用的对象 ；
2. 方法区中的类静态属性引用的对象 ；
3. 方法区中的常量引用的对象 ；
4. 本地方法栈中JNI的引用的对象；
   ps：为了加快此阶段处理速度，减少停顿时间，可以开启初始标记并行化，-XX:+CMSParallelInitialMarkEnabled，同时调大并行标记的线程数，线程数不要超过cpu的核数；

并发标记
从“初始标记”阶段标记的对象开始找出所有存活的对象;

因为是并发运行的，在运行期间会发生新生代的对象晋升到老年代、或者是直接在老年代分配对象、或者更新老年代对象的引用关系等等，对于这些对象，都是需要进行重新标记的，否则有些对象就会被遗漏，发生漏标的情况。为了提高重新标记的效率，该阶段会把上述对象所在的Card标识为Dirty，后续只需扫描这些Dirty Card的对象，避免扫描整个老年代；
并发标记阶段只负责将引用发生改变的Card标记为Dirty状态，不负责处理；

如下图所示，也就是节点1、2、3，最终找到了节点4和5。并发标记的特点是和应用程序线程同时运行。并不是老年代的所有存活对象都会被标记，因为标记的同时应用程序会改变一些对象的引用等。



这个阶段因为是并发的容易导致concurrent mode failure

预清理阶段
前一个阶段已经说明，不能标记出老年代全部的存活对象，是因为标记的同时应用程序会改变一些对象引用，这个阶段就是用来处理前一个阶段因为引用关系改变导致没有标记到的存活对象的，它会扫描所有标记为Direty的Card
如下图所示，在并发清理阶段，节点3的引用指向了6；则会把节点3的card标记为Dirty；

最后将6标记为存活,如下图所示：



可终止的预处理
这个阶段尝试着去承担下一个阶段Final Remark阶段足够多的工作。这个阶段持续的时间依赖好多的因素，由于这个阶段是重复的做相同的事情直到发生aboart的条件（比如：重复的次数、多少量的工作、持续的时间等等）之一才会停止。
ps:此阶段最大持续时间为5秒，之所以可以持续5秒，另外一个原因也是为了期待这5秒内能够发生一次ygc，清理年轻带的引用，是的下个阶段的重新标记阶段，扫描年轻带指向老年代的引用的时间减少；

重新标记
这个阶段会导致第二次stop the word，该阶段的任务是完成标记整个年老代的所有的存活对象。
这个阶段，重新标记的内存范围是整个堆，包含_young_gen和_old_gen。为什么要扫描新生代呢，因为对于老年代中的对象，如果被新生代中的对象引用，那么就会被视为存活对象，即使新生代的对象已经不可达了，也会使用这些不可达的对象当做cms的“gc root”，来扫描老年代； 因此对于老年代来说，引用了老年代中对象的新生代的对象，也会被老年代视作“GC ROOTS”:当此阶段耗时较长的时候，可以加入参数-XX:+CMSScavengeBeforeRemark，在重新标记之前，先执行一次ygc，回收掉年轻带的对象无用的对象，并将对象放入幸存带或晋升到老年代，这样再进行年轻带扫描时，只需要扫描幸存区的对象即可，一般幸存带非常小，这大大减少了扫描时间
由于之前的预处理阶段是与用户线程并发执行的，这时候可能年轻带的对象对老年代的引用已经发生了很多改变，这个时候，remark阶段要花很多时间处理这些改变，会导致很长stop the word，所以通常CMS尽量运行Final Remark阶段在年轻代是足够干净的时候。

另外，还可以开启并行收集：-XX:+CMSParallelRemarkEnabled

并发清理
通过以上5个阶段的标记，老年代所有存活的对象已经被标记并且现在要通过Garbage Collector采用清扫的方式回收那些不能用的对象了。
这个阶段主要是清除那些没有标记的对象并且回收空间；

由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为“浮动垃圾”。

并发重置
这个阶段并发执行，重新设置CMS算法内部的数据结构，准备下一个CMS生命周期的使用。

CMS需要注意的问题
CMS不是full GC
有一点需要注意的是：CMS并发GC不是“full GC”。HotSpot VM里对concurrent collection和full collection有明确的区分。所有带有“FullCollection”字样的VM参数都是跟真正的full GC相关，而跟CMS并发GC无关的，cms收集算法只是清理老年代。

减少remark阶段停顿
一般CMS的GC耗时 80%都在remark阶段，如果发现remark阶段停顿时间很长，可以尝试添加该参数：

-XX:+CMSScavengeBeforeRemark
1
在执行remark操作之前先做一次ygc，目的在于减少ygen对oldgen的无效引用，降低remark时的开销，如果添加该参数后 ”ygc停顿时间+remark时间<添加该参数之前的remark时间“,说明该参数是有效的；

内存碎片
CMS是基于标记-清除算法的，只会将标记为为存活的对象删除，并不会移动对象整理内存空间，会造成内存碎片，这时候我们需要用到这个参数;

-XX:CMSFullGCsBeforeCompaction=n
1
这个参数大部分人的使用方式都是错误的，往往会导致设置后问题更大。
CMSFullGCsBeforeCompaction这个参数在HotSpot VM里是这样声明的：

product(bool, UseCMSCompactAtFullCollection, true,                     \
        "Use mark sweep compact at full collections")                  \
                                                                       \
product(uintx, CMSFullGCsBeforeCompaction, 0,                          \
        "Number of CMS full collection done before compaction if > 0") \
1
2
3
4
5
然后这样使用的：

  *should_compact =
    UseCMSCompactAtFullCollection &&
    ((_full_gcs_since_conc_gc >= CMSFullGCsBeforeCompaction) ||
     GCCause::is_user_requested_gc(gch->gc_cause()) ||
     gch->incremental_collection_will_fail(true /* consult_young */));
1
2
3
4
5
CMS GC要决定是否在full GC时做压缩，会依赖几个条件。其中，

1. UseCMSCompactAtFullCollection 与 CMSFullGCsBeforeCompaction 是搭配使用的；前者目前默认就是true了，也就是关键在后者上。
2. 用户调用了System.gc()，而且DisableExplicitGC没有开启。
3. young gen报告接下来如果做增量收集会失败；简单来说也就是young gen预计old gen没有足够空间来容纳下次young GC晋升的对象。
   上述三种条件的任意一种成立都会让CMS决定这次做full GC时要做压缩。

CMSFullGCsBeforeCompaction 说的是，在上一次CMS并发GC执行过后，到底还要再执行多少次full GC才会做压缩。默认是0，也就是在默认配置下每次CMS GC顶不住了而要转入full GC的时候都会做压缩。 如果把CMSFullGCsBeforeCompaction配置为10，就会让上面说的第一个条件变成每隔10次真正的full GC才做一次压缩（而不是每10次CMS并发GC就做一次压缩，目前VM里没有这样的参数）。这会使full GC更少做压缩，也就更容易使CMS的old gen受碎片化问题的困扰。 本来这个参数就是用来配置降低full GC压缩的频率，以期减少某些full GC的暂停时间。CMS回退到full GC时用的算法是mark-sweep-compact，但compaction是可选的，不做的话碎片化会严重些但这次full GC的暂停时间会短些；这是个取舍。

concurrent mode failure
这个异常发生在cms正在回收的时候。执行CMS GC的过程中，同时业务线程也在运行，当年轻带空间满了，执行ygc时，需要将存活的对象放入到老年代，而此时老年代空间不足，这时CMS还没有机会回收老年带产生的，或者在做Minor GC的时候，新生代救助空间放不下，需要放入老年代，而老年代也放不下而产生的。
设置cms触发时机有两个参数：

-XX:+UseCMSInitiatingOccupancyOnly
-XX:CMSInitiatingOccupancyFraction=70 
1
2
-XX:CMSInitiatingOccupancyFraction=70 是指设定CMS在对内存占用率达到70%的时候开始GC。

-XX:+UseCMSInitiatingOccupancyOnly如果不指定, 只是用设定的回收阈值CMSInitiatingOccupancyFraction,则JVM仅在第一次使用设定值,后续则自动调整会导致上面的那个参数不起作用。

为什么要有这两个参数？
由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。

CMS前五个阶段都是标记存活对象的，除了”初始标记”和”重新标记”阶段会stop the word ，其它三个阶段都是与用户线程一起跑的，就会出现这样的情况gc线程正在标记存活对象，用户线程同时向老年代提升新的对象，清理工作还没有开始，old gen已经没有空间容纳更多对象了，这时候就会导致concurrent mode failure， 然后就会使用串行收集器回收老年代的垃圾，导致停顿的时间非常长。

CMSInitiatingOccupancyFraction参数要设置一个合理的值，设置大了，会增加concurrent mode failure发生的频率，设置的小了，又会增加CMS频率，所以要根据应用的运行情况来选取一个合理的值。

如果发现这两个参数设置大了会导致fullgc，设置小了会导致频繁的cmsgc，说明你的老年代空间过小，应该增加老年代空间的大小了；

promotion failed
这个异常发生在年轻带回收的时候；
在进行Minor GC时，Survivor Space放不下，对象只能放入老年代，而此时老年代也放不下造成的，多数是由于老年带有足够的空闲空间，但是由于碎片较多，新生代要转移到老年带的对象比较大,找不到一段连续区域存放这个对象导致的，以下是一段promotion failed的日志：
106.641: [GC 106.641: [ParNew (promotion failed): 14784K->14784K(14784K), 0.0370328 secs]106.678: [CMS106.715: [CMS-concurrent-mark: 0.065/0.103 secs] [Times: user=0.17 sys=0.00, real=0.11 secs]
(concurrent mode failure): 41568K->27787K(49152K), 0.2128504 secs] 52402K->27787K(63936K), [CMS Perm : 2086K->2086K(12288K)], 0.2499776 secs] [Times: user=0.28 sys=0.00, real=0.25 secs]

过早提升与提升失败
在 Minor GC 过程中，Survivor Unused 可能不足以容纳 Eden 和另一个 Survivor 中的存活对象， 那么多余的将被移到老年代， 称为过早提升（Premature Promotion）,这会导致老年代中短期存活对象的增长， 可能会引发严重的性能问题。 再进一步， 如果老年代满了， Minor GC 后会进行 Full GC， 这将导致遍历整个堆， 称为提升失败（Promotion Failure）。
早提升的原因

1. Survivor空间太小，容纳不下全部的运行时短生命周期的对象，如果是这个原因，可以尝试将Survivor调大，否则端生命周期的对象提升过快，导致老年代很快就被占满，从而引起频繁的full gc；
2. 对象太大，Survivor和Eden没有足够大的空间来存放这些大象；
   提升失败原因
   当提升的时候，发现老年代也没有足够的连续空间来容纳该对象。
   为什么是没有足够的连续空间而不是空闲空间呢？
   老年代容纳不下提升的对象有两种情况：
3. 老年代空闲空间不够用了；
4. 老年代虽然空闲空间很多，但是碎片太多，没有连续的空闲空间存放该对象；
   解决方法
5. 如果是因为内存碎片导致的大对象提升失败，cms需要进行空间整理压缩；
6. 如果是因为提升过快导致的，说明Survivor 空闲空间不足，那么可以尝试调大 Survivor；
7. 如果是因为老年代空间不够导致的，尝试将CMS触发的阈值调低；

其它导致回收停顿时间变长原因
linux使用了swap，内存换入换出（vmstat），尤其是开启了大内存页的时候，因为swap只支持4k的内存页，大内存页的大小为2M，大内存页在swap的交换的时候需要先将swap中4k内存页合并成一个大内存页再放入内存或将大内存页切分为4k的内存页放入swap，合并和切分的操作会导致操作系统占用cup飙高，用户cpu占用反而很低；
除了swap交换外，网络io（netstat）、磁盘I/O （iostat）在 GC 过程中发生会使 GC 时间变长。
如果是以上原因，就要去查看gc日志中的Times耗时：
[Times: user=0.00 sys=0.00, real=0.00 secs] 
1
user是用户线程占用的时间，sys是系统线程占用的时间，如果是io导致的问题，会有两种情况

1. user与sys时间都非常小，但是real却很长，如下：

[ Times: user=0.51 sys=0.10, real=5.00 secs ] 
1
user+sys的时间远远小于real的值，这种情况说明停顿的时间并不是消耗在cup执行上了，不是cup肯定就是io导致的了，所以这时候要去检查系统的io情况。

sys时间很长，user时间很短，real几乎等于sys的时间，如下：
[ Times: user=0.11 sys=31.10, real=33.12 secs ] 
1
这时候其中一种原因是开启了大内存页，还开启了swap，大内存进行swap交换时会有这种现象；

增加线程数
CMS默认启动的回收线程数目是 (ParallelGCThreads + 3)/4) ，这里的ParallelGCThreads是年轻代的并行收集线程数，感觉有点怪怪的；
年轻代的并行收集线程数默认是(ncpus <= 8) ? ncpus : 3 + ((ncpus * 5) / 8)，可以通过-XX:ParallelGCThreads= N 来调整；
如果要直接设定CMS回收线程数，可以通过-XX:ParallelCMSThreads=n，注意这个n不能超过cpu线程数，需要注意的是增加gc线程数，就会和应用争抢资源；

参考
https://plumbr.eu/handbook/garbage-collection-algorithms-implementations#concurrent-mark-and-sweep

http://www.infoq.com/cn/presentations/a-long-period-of-atypical-jvm-gc-caused-by-os/

GC Cause
Heap Inspection Initiated GC
因为执行了jmap -histo:live 触发的gc



205.新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？

**新生代和老年代**

对象在被实例化之后，都是属于新生代。

大部分新生代的生命周期都是及其短暂的，例如在一个方法中创建的对象会随着方法执行完毕，栈空间的栈帧出栈后而失去引用。

而有一些对象确实会长期存活在堆内存的，比如被Static引用的对象。这种对象不会轻易的被垃圾回收器回收。

所以JVM会将堆内存分为两个区域，一个年轻代，一个老年代。

其中年轻代，顾名思义，就是创建和使用完之后立马就要被回收的对象放在里面。然后老年带呢，就是把一些会长期存活的对象放在里面。

**为什么要分成新生代和老年代**

很多人都会有一个疑问，为什么要划分两个区域呢？

因为这个垃圾回收有关，对于年轻代的对象，他们的特点是很快就会被回收，所以需要使用一种垃圾回收算法。

而对于老年代而言，里面的大部分对象可能都会长期存活，那么使用新生代的回收算法放在这里就可能并不是那么的合适。需要有着自己的一套回收算法。

**什么是永久代**

很简单，JVM里的永久代其实就是我们之前说的方法区

所谓的永久代，你可以认为是存放一些类的信息，在上一个章节我们知道我们生成的.class就是存放在这个区域的。一般情况下，我们对于jvm调优都是对新生代和老年代进行调优。一般而言永久代保持默认配置就可以了。

是不是意味着我们就不需要关注永久代？

肯定不是的。因为要存储类的相关信息，所以对于动态生成类的情况比较容易出现永久代的内存溢出。最典型的场景就是，在 jsp 页面比较多的情况，容易出现永久代内存溢出。

**如何判断一个对象是否是垃圾**

我们知道，当一个对象被创建出来的时候，比如说在一个方法中创建一个对象，当该方法执行完毕后，就没有引用指向这个对象了，这个对象就会变成垃圾对象。

这仅仅是一种情况。

到低哪些对象是辣鸡，哪些对象不是？

JVM中使用了一种可达性分析算法来判定哪些对象是可以被回收的。这个算法的核心就是看这个对象有谁在引用它，然后一层一层的往上判断，看是否被GC roots所引用。

在java中，可作为GC Roots的对象有：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.虚拟机栈（栈帧中的本地变量表）中引用的对象(也就是我们前面提到在方法中创建的对象)；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.方法区中的类静态属性引用的对象；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3.方法区中常量引用的对象；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4.本地方法栈中JNI（即一般说的Native方法）中引用的对象</span><br></pre></td></tr></table></figure>

当一个对象没有被上述所引用，那么这个对象就可以被认为是垃圾对象了。

总之记住一句话，只要你的对象被方法的具备变量，类的静态变量给引用了，就不会回收他

### 206.简述分代垃圾回收器是怎么工作的？

三、分代垃圾收集器

1、串行收集器（Serial）

　　Serial收集器是Hotspot运行在Client模式下的默认新生代收集器, 它的特点是：只用一个CPU（计算核心）/一条收集线程去完成GC工作, 且在进行垃圾收集时必须暂停其他所有的工作线程(“Stop The World” -后面简称STW)。可以使用-XX:+UseSerialGC打开。 虽然是单线程收集, 但它却简单而高效, 在VM管理内存不大的情况下(收集几十M~一两百M的新生代), 停顿时间完全可以控制在几十毫秒~一百多毫秒内。

![img](https://img2018.cnblogs.com/blog/955092/201903/955092-20190313173508988-2006561996.jpg)

2、并行收集器（ParNew）

　　ParNew收集器其实是前面Serial的多线程版本, 除使用多条线程进行GC外, 包括Serial可用的所有控制参数、收集算法、STW、对象分配规则、回收策略等都与Serial完全一样(也是VM启用CMS收集器-XX: +UseConcMarkSweepGC的默认新生代收集器)。

　　由于存在线程切换的开销, ParNew在单CPU的环境中比不上Serial, 且在通过超线程技术实现的两个CPU的环境中也不能100%保证能超越Serial. 但随着可用的CPU数量的增加, 收集效率肯定也会大大增加(ParNew收集线程数与CPU的数量相同, 因此在CPU数量过大的环境中, 可用-XX:ParallelGCThreads=<N>参数控制GC线程数)。

![img](https://img2018.cnblogs.com/blog/955092/201903/955092-20190313173645759-691927430.jpg)

3、Parallel Scavenge收集器

　　与ParNew类似, Parallel Scavenge也是使用复制算法, 也是并行多线程收集器. 但与其他收集器关注尽可能缩短垃圾收集时间不同, Parallel Scavenge更关注系统吞吐量:
　　系统吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)。
　　停顿时间越短就越适用于用户交互的程序-良好的响应速度能提升用户的体验;而高吞吐量则适用于后台运算而不需要太多交互的任务-可以最高效率地利用CPU时间,尽快地完成程序的运算任务. Parallel Scavenge提供了如下参数设置系统吞吐量:

| *Parallel Scavenge*参数     | 描述                                                         |
| --------------------------- | ------------------------------------------------------------ |
| *-XX:MaxGCPauseMillis*      | *(*毫秒数*)* 收集器将尽力保证内存回收花费的时间不超过设定值*,* 但如果太小将会导致*GC*的频率增加*.* |
| *-XX:GCTimeRatio*           | *(*整数*:0 < GCTimeRatio < 100)* 是垃圾收集时间占总时间的比率 |
| *XX:+UseAdaptiveSizePolicy* | 启用*GC*自适应的调节策略*:* 不再需要手工指定*-Xmn*、*-XX:SurvivorRatio*、*-XX:PretenureSizeThreshold*等细节参数*, VM*会根据当前系统的运行情况收集性能监控信息*,* 动态调整这些参数以提供最合适的停顿时间或最大的吞吐量 |

4、Serial Old收集器

　　Serial Old是Serial收集器的老年代版本, 同样是单线程收集器,使用“标记-整理”算法。

![img](https://img2018.cnblogs.com/blog/955092/201903/955092-20190313174332119-652531449.jpg)

5、Parallel Old收集器

　　Parallel Old是Parallel Scavenge收集器的老年代版本, 使用多线程和“标记－整理”算法, 吞吐量优先, 主要与Parallel Scavenge配合在注重吞吐量及CPU资源敏感系统内使用；

![img](https://img2018.cnblogs.com/blog/955092/201903/955092-20190313174422454-1338540388.jpg)

6、CMS收集器（Concurrent Mark Sweep）

　　CMS(Concurrent Mark Sweep)收集器是一款具有划时代意义的收集器, 一款真正意义上的并发收集器, 虽然现在已经有了理论意义上表现更好的G1收集器, 但现在主流互联网企业线上选用的仍是CMS(如Taobao、微店).
　　CMS是一种以获取最短回收停顿时间为目标的收集器(CMS又称多并发低暂停的收集器), 基于”标记-清除”算法实现, 整个GC过程分为以下4个步骤:

1. 初始标记(CMS initial mark)
2. 并发标记(CMS concurrent mark: GC Roots Tracing过程)
3. 重新标记(CMS remark)
4. 并发清除(CMS concurrent sweep: 已死对象将会就地释放, 注意:此处没有压缩)
   其中1，3两个步骤(初始标记、重新标记)仍需STW. 但初始标记仅只标记一下GC Roots能直接关联到的对象, 速度很快; 而重新标记则是为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录, 虽然一般比初始标记阶段稍长, 但要远小于并发标记时间.

![img](https://img2018.cnblogs.com/blog/955092/201903/955092-20190313174511354-1133294306.jpg)

CMS特点：

1. CMS默认启动的回收线程数=(CPU数目+3)/4,当CPU数>4时, GC线程一般占用不超过25%的CPU资源, 但是当CPU数<=4时, GC线程可能就会过多的占用用户CPU资源, 从而导致应用程序变慢, 总吞吐量降低.
   2.无法处理浮动垃圾, 可能出现Promotion Failure、Concurrent Mode Failure而导致另一次Full GC的产生: 浮动垃圾是指在CMS并发清理阶段用户线程运行而产生的新垃圾. 由于在GC阶段用户线程还需运行, 因此还需要预留足够的内存空间给用户线程使用, 导致CMS不能像其他收集器那样等到老年代几乎填满了再进行收集. 因此CMS提供了-XX:CMSInitiatingOccupancyFraction参数来设置GC的触发百分比(以及-XX:+UseCMSInitiatingOccupancyOnly来启用该触发百分比), 当老年代的使用空间超过该比例后CMS就会被触发(JDK 1.6之后默认92%). 但当CMS运行期间预留的内存无法满足程序需要, 就会出现上述Promotion Failure等失败, 这时VM将启动后备预案: 临时启用Serial Old收集器来重新执行Full GC(CMS通常配合大内存使用, 一旦大内存转入串行的Serial GC, 那停顿的时间就是大家都不愿看到的了).
   　　3.最后, 由于CMS采用”标记-清除”算法实现, 可能会产生大量内存碎片. 内存碎片过多可能会导致无法分配大对象而提前触发Full GC. 因此CMS提供了-XX:+UseCMSCompactAtFullCollection开关参数, 用于在Full GC后再执行一个碎片整理过程. 但内存整理是无法并发的, 内存碎片问题虽然没有了, 但停顿时间也因此变长了, 因此CMS还提供了另外一个参数-XX:CMSFullGCsBeforeCompaction用于设置在执行N次不进行内存整理的Full GC后, 跟着来一次带整理的(默认为0: 每次进入Full GC时都进行碎片整理).

7、分区收集- G1收集器

　　G1(Garbage-First)是一款面向服务端应用的收集器, 主要目标用于配备多颗CPU的服务器治理大内存.

- G1 is planned as the long term replacement for the Concurrent Mark-Sweep Collector (CMS).
  -XX:+UseG1GC启用G1收集器.
  　　与其他基于分代的收集器不同, G1将整个Java堆划分为多个大小相等的独立区域(Region), 虽然还保留有新生代和老年代的概念, 但新生代和老年代不再是物理隔离的了, 它们都是一部分Region(不需要连续)的集合.如：
  ![img](https://img2018.cnblogs.com/blog/955092/201903/955092-20190313174924710-1450508244.jpg)

　　每块区域既有可能属于O区、也有可能是Y区, 因此不需要一次就对整个老年代/新生代回收. 而是当线程并发寻找可回收的对象时, 有些区块包含可回收的对象要比其他区块多很多. 虽然在清理这些区块时G1仍然需要暂停应用线程, 但可以用相对较少的时间优先回收垃圾较多的Region. 这种方式保证了G1可以在有限的时间内获取尽可能高的收集效率.
　　G1的新生代收集跟ParNew类似: 存活的对象被转移到一个/多个Survivor Regions. 如果存活时间达到阀值, 这部分对象就会被提升到老年代.如图：

![img](https://img2018.cnblogs.com/blog/955092/201903/955092-20190313175001664-1159823407.jpg)

![img](https://img2018.cnblogs.com/blog/955092/201903/955092-20190313175020269-2035553323.jpg)

其特定是：
　　一整块堆内存被分为多个Regions.存活对象被拷贝到新的Survivor区或老年代.年轻代内存由一组不连续的heap区组成, 这种方法使得可以动态调整各代区域尺寸.Young GC会有STW事件, 进行时所有应用程序线程都会被暂停.
多线程并发GC.
G1老年代GC特点如下:
并发标记阶段
　　1.在与应用程序并发执行的过程中会计算活跃度信息.
　　2.这些活跃度信息标识出那些regions最适合在STW期间回收(which regions will be best to reclaim during an evacuation pause).
　　3.不像CMS有清理阶段.
再次标记阶段
　　1.使用Snapshot-at-the-Beginning(SATB)算法比CMS快得多.
　　2.空region直接被回收.
拷贝/清理阶段(Copying/Cleanup Phase)
　　1.年轻代与老年代同时回收.
　　2.老年代内存回收会基于他的活跃度信息.

### 207.说一下 jvm 调优的工具？

1、jps:虚拟机进程状况工具

jps主要用来输出JVM中运行的进程状态信息。语法格式如下：

jps [options] [hostid]

第一个参数：options

-q 不输出类名、Jar名和传入main方法的参数-m 输出传入main方法的参数-l 输出main类或Jar的全限名-v 输出传入JVM的参数

第二个参数：hostid

主机或者是服务器的id，如果不指定，就默认为当前的主机或者是服务器。

我是在Windows10系统下测试的，当然你可以在linux下试验，方式是一样的，结果可能有不同。你可以选择不同的参数选项来进行测试。打开CMD输入相应命令

![img](http://pics2.baidu.com/feed/4610b912c8fcc3ce5f26458dc79cf68dd63f208c.jpeg?token=27132261b914113d2d9263d70c6bfd58)

2、jstack：堆栈跟踪工具

jstack用于生成虚拟机当前时刻的线程快照。语法格式如下：

jstack [option] vmid

第一个参数：option

![img](http://pics1.baidu.com/feed/37d3d539b6003af35d0f963c63f3e6591138b617.png?token=15a7c34b4c9f8ee190938f636fbee4e4&s=1A2874238DA0450356FCA1DE0300C0B1)

第二个参数：vmid

vmid是Java虚拟机ID，在Linux/Unix系统上一般就是进程ID。

我们直接在CMD中操作一下：

![img](http://pics3.baidu.com/feed/d31b0ef41bd5ad6e1982cf9bd51219deb7fd3ca2.jpeg?token=e336b0f86343c7d16a3d8d4a41d1afc3&s=0DE272228BE08A4B5C7DB50F000070C1)

3、jstat:虚拟机统计信息监控工具

jstat监视虚拟机各种运行状态信息，可以显示本地或者是远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。语法格式如下：

jstat [ generalOption | outputOptions vmid [interval] [count]] ]

第一个参数：generalOption | outputOptions

这个参数表示的option，代表着用户希望查询的虚拟机信息，分为类加载、垃圾收集、运行期编译状况3类。

![img](http://pics7.baidu.com/feed/b151f8198618367ae3252a817aaaabd1b21ce518.jpeg?token=5d86fe924dd5722ae81742a8395effa9&s=3EAA70239D9844C85EFD45DA0100C0B1)

第二个参数：vmid

vmid是Java虚拟机ID，在Linux/Unix系统上一般就是进程ID。

第三个参数：interval

interval是采样时间间隔，

第四个参数：count

count表示的是采样数。

下面我们就是用一下这个工具，打开我们的CMD，输入相应的命令：

![img](http://pics2.baidu.com/feed/8b82b9014a90f603c70774796dcb931eb151edbc.jpeg?token=996ae0d68d207a21ca2fef14f99c843c&s=45D33A66DFEDBB704C71DC1F0000A0C3)

4、jinfo：实时地查看和调整虚拟机各项参数

命令格式:

jinfo [option] pid

第一个参数：option

![img](http://pics4.baidu.com/feed/71cf3bc79f3df8dc74aa127798c8528e4510289b.png?token=f36fe6690ad2eef4d6ae1d21db99f222&s=1AAA74239BA059031E5D90DE0300C0B1)

第二个参数：pid

指定显示的进程id。

在CMD中进行测试：

![img](http://pics4.baidu.com/feed/a5c27d1ed21b0ef41ab2f25d891d71df80cb3ebc.jpeg?token=5ae7f70c62faa7374b1e6a64fe10d122&s=EDE03A6613A483494E5DBD0F0000E0C3)

5、jmap：生成虚拟机的内存转储快照（heapdump文件）

jmap（Memory Map for Java，内存映像工具），用于生成堆转存的快照，一般是heapdump或者dump文件。如果不适用jmap命令，可以使用-XX:+HeapDumpOnOutOfMemoryError参数，当虚拟机发生内存溢出的时候可以产生快照。或者使用kill -3 pid也可以产生。jmap的作用并不仅仅是为了获取dump文件，它可以查询finalize执行队列，java堆和永久代的详细信息，如空间使用率，当前用的哪种收集器。命令格式如下：

jmap [option] vmid

第一个参数：

![img](http://pics5.baidu.com/feed/d8f9d72a6059252d24ddc5946042233e59b5b9b3.jpeg?token=b5b6d5d2cc3be15e31b6d772e2da34bb&s=5AAA346399D844C80E5CD4CF0000A0B1)

第二个参数：vmid

vmid是Java虚拟机ID，在Linux/Unix系统上一般就是进程ID.

在cmd中测试：

![img](http://pics0.baidu.com/feed/ac6eddc451da81cb7409ae1306bff0130b24315a.jpeg?token=93e2a4769589c40a59109e43ce1b1cfa&s=4DC33A6653A5834F0E5CA41B000070C3)

6、jhat：分析内存转储快照，不推荐使用，而且慢

由于这个工具功能比较简陋，运行起来也比较耗时，所以这个工具不推荐使用，推荐使用MAT。

7、JConsole：JMX的可视化管理工具

这个工具相比较前面几个工具，使用率比较高，很重要。它是一个java GUI监视工具，可以以图表化的形式显示各种数据。并可通过远程连接监视远程的服务器VM。用java写的GUI程序，用来监控VM，并可监控远程的VM，非常易用，而且功能非常强。

在cmd里面输入 jconsole，选则进程就可以了。（前提是在IDE工具先建立一个线程运行着）

![img](http://pics4.baidu.com/feed/359b033b5bb5c9ea5dbaad7a81e096053bf3b338.jpeg?token=540c9335ce9b5dafb1440d53931567e4&s=49008D1A515E55CC58F515DA0000C0B1)

然后我们选择了相应的选项之后，进入这个工具就会出现下面这个界面

![img](http://pics2.baidu.com/feed/bd315c6034a85edfe69876d11c8d2926dc54750e.jpeg?token=dbf4f034d60e8173c3d2c2a00351dcdc&s=AD8A55320B0E444D1C5508CA0000D0B2)

在上面有菜单，我们可以选择其中一个进行查看，就可以了，这个用具用起来很方便，也是我之前用的比较多的工具。

8、VisualVM：多合一故障管理工具

这个工具也很牛bility。它同jconsole都是一个基于图形化界面的、可以查看本地及远程的JAVA GUI监控工具，Jvisualvm同jconsole的使用方式一样，直接在命令行打入jvisualvm即可启动，jvisualvm界面更美观一些，数据更实时：

![img](http://pics4.baidu.com/feed/d1160924ab18972b3f49b403b2145b8c9c510ae2.jpeg?token=964d4a7ea666e14f0ff647efd2c52218&s=F490EC381ECE74C8445C58DF000010B2)

最上面也有菜单，你可以选择不同的选项来展示

### 208.常用的 jvm 调优的参数都有哪些？

-Xmx

指定java程序的最大堆内存, 使用java -Xmx5000M -version判断当前系统能分配的最大堆内存

-Xms

指定最小堆内存, 通常设置成跟最大堆内存一样，减少GC

-Xmn

　　设置年轻代大小。整个堆大小=年轻代大小 + 年老代大小。所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。

-Xss

　　指定线程的最大栈空间, 此参数决定了java函数调用的深度, 值越大调用深度越深, 若值太小则容易出栈溢出错误(StackOverflowError)

-XX:PermSize

　　指定方法区(永久区)的初始值,默认是物理内存的1/64， 在Java8永久区移除, 代之的是元数据区， 由-XX:MetaspaceSize指定

-XX:MaxPermSize

　　指定方法区的最大值, 默认是物理内存的1/4， 在java8中由-XX:MaxMetaspaceSize指定元数据区的大小

-XX:NewRatio=n

　　年老代与年轻代的比值，-XX:NewRatio=2, 表示年老代与年轻代的比值为2:1

-XX:SurvivorRatio=n

Eden区与Survivor区的大小比值，-XX:SurvivorRatio=8表示Eden区与Survivor区的大小比值是8:1:1，因为Survivor区有两个(from, to)
      

      
        <div class="page-reward">
          <a href="javascript:;" class="page-reward-btn tooltip-top">
            <div class="tooltip tooltip-east">
            <span class="tooltip-item">
              赏
            </span>
            <span class="tooltip-content">
              <span class="tooltip-text">
                <span class="tooltip-inner">
                  <p class="reward-p"><i class="icon icon-quo-left"></i>谢谢你请我吃糖果<i class="icon icon-quo-right"></i></p>
                  <div class="reward-box">
                    
                    
                  </div>
                </span>
              </span>
            </span>
          </div>
          </a>
        </div>
      
    </div>
    <div class="article-info article-info-index">
      
      
      

      

      
        
<div class="share-btn share-icons tooltip-left">
  <div class="tooltip tooltip-east">
    <span class="tooltip-item">
      <a href="javascript:;" class="share-sns share-outer">
        <i class="icon icon-share"></i>
      </a>
    </span>
    <span class="tooltip-content">
      <div class="share-wrap">
        <div class="share-icons">
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="icon icon-weibo"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="icon icon-weixin"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="icon icon-qq"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="icon icon-douban"></i>
          </a>
          <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a>
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="icon icon-facebook"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="icon icon-twitter"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="icon icon-google"></i>
          </a>
        </div>
      </div>
    </span>
  </div>
</div>

<div class="page-modal wx-share js-wx-box">
    <a class="close js-modal-close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//pan.baidu.com/share/qrcode?url=http://yoursite.com/2020/03/31/java/" alt="微信分享二维码">
    </div>
</div>

<div class="mask js-mask"></div>
      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

  
<nav id="article-nav">
  
  
    <a href="/2020/01/04/%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">课程/数据结构</div>
      <i class="icon-circle-right"></i>
    </a>
  
</nav>


<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>



  
  
  

  

  

  


          </div>
        </div>
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2020 董晓洁
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		mathjax: false,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		toc_hide_index: true,
		root: "/",
		innerArchive: true,
		showTags: false
	}
</script>

<script>!function(t){function n(e){if(r[e])return r[e].exports;var i=r[e]={exports:{},id:e,loaded:!1};return t[e].call(i.exports,i,i.exports,n),i.loaded=!0,i.exports}var r={};n.m=t,n.c=r,n.p="./",n(0)}([function(t,n,r){r(195),t.exports=r(191)},function(t,n,r){var e=r(3),i=r(52),o=r(27),u=r(28),c=r(53),f="prototype",a=function(t,n,r){var s,l,h,v,p=t&a.F,d=t&a.G,y=t&a.S,g=t&a.P,b=t&a.B,m=d?e:y?e[n]||(e[n]={}):(e[n]||{})[f],x=d?i:i[n]||(i[n]={}),w=x[f]||(x[f]={});d&&(r=n);for(s in r)l=!p&&m&&void 0!==m[s],h=(l?m:r)[s],v=b&&l?c(h,e):g&&"function"==typeof h?c(Function.call,h):h,m&&u(m,s,h,t&a.U),x[s]!=h&&o(x,s,v),g&&w[s]!=h&&(w[s]=h)};e.core=i,a.F=1,a.G=2,a.S=4,a.P=8,a.B=16,a.W=32,a.U=64,a.R=128,t.exports=a},function(t,n,r){var e=r(6);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n,r){var e=r(126)("wks"),i=r(76),o=r(3).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n,r){var e=r(94),i=r(33);t.exports=function(t){return e(i(t))}},function(t,n,r){t.exports=!r(4)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(2),i=r(167),o=r(50),u=Object.defineProperty;n.f=r(10)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){t.exports=!r(18)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(14),i=r(22);t.exports=r(12)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var e=r(20),i=r(58),o=r(42),u=Object.defineProperty;n.f=r(12)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){var e=r(40)("wks"),i=r(23),o=r(5).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n,r){var e=r(67),i=Math.min;t.exports=function(t){return t>0?i(e(t),9007199254740991):0}},function(t,n,r){var e=r(46);t.exports=function(t){return Object(e(t))}},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n,r){var e=r(63),i=r(34);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n,r){var e=r(21);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n){var r=t.exports={version:"2.4.0"};"number"==typeof __e&&(__e=r)},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n,r){var e=r(11),i=r(66);t.exports=r(10)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var e=r(3),i=r(27),o=r(24),u=r(76)("src"),c="toString",f=Function[c],a=(""+f).split(c);r(52).inspectSource=function(t){return f.call(t)},(t.exports=function(t,n,r,c){var f="function"==typeof r;f&&(o(r,"name")||i(r,"name",n)),t[n]!==r&&(f&&(o(r,u)||i(r,u,t[n]?""+t[n]:a.join(String(n)))),t===e?t[n]=r:c?t[n]?t[n]=r:i(t,n,r):(delete t[n],i(t,n,r)))})(Function.prototype,c,function(){return"function"==typeof this&&this[u]||f.call(this)})},function(t,n,r){var e=r(1),i=r(4),o=r(46),u=function(t,n,r,e){var i=String(o(t)),u="<"+n;return""!==r&&(u+=" "+r+'="'+String(e).replace(/"/g,"&quot;")+'"'),u+">"+i+"</"+n+">"};t.exports=function(t,n){var r={};r[t]=n(u),e(e.P+e.F*i(function(){var n=""[t]('"');return n!==n.toLowerCase()||n.split('"').length>3}),"String",r)}},function(t,n,r){var e=r(115),i=r(46);t.exports=function(t){return e(i(t))}},function(t,n,r){var e=r(116),i=r(66),o=r(30),u=r(50),c=r(24),f=r(167),a=Object.getOwnPropertyDescriptor;n.f=r(10)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(24),i=r(17),o=r(145)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n){t.exports={}},function(t,n){t.exports=!0},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var e=r(14).f,i=r(8),o=r(15)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var e=r(40)("keys"),i=r(23);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var e=r(5),i="__core-js_shared__",o=e[i]||(e[i]={});t.exports=function(t){return o[t]||(o[t]={})}},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?e:r)(t)}},function(t,n,r){var e=r(21);t.exports=function(t,n){if(!e(t))return t;var r,i;if(n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;if("function"==typeof(r=t.valueOf)&&!e(i=r.call(t)))return i;if(!n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var e=r(5),i=r(25),o=r(36),u=r(44),c=r(14).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){n.f=r(15)},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n,r){var e=r(4);t.exports=function(t,n){return!!t&&e(function(){n?t.call(null,function(){},1):t.call(null)})}},function(t,n,r){var e=r(53),i=r(115),o=r(17),u=r(16),c=r(203);t.exports=function(t,n){var r=1==t,f=2==t,a=3==t,s=4==t,l=6==t,h=5==t||l,v=n||c;return function(n,c,p){for(var d,y,g=o(n),b=i(g),m=e(c,p,3),x=u(b.length),w=0,S=r?v(n,x):f?v(n,0):void 0;x>w;w++)if((h||w in b)&&(d=b[w],y=m(d,w,g),t))if(r)S[w]=y;else if(y)switch(t){case 3:return!0;case 5:return d;case 6:return w;case 2:S.push(d)}else if(s)return!1;return l?-1:a||s?s:S}}},function(t,n,r){var e=r(1),i=r(52),o=r(4);t.exports=function(t,n){var r=(i.Object||{})[t]||Object[t],u={};u[t]=n(r),e(e.S+e.F*o(function(){r(1)}),"Object",u)}},function(t,n,r){var e=r(6);t.exports=function(t,n){if(!e(t))return t;var r,i;if(n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;if("function"==typeof(r=t.valueOf)&&!e(i=r.call(t)))return i;if(!n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var e=r(5),i=r(25),o=r(91),u=r(13),c="prototype",f=function(t,n,r){var a,s,l,h=t&f.F,v=t&f.G,p=t&f.S,d=t&f.P,y=t&f.B,g=t&f.W,b=v?i:i[n]||(i[n]={}),m=b[c],x=v?e:p?e[n]:(e[n]||{})[c];v&&(r=n);for(a in r)(s=!h&&x&&void 0!==x[a])&&a in b||(l=s?x[a]:r[a],b[a]=v&&"function"!=typeof x[a]?r[a]:y&&s?o(l,e):g&&x[a]==l?function(t){var n=function(n,r,e){if(this instanceof t){switch(arguments.length){case 0:return new t;case 1:return new t(n);case 2:return new t(n,r)}return new t(n,r,e)}return t.apply(this,arguments)};return n[c]=t[c],n}(l):d&&"function"==typeof l?o(Function.call,l):l,d&&((b.virtual||(b.virtual={}))[a]=l,t&f.R&&m&&!m[a]&&u(m,a,l)))};f.F=1,f.G=2,f.S=4,f.P=8,f.B=16,f.W=32,f.U=64,f.R=128,t.exports=f},function(t,n){var r=t.exports={version:"2.4.0"};"number"==typeof __e&&(__e=r)},function(t,n,r){var e=r(26);t.exports=function(t,n,r){if(e(t),void 0===n)return t;switch(r){case 1:return function(r){return t.call(n,r)};case 2:return function(r,e){return t.call(n,r,e)};case 3:return function(r,e,i){return t.call(n,r,e,i)}}return function(){return t.apply(n,arguments)}}},function(t,n,r){var e=r(183),i=r(1),o=r(126)("metadata"),u=o.store||(o.store=new(r(186))),c=function(t,n,r){var i=u.get(t);if(!i){if(!r)return;u.set(t,i=new e)}var o=i.get(n);if(!o){if(!r)return;i.set(n,o=new e)}return o},f=function(t,n,r){var e=c(n,r,!1);return void 0!==e&&e.has(t)},a=function(t,n,r){var e=c(n,r,!1);return void 0===e?void 0:e.get(t)},s=function(t,n,r,e){c(r,e,!0).set(t,n)},l=function(t,n){var r=c(t,n,!1),e=[];return r&&r.forEach(function(t,n){e.push(n)}),e},h=function(t){return void 0===t||"symbol"==typeof t?t:String(t)},v=function(t){i(i.S,"Reflect",t)};t.exports={store:u,map:c,has:f,get:a,set:s,keys:l,key:h,exp:v}},function(t,n,r){"use strict";if(r(10)){var e=r(69),i=r(3),o=r(4),u=r(1),c=r(127),f=r(152),a=r(53),s=r(68),l=r(66),h=r(27),v=r(73),p=r(67),d=r(16),y=r(75),g=r(50),b=r(24),m=r(180),x=r(114),w=r(6),S=r(17),_=r(137),O=r(70),E=r(32),P=r(71).f,j=r(154),F=r(76),M=r(7),A=r(48),N=r(117),T=r(146),I=r(155),k=r(80),L=r(123),R=r(74),C=r(130),D=r(160),U=r(11),W=r(31),G=U.f,B=W.f,V=i.RangeError,z=i.TypeError,q=i.Uint8Array,K="ArrayBuffer",J="Shared"+K,Y="BYTES_PER_ELEMENT",H="prototype",$=Array[H],X=f.ArrayBuffer,Q=f.DataView,Z=A(0),tt=A(2),nt=A(3),rt=A(4),et=A(5),it=A(6),ot=N(!0),ut=N(!1),ct=I.values,ft=I.keys,at=I.entries,st=$.lastIndexOf,lt=$.reduce,ht=$.reduceRight,vt=$.join,pt=$.sort,dt=$.slice,yt=$.toString,gt=$.toLocaleString,bt=M("iterator"),mt=M("toStringTag"),xt=F("typed_constructor"),wt=F("def_constructor"),St=c.CONSTR,_t=c.TYPED,Ot=c.VIEW,Et="Wrong length!",Pt=A(1,function(t,n){return Tt(T(t,t[wt]),n)}),jt=o(function(){return 1===new q(new Uint16Array([1]).buffer)[0]}),Ft=!!q&&!!q[H].set&&o(function(){new q(1).set({})}),Mt=function(t,n){if(void 0===t)throw z(Et);var r=+t,e=d(t);if(n&&!m(r,e))throw V(Et);return e},At=function(t,n){var r=p(t);if(r<0||r%n)throw V("Wrong offset!");return r},Nt=function(t){if(w(t)&&_t in t)return t;throw z(t+" is not a typed array!")},Tt=function(t,n){if(!(w(t)&&xt in t))throw z("It is not a typed array constructor!");return new t(n)},It=function(t,n){return kt(T(t,t[wt]),n)},kt=function(t,n){for(var r=0,e=n.length,i=Tt(t,e);e>r;)i[r]=n[r++];return i},Lt=function(t,n,r){G(t,n,{get:function(){return this._d[r]}})},Rt=function(t){var n,r,e,i,o,u,c=S(t),f=arguments.length,s=f>1?arguments[1]:void 0,l=void 0!==s,h=j(c);if(void 0!=h&&!_(h)){for(u=h.call(c),e=[],n=0;!(o=u.next()).done;n++)e.push(o.value);c=e}for(l&&f>2&&(s=a(s,arguments[2],2)),n=0,r=d(c.length),i=Tt(this,r);r>n;n++)i[n]=l?s(c[n],n):c[n];return i},Ct=function(){for(var t=0,n=arguments.length,r=Tt(this,n);n>t;)r[t]=arguments[t++];return r},Dt=!!q&&o(function(){gt.call(new q(1))}),Ut=function(){return gt.apply(Dt?dt.call(Nt(this)):Nt(this),arguments)},Wt={copyWithin:function(t,n){return D.call(Nt(this),t,n,arguments.length>2?arguments[2]:void 0)},every:function(t){return rt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},fill:function(t){return C.apply(Nt(this),arguments)},filter:function(t){return It(this,tt(Nt(this),t,arguments.length>1?arguments[1]:void 0))},find:function(t){return et(Nt(this),t,arguments.length>1?arguments[1]:void 0)},findIndex:function(t){return it(Nt(this),t,arguments.length>1?arguments[1]:void 0)},forEach:function(t){Z(Nt(this),t,arguments.length>1?arguments[1]:void 0)},indexOf:function(t){return ut(Nt(this),t,arguments.length>1?arguments[1]:void 0)},includes:function(t){return ot(Nt(this),t,arguments.length>1?arguments[1]:void 0)},join:function(t){return vt.apply(Nt(this),arguments)},lastIndexOf:function(t){return st.apply(Nt(this),arguments)},map:function(t){return Pt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},reduce:function(t){return lt.apply(Nt(this),arguments)},reduceRight:function(t){return ht.apply(Nt(this),arguments)},reverse:function(){for(var t,n=this,r=Nt(n).length,e=Math.floor(r/2),i=0;i<e;)t=n[i],n[i++]=n[--r],n[r]=t;return n},some:function(t){return nt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},sort:function(t){return pt.call(Nt(this),t)},subarray:function(t,n){var r=Nt(this),e=r.length,i=y(t,e);return new(T(r,r[wt]))(r.buffer,r.byteOffset+i*r.BYTES_PER_ELEMENT,d((void 0===n?e:y(n,e))-i))}},Gt=function(t,n){return It(this,dt.call(Nt(this),t,n))},Bt=function(t){Nt(this);var n=At(arguments[1],1),r=this.length,e=S(t),i=d(e.length),o=0;if(i+n>r)throw V(Et);for(;o<i;)this[n+o]=e[o++]},Vt={entries:function(){return at.call(Nt(this))},keys:function(){return ft.call(Nt(this))},values:function(){return ct.call(Nt(this))}},zt=function(t,n){return w(t)&&t[_t]&&"symbol"!=typeof n&&n in t&&String(+n)==String(n)},qt=function(t,n){return zt(t,n=g(n,!0))?l(2,t[n]):B(t,n)},Kt=function(t,n,r){return!(zt(t,n=g(n,!0))&&w(r)&&b(r,"value"))||b(r,"get")||b(r,"set")||r.configurable||b(r,"writable")&&!r.writable||b(r,"enumerable")&&!r.enumerable?G(t,n,r):(t[n]=r.value,t)};St||(W.f=qt,U.f=Kt),u(u.S+u.F*!St,"Object",{getOwnPropertyDescriptor:qt,defineProperty:Kt}),o(function(){yt.call({})})&&(yt=gt=function(){return vt.call(this)});var Jt=v({},Wt);v(Jt,Vt),h(Jt,bt,Vt.values),v(Jt,{slice:Gt,set:Bt,constructor:function(){},toString:yt,toLocaleString:Ut}),Lt(Jt,"buffer","b"),Lt(Jt,"byteOffset","o"),Lt(Jt,"byteLength","l"),Lt(Jt,"length","e"),G(Jt,mt,{get:function(){return this[_t]}}),t.exports=function(t,n,r,f){f=!!f;var a=t+(f?"Clamped":"")+"Array",l="Uint8Array"!=a,v="get"+t,p="set"+t,y=i[a],g=y||{},b=y&&E(y),m=!y||!c.ABV,S={},_=y&&y[H],j=function(t,r){var e=t._d;return e.v[v](r*n+e.o,jt)},F=function(t,r,e){var i=t._d;f&&(e=(e=Math.round(e))<0?0:e>255?255:255&e),i.v[p](r*n+i.o,e,jt)},M=function(t,n){G(t,n,{get:function(){return j(this,n)},set:function(t){return F(this,n,t)},enumerable:!0})};m?(y=r(function(t,r,e,i){s(t,y,a,"_d");var o,u,c,f,l=0,v=0;if(w(r)){if(!(r instanceof X||(f=x(r))==K||f==J))return _t in r?kt(y,r):Rt.call(y,r);o=r,v=At(e,n);var p=r.byteLength;if(void 0===i){if(p%n)throw V(Et);if((u=p-v)<0)throw V(Et)}else if((u=d(i)*n)+v>p)throw V(Et);c=u/n}else c=Mt(r,!0),u=c*n,o=new X(u);for(h(t,"_d",{b:o,o:v,l:u,e:c,v:new Q(o)});l<c;)M(t,l++)}),_=y[H]=O(Jt),h(_,"constructor",y)):L(function(t){new y(null),new y(t)},!0)||(y=r(function(t,r,e,i){s(t,y,a);var o;return w(r)?r instanceof X||(o=x(r))==K||o==J?void 0!==i?new g(r,At(e,n),i):void 0!==e?new g(r,At(e,n)):new g(r):_t in r?kt(y,r):Rt.call(y,r):new g(Mt(r,l))}),Z(b!==Function.prototype?P(g).concat(P(b)):P(g),function(t){t in y||h(y,t,g[t])}),y[H]=_,e||(_.constructor=y));var A=_[bt],N=!!A&&("values"==A.name||void 0==A.name),T=Vt.values;h(y,xt,!0),h(_,_t,a),h(_,Ot,!0),h(_,wt,y),(f?new y(1)[mt]==a:mt in _)||G(_,mt,{get:function(){return a}}),S[a]=y,u(u.G+u.W+u.F*(y!=g),S),u(u.S,a,{BYTES_PER_ELEMENT:n,from:Rt,of:Ct}),Y in _||h(_,Y,n),u(u.P,a,Wt),R(a),u(u.P+u.F*Ft,a,{set:Bt}),u(u.P+u.F*!N,a,Vt),u(u.P+u.F*(_.toString!=yt),a,{toString:yt}),u(u.P+u.F*o(function(){new y(1).slice()}),a,{slice:Gt}),u(u.P+u.F*(o(function(){return[1,2].toLocaleString()!=new y([1,2]).toLocaleString()})||!o(function(){_.toLocaleString.call([1,2])})),a,{toLocaleString:Ut}),k[a]=N?A:T,e||N||h(_,bt,T)}}else t.exports=function(){}},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n,r){var e=r(21),i=r(5).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n,r){t.exports=!r(12)&&!r(18)(function(){return 7!=Object.defineProperty(r(57)("div"),"a",{get:function(){return 7}}).a})},function(t,n,r){"use strict";var e=r(36),i=r(51),o=r(64),u=r(13),c=r(8),f=r(35),a=r(96),s=r(38),l=r(103),h=r(15)("iterator"),v=!([].keys&&"next"in[].keys()),p="keys",d="values",y=function(){return this};t.exports=function(t,n,r,g,b,m,x){a(r,n,g);var w,S,_,O=function(t){if(!v&&t in F)return F[t];switch(t){case p:case d:return function(){return new r(this,t)}}return function(){return new r(this,t)}},E=n+" Iterator",P=b==d,j=!1,F=t.prototype,M=F[h]||F["@@iterator"]||b&&F[b],A=M||O(b),N=b?P?O("entries"):A:void 0,T="Array"==n?F.entries||M:M;if(T&&(_=l(T.call(new t)))!==Object.prototype&&(s(_,E,!0),e||c(_,h)||u(_,h,y)),P&&M&&M.name!==d&&(j=!0,A=function(){return M.call(this)}),e&&!x||!v&&!j&&F[h]||u(F,h,A),f[n]=A,f[E]=y,b)if(w={values:P?A:O(d),keys:m?A:O(p),entries:N},x)for(S in w)S in F||o(F,S,w[S]);else i(i.P+i.F*(v||j),n,w);return w}},function(t,n,r){var e=r(20),i=r(100),o=r(34),u=r(39)("IE_PROTO"),c=function(){},f="prototype",a=function(){var t,n=r(57)("iframe"),e=o.length;for(n.style.display="none",r(93).appendChild(n),n.src="javascript:",t=n.contentWindow.document,t.open(),t.write("<script>document.F=Object<\/script>"),t.close(),a=t.F;e--;)delete a[f][o[e]];return a()};t.exports=Object.create||function(t,n){var r;return null!==t?(c[f]=e(t),r=new c,c[f]=null,r[u]=t):r=a(),void 0===n?r:i(r,n)}},function(t,n,r){var e=r(63),i=r(34).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){var e=r(8),i=r(9),o=r(90)(!1),u=r(39)("IE_PROTO");t.exports=function(t,n){var r,c=i(t),f=0,a=[];for(r in c)r!=u&&e(c,r)&&a.push(r);for(;n.length>f;)e(c,r=n[f++])&&(~o(a,r)||a.push(r));return a}},function(t,n,r){t.exports=r(13)},function(t,n,r){var e=r(76)("meta"),i=r(6),o=r(24),u=r(11).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(4)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},h=function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},v=function(t){return a&&p.NEED&&f(t)&&!o(t,e)&&s(t),t},p=t.exports={KEY:e,NEED:!1,fastKey:l,getWeak:h,onFreeze:v}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?e:r)(t)}},function(t,n){t.exports=function(t,n,r,e){if(!(t instanceof n)||void 0!==e&&e in t)throw TypeError(r+": incorrect invocation!");return t}},function(t,n){t.exports=!1},function(t,n,r){var e=r(2),i=r(173),o=r(133),u=r(145)("IE_PROTO"),c=function(){},f="prototype",a=function(){var t,n=r(132)("iframe"),e=o.length;for(n.style.display="none",r(135).appendChild(n),n.src="javascript:",t=n.contentWindow.document,t.open(),t.write("<script>document.F=Object<\/script>"),t.close(),a=t.F;e--;)delete a[f][o[e]];return a()};t.exports=Object.create||function(t,n){var r;return null!==t?(c[f]=e(t),r=new c,c[f]=null,r[u]=t):r=a(),void 0===n?r:i(r,n)}},function(t,n,r){var e=r(175),i=r(133).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n,r){var e=r(175),i=r(133);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n,r){var e=r(28);t.exports=function(t,n,r){for(var i in n)e(t,i,n[i],r);return t}},function(t,n,r){"use strict";var e=r(3),i=r(11),o=r(10),u=r(7)("species");t.exports=function(t){var n=e[t];o&&n&&!n[u]&&i.f(n,u,{configurable:!0,get:function(){return this}})}},function(t,n,r){var e=r(67),i=Math.max,o=Math.min;t.exports=function(t,n){return t=e(t),t<0?i(t+n,0):o(t,n)}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n,r){var e=r(33);t.exports=function(t){return Object(e(t))}},function(t,n,r){var e=r(7)("unscopables"),i=Array.prototype;void 0==i[e]&&r(27)(i,e,{}),t.exports=function(t){i[e][t]=!0}},function(t,n,r){var e=r(53),i=r(169),o=r(137),u=r(2),c=r(16),f=r(154),a={},s={},n=t.exports=function(t,n,r,l,h){var v,p,d,y,g=h?function(){return t}:f(t),b=e(r,l,n?2:1),m=0;if("function"!=typeof g)throw TypeError(t+" is not iterable!");if(o(g)){for(v=c(t.length);v>m;m++)if((y=n?b(u(p=t[m])[0],p[1]):b(t[m]))===a||y===s)return y}else for(d=g.call(t);!(p=d.next()).done;)if((y=i(d,b,p.value,n))===a||y===s)return y};n.BREAK=a,n.RETURN=s},function(t,n){t.exports={}},function(t,n,r){var e=r(11).f,i=r(24),o=r(7)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var e=r(1),i=r(46),o=r(4),u=r(150),c="["+u+"]",f="​",a=RegExp("^"+c+c+"*"),s=RegExp(c+c+"*$"),l=function(t,n,r){var i={},c=o(function(){return!!u[t]()||f[t]()!=f}),a=i[t]=c?n(h):u[t];r&&(i[r]=a),e(e.P+e.F*c,"String",i)},h=l.trim=function(t,n){return t=String(i(t)),1&n&&(t=t.replace(a,"")),2&n&&(t=t.replace(s,"")),t};t.exports=l},function(t,n,r){t.exports={default:r(86),__esModule:!0}},function(t,n,r){t.exports={default:r(87),__esModule:!0}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}n.__esModule=!0;var i=r(84),o=e(i),u=r(83),c=e(u),f="function"==typeof c.default&&"symbol"==typeof o.default?function(t){return typeof t}:function(t){return t&&"function"==typeof c.default&&t.constructor===c.default&&t!==c.default.prototype?"symbol":typeof t};n.default="function"==typeof c.default&&"symbol"===f(o.default)?function(t){return void 0===t?"undefined":f(t)}:function(t){return t&&"function"==typeof c.default&&t.constructor===c.default&&t!==c.default.prototype?"symbol":void 0===t?"undefined":f(t)}},function(t,n,r){r(110),r(108),r(111),r(112),t.exports=r(25).Symbol},function(t,n,r){r(109),r(113),t.exports=r(44).f("iterator")},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n){t.exports=function(){}},function(t,n,r){var e=r(9),i=r(106),o=r(105);t.exports=function(t){return function(n,r,u){var c,f=e(n),a=i(f.length),s=o(u,a);if(t&&r!=r){for(;a>s;)if((c=f[s++])!=c)return!0}else for(;a>s;s++)if((t||s in f)&&f[s]===r)return t||s||0;return!t&&-1}}},function(t,n,r){var e=r(88);t.exports=function(t,n,r){if(e(t),void 0===n)return t;switch(r){case 1:return function(r){return t.call(n,r)};case 2:return function(r,e){return t.call(n,r,e)};case 3:return function(r,e,i){return t.call(n,r,e,i)}}return function(){return t.apply(n,arguments)}}},function(t,n,r){var e=r(19),i=r(62),o=r(37);t.exports=function(t){var n=e(t),r=i.f;if(r)for(var u,c=r(t),f=o.f,a=0;c.length>a;)f.call(t,u=c[a++])&&n.push(u);return n}},function(t,n,r){t.exports=r(5).document&&document.documentElement},function(t,n,r){var e=r(56);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n,r){var e=r(56);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){"use strict";var e=r(60),i=r(22),o=r(38),u={};r(13)(u,r(15)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n,r){var e=r(19),i=r(9);t.exports=function(t,n){for(var r,o=i(t),u=e(o),c=u.length,f=0;c>f;)if(o[r=u[f++]]===n)return r}},function(t,n,r){var e=r(23)("meta"),i=r(21),o=r(8),u=r(14).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(18)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},h=function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},v=function(t){return a&&p.NEED&&f(t)&&!o(t,e)&&s(t),t},p=t.exports={KEY:e,NEED:!1,fastKey:l,getWeak:h,onFreeze:v}},function(t,n,r){var e=r(14),i=r(20),o=r(19);t.exports=r(12)?Object.defineProperties:function(t,n){i(t);for(var r,u=o(n),c=u.length,f=0;c>f;)e.f(t,r=u[f++],n[r]);return t}},function(t,n,r){var e=r(37),i=r(22),o=r(9),u=r(42),c=r(8),f=r(58),a=Object.getOwnPropertyDescriptor;n.f=r(12)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(9),i=r(61).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],c=function(t){try{return i(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?c(t):i(e(t))}},function(t,n,r){var e=r(8),i=r(77),o=r(39)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n,r){var e=r(41),i=r(33);t.exports=function(t){return function(n,r){var o,u,c=String(i(n)),f=e(r),a=c.length;return f<0||f>=a?t?"":void 0:(o=c.charCodeAt(f),o<55296||o>56319||f+1===a||(u=c.charCodeAt(f+1))<56320||u>57343?t?c.charAt(f):o:t?c.slice(f,f+2):u-56320+(o-55296<<10)+65536)}}},function(t,n,r){var e=r(41),i=Math.max,o=Math.min;t.exports=function(t,n){return t=e(t),t<0?i(t+n,0):o(t,n)}},function(t,n,r){var e=r(41),i=Math.min;t.exports=function(t){return t>0?i(e(t),9007199254740991):0}},function(t,n,r){"use strict";var e=r(89),i=r(97),o=r(35),u=r(9);t.exports=r(59)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):"keys"==n?i(0,r):"values"==n?i(0,t[r]):i(0,[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){},function(t,n,r){"use strict";var e=r(104)(!0);r(59)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";var e=r(5),i=r(8),o=r(12),u=r(51),c=r(64),f=r(99).KEY,a=r(18),s=r(40),l=r(38),h=r(23),v=r(15),p=r(44),d=r(43),y=r(98),g=r(92),b=r(95),m=r(20),x=r(9),w=r(42),S=r(22),_=r(60),O=r(102),E=r(101),P=r(14),j=r(19),F=E.f,M=P.f,A=O.f,N=e.Symbol,T=e.JSON,I=T&&T.stringify,k="prototype",L=v("_hidden"),R=v("toPrimitive"),C={}.propertyIsEnumerable,D=s("symbol-registry"),U=s("symbols"),W=s("op-symbols"),G=Object[k],B="function"==typeof N,V=e.QObject,z=!V||!V[k]||!V[k].findChild,q=o&&a(function(){return 7!=_(M({},"a",{get:function(){return M(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=F(G,n);e&&delete G[n],M(t,n,r),e&&t!==G&&M(G,n,e)}:M,K=function(t){var n=U[t]=_(N[k]);return n._k=t,n},J=B&&"symbol"==typeof N.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof N},Y=function(t,n,r){return t===G&&Y(W,n,r),m(t),n=w(n,!0),m(r),i(U,n)?(r.enumerable?(i(t,L)&&t[L][n]&&(t[L][n]=!1),r=_(r,{enumerable:S(0,!1)})):(i(t,L)||M(t,L,S(1,{})),t[L][n]=!0),q(t,n,r)):M(t,n,r)},H=function(t,n){m(t);for(var r,e=g(n=x(n)),i=0,o=e.length;o>i;)Y(t,r=e[i++],n[r]);return t},$=function(t,n){return void 0===n?_(t):H(_(t),n)},X=function(t){var n=C.call(this,t=w(t,!0));return!(this===G&&i(U,t)&&!i(W,t))&&(!(n||!i(this,t)||!i(U,t)||i(this,L)&&this[L][t])||n)},Q=function(t,n){if(t=x(t),n=w(n,!0),t!==G||!i(U,n)||i(W,n)){var r=F(t,n);return!r||!i(U,n)||i(t,L)&&t[L][n]||(r.enumerable=!0),r}},Z=function(t){for(var n,r=A(x(t)),e=[],o=0;r.length>o;)i(U,n=r[o++])||n==L||n==f||e.push(n);return e},tt=function(t){for(var n,r=t===G,e=A(r?W:x(t)),o=[],u=0;e.length>u;)!i(U,n=e[u++])||r&&!i(G,n)||o.push(U[n]);return o};B||(N=function(){if(this instanceof N)throw TypeError("Symbol is not a constructor!");var t=h(arguments.length>0?arguments[0]:void 0),n=function(r){this===G&&n.call(W,r),i(this,L)&&i(this[L],t)&&(this[L][t]=!1),q(this,t,S(1,r))};return o&&z&&q(G,t,{configurable:!0,set:n}),K(t)},c(N[k],"toString",function(){return this._k}),E.f=Q,P.f=Y,r(61).f=O.f=Z,r(37).f=X,r(62).f=tt,o&&!r(36)&&c(G,"propertyIsEnumerable",X,!0),p.f=function(t){return K(v(t))}),u(u.G+u.W+u.F*!B,{Symbol:N});for(var nt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),rt=0;nt.length>rt;)v(nt[rt++]);for(var nt=j(v.store),rt=0;nt.length>rt;)d(nt[rt++]);u(u.S+u.F*!B,"Symbol",{for:function(t){return i(D,t+="")?D[t]:D[t]=N(t)},keyFor:function(t){if(J(t))return y(D,t);throw TypeError(t+" is not a symbol!")},useSetter:function(){z=!0},useSimple:function(){z=!1}}),u(u.S+u.F*!B,"Object",{create:$,defineProperty:Y,defineProperties:H,getOwnPropertyDescriptor:Q,getOwnPropertyNames:Z,getOwnPropertySymbols:tt}),T&&u(u.S+u.F*(!B||a(function(){var t=N();return"[null]"!=I([t])||"{}"!=I({a:t})||"{}"!=I(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!J(t)){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);return n=e[1],"function"==typeof n&&(r=n),!r&&b(n)||(n=function(t,n){if(r&&(n=r.call(this,t,n)),!J(n))return n}),e[1]=n,I.apply(T,e)}}}),N[k][R]||r(13)(N[k],R,N[k].valueOf),l(N,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){r(43)("asyncIterator")},function(t,n,r){r(43)("observable")},function(t,n,r){r(107);for(var e=r(5),i=r(13),o=r(35),u=r(15)("toStringTag"),c=["NodeList","DOMTokenList","MediaList","StyleSheetList","CSSRuleList"],f=0;f<5;f++){var a=c[f],s=e[a],l=s&&s.prototype;l&&!l[u]&&i(l,u,a),o[a]=o.Array}},function(t,n,r){var e=r(45),i=r(7)("toStringTag"),o="Arguments"==e(function(){return arguments}()),u=function(t,n){try{return t[n]}catch(t){}};t.exports=function(t){var n,r,c;return void 0===t?"Undefined":null===t?"Null":"string"==typeof(r=u(n=Object(t),i))?r:o?e(n):"Object"==(c=e(n))&&"function"==typeof n.callee?"Arguments":c}},function(t,n,r){var e=r(45);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var e=r(30),i=r(16),o=r(75);t.exports=function(t){return function(n,r,u){var c,f=e(n),a=i(f.length),s=o(u,a);if(t&&r!=r){for(;a>s;)if((c=f[s++])!=c)return!0}else for(;a>s;s++)if((t||s in f)&&f[s]===r)return t||s||0;return!t&&-1}}},function(t,n,r){"use strict";var e=r(3),i=r(1),o=r(28),u=r(73),c=r(65),f=r(79),a=r(68),s=r(6),l=r(4),h=r(123),v=r(81),p=r(136);t.exports=function(t,n,r,d,y,g){var b=e[t],m=b,x=y?"set":"add",w=m&&m.prototype,S={},_=function(t){var n=w[t];o(w,t,"delete"==t?function(t){return!(g&&!s(t))&&n.call(this,0===t?0:t)}:"has"==t?function(t){return!(g&&!s(t))&&n.call(this,0===t?0:t)}:"get"==t?function(t){return g&&!s(t)?void 0:n.call(this,0===t?0:t)}:"add"==t?function(t){return n.call(this,0===t?0:t),this}:function(t,r){return n.call(this,0===t?0:t,r),this})};if("function"==typeof m&&(g||w.forEach&&!l(function(){(new m).entries().next()}))){var O=new m,E=O[x](g?{}:-0,1)!=O,P=l(function(){O.has(1)}),j=h(function(t){new m(t)}),F=!g&&l(function(){for(var t=new m,n=5;n--;)t[x](n,n);return!t.has(-0)});j||(m=n(function(n,r){a(n,m,t);var e=p(new b,n,m);return void 0!=r&&f(r,y,e[x],e),e}),m.prototype=w,w.constructor=m),(P||F)&&(_("delete"),_("has"),y&&_("get")),(F||E)&&_(x),g&&w.clear&&delete w.clear}else m=d.getConstructor(n,t,y,x),u(m.prototype,r),c.NEED=!0;return v(m,t),S[t]=m,i(i.G+i.W+i.F*(m!=b),S),g||d.setStrong(m,t,y),m}},function(t,n,r){"use strict";var e=r(27),i=r(28),o=r(4),u=r(46),c=r(7);t.exports=function(t,n,r){var f=c(t),a=r(u,f,""[t]),s=a[0],l=a[1];o(function(){var n={};return n[f]=function(){return 7},7!=""[t](n)})&&(i(String.prototype,t,s),e(RegExp.prototype,f,2==n?function(t,n){return l.call(t,this,n)}:function(t){return l.call(t,this)}))}
},function(t,n,r){"use strict";var e=r(2);t.exports=function(){var t=e(this),n="";return t.global&&(n+="g"),t.ignoreCase&&(n+="i"),t.multiline&&(n+="m"),t.unicode&&(n+="u"),t.sticky&&(n+="y"),n}},function(t,n){t.exports=function(t,n,r){var e=void 0===r;switch(n.length){case 0:return e?t():t.call(r);case 1:return e?t(n[0]):t.call(r,n[0]);case 2:return e?t(n[0],n[1]):t.call(r,n[0],n[1]);case 3:return e?t(n[0],n[1],n[2]):t.call(r,n[0],n[1],n[2]);case 4:return e?t(n[0],n[1],n[2],n[3]):t.call(r,n[0],n[1],n[2],n[3])}return t.apply(r,n)}},function(t,n,r){var e=r(6),i=r(45),o=r(7)("match");t.exports=function(t){var n;return e(t)&&(void 0!==(n=t[o])?!!n:"RegExp"==i(t))}},function(t,n,r){var e=r(7)("iterator"),i=!1;try{var o=[7][e]();o.return=function(){i=!0},Array.from(o,function(){throw 2})}catch(t){}t.exports=function(t,n){if(!n&&!i)return!1;var r=!1;try{var o=[7],u=o[e]();u.next=function(){return{done:r=!0}},o[e]=function(){return u},t(o)}catch(t){}return r}},function(t,n,r){t.exports=r(69)||!r(4)(function(){var t=Math.random();__defineSetter__.call(null,t,function(){}),delete r(3)[t]})},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){var e=r(3),i="__core-js_shared__",o=e[i]||(e[i]={});t.exports=function(t){return o[t]||(o[t]={})}},function(t,n,r){for(var e,i=r(3),o=r(27),u=r(76),c=u("typed_array"),f=u("view"),a=!(!i.ArrayBuffer||!i.DataView),s=a,l=0,h="Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(",");l<9;)(e=i[h[l++]])?(o(e.prototype,c,!0),o(e.prototype,f,!0)):s=!1;t.exports={ABV:a,CONSTR:s,TYPED:c,VIEW:f}},function(t,n){"use strict";var r={versions:function(){var t=window.navigator.userAgent;return{trident:t.indexOf("Trident")>-1,presto:t.indexOf("Presto")>-1,webKit:t.indexOf("AppleWebKit")>-1,gecko:t.indexOf("Gecko")>-1&&-1==t.indexOf("KHTML"),mobile:!!t.match(/AppleWebKit.*Mobile.*/),ios:!!t.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/),android:t.indexOf("Android")>-1||t.indexOf("Linux")>-1,iPhone:t.indexOf("iPhone")>-1||t.indexOf("Mac")>-1,iPad:t.indexOf("iPad")>-1,webApp:-1==t.indexOf("Safari"),weixin:-1==t.indexOf("MicroMessenger")}}()};t.exports=r},function(t,n,r){"use strict";var e=r(85),i=function(t){return t&&t.__esModule?t:{default:t}}(e),o=function(){function t(t,n,e){return n||e?String.fromCharCode(n||e):r[t]||t}function n(t){return e[t]}var r={"&quot;":'"',"&lt;":"<","&gt;":">","&amp;":"&","&nbsp;":" "},e={};for(var u in r)e[r[u]]=u;return r["&apos;"]="'",e["'"]="&#39;",{encode:function(t){return t?(""+t).replace(/['<> "&]/g,n).replace(/\r?\n/g,"<br/>").replace(/\s/g,"&nbsp;"):""},decode:function(n){return n?(""+n).replace(/<br\s*\/?>/gi,"\n").replace(/&quot;|&lt;|&gt;|&amp;|&nbsp;|&apos;|&#(\d+);|&#(\d+)/g,t).replace(/\u00a0/g," "):""},encodeBase16:function(t){if(!t)return t;t+="";for(var n=[],r=0,e=t.length;e>r;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},encodeBase16forJSON:function(t){if(!t)return t;t=t.replace(/[\u4E00-\u9FBF]/gi,function(t){return escape(t).replace("%u","\\u")});for(var n=[],r=0,e=t.length;e>r;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},decodeBase16:function(t){if(!t)return t;t+="";for(var n=[],r=0,e=t.length;e>r;r+=2)n.push(String.fromCharCode("0x"+t.slice(r,r+2)));return n.join("")},encodeObject:function(t){if(t instanceof Array)for(var n=0,r=t.length;r>n;n++)t[n]=o.encodeObject(t[n]);else if("object"==(void 0===t?"undefined":(0,i.default)(t)))for(var e in t)t[e]=o.encodeObject(t[e]);else if("string"==typeof t)return o.encode(t);return t},loadScript:function(t){var n=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(n),n.setAttribute("src",t)},addLoadEvent:function(t){var n=window.onload;"function"!=typeof window.onload?window.onload=t:window.onload=function(){n(),t()}}}}();t.exports=o},function(t,n,r){"use strict";var e=r(17),i=r(75),o=r(16);t.exports=function(t){for(var n=e(this),r=o(n.length),u=arguments.length,c=i(u>1?arguments[1]:void 0,r),f=u>2?arguments[2]:void 0,a=void 0===f?r:i(f,r);a>c;)n[c++]=t;return n}},function(t,n,r){"use strict";var e=r(11),i=r(66);t.exports=function(t,n,r){n in t?e.f(t,n,i(0,r)):t[n]=r}},function(t,n,r){var e=r(6),i=r(3).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n,r){var e=r(7)("match");t.exports=function(t){var n=/./;try{"/./"[t](n)}catch(r){try{return n[e]=!1,!"/./"[t](n)}catch(t){}}return!0}},function(t,n,r){t.exports=r(3).document&&document.documentElement},function(t,n,r){var e=r(6),i=r(144).set;t.exports=function(t,n,r){var o,u=n.constructor;return u!==r&&"function"==typeof u&&(o=u.prototype)!==r.prototype&&e(o)&&i&&i(t,o),t}},function(t,n,r){var e=r(80),i=r(7)("iterator"),o=Array.prototype;t.exports=function(t){return void 0!==t&&(e.Array===t||o[i]===t)}},function(t,n,r){var e=r(45);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){"use strict";var e=r(70),i=r(66),o=r(81),u={};r(27)(u,r(7)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n,r){"use strict";var e=r(69),i=r(1),o=r(28),u=r(27),c=r(24),f=r(80),a=r(139),s=r(81),l=r(32),h=r(7)("iterator"),v=!([].keys&&"next"in[].keys()),p="keys",d="values",y=function(){return this};t.exports=function(t,n,r,g,b,m,x){a(r,n,g);var w,S,_,O=function(t){if(!v&&t in F)return F[t];switch(t){case p:case d:return function(){return new r(this,t)}}return function(){return new r(this,t)}},E=n+" Iterator",P=b==d,j=!1,F=t.prototype,M=F[h]||F["@@iterator"]||b&&F[b],A=M||O(b),N=b?P?O("entries"):A:void 0,T="Array"==n?F.entries||M:M;if(T&&(_=l(T.call(new t)))!==Object.prototype&&(s(_,E,!0),e||c(_,h)||u(_,h,y)),P&&M&&M.name!==d&&(j=!0,A=function(){return M.call(this)}),e&&!x||!v&&!j&&F[h]||u(F,h,A),f[n]=A,f[E]=y,b)if(w={values:P?A:O(d),keys:m?A:O(p),entries:N},x)for(S in w)S in F||o(F,S,w[S]);else i(i.P+i.F*(v||j),n,w);return w}},function(t,n){var r=Math.expm1;t.exports=!r||r(10)>22025.465794806718||r(10)<22025.465794806718||-2e-17!=r(-2e-17)?function(t){return 0==(t=+t)?t:t>-1e-6&&t<1e-6?t+t*t/2:Math.exp(t)-1}:r},function(t,n){t.exports=Math.sign||function(t){return 0==(t=+t)||t!=t?t:t<0?-1:1}},function(t,n,r){var e=r(3),i=r(151).set,o=e.MutationObserver||e.WebKitMutationObserver,u=e.process,c=e.Promise,f="process"==r(45)(u);t.exports=function(){var t,n,r,a=function(){var e,i;for(f&&(e=u.domain)&&e.exit();t;){i=t.fn,t=t.next;try{i()}catch(e){throw t?r():n=void 0,e}}n=void 0,e&&e.enter()};if(f)r=function(){u.nextTick(a)};else if(o){var s=!0,l=document.createTextNode("");new o(a).observe(l,{characterData:!0}),r=function(){l.data=s=!s}}else if(c&&c.resolve){var h=c.resolve();r=function(){h.then(a)}}else r=function(){i.call(e,a)};return function(e){var i={fn:e,next:void 0};n&&(n.next=i),t||(t=i,r()),n=i}}},function(t,n,r){var e=r(6),i=r(2),o=function(t,n){if(i(t),!e(n)&&null!==n)throw TypeError(n+": can't set as prototype!")};t.exports={set:Object.setPrototypeOf||("__proto__"in{}?function(t,n,e){try{e=r(53)(Function.call,r(31).f(Object.prototype,"__proto__").set,2),e(t,[]),n=!(t instanceof Array)}catch(t){n=!0}return function(t,r){return o(t,r),n?t.__proto__=r:e(t,r),t}}({},!1):void 0),check:o}},function(t,n,r){var e=r(126)("keys"),i=r(76);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var e=r(2),i=r(26),o=r(7)("species");t.exports=function(t,n){var r,u=e(t).constructor;return void 0===u||void 0==(r=e(u)[o])?n:i(r)}},function(t,n,r){var e=r(67),i=r(46);t.exports=function(t){return function(n,r){var o,u,c=String(i(n)),f=e(r),a=c.length;return f<0||f>=a?t?"":void 0:(o=c.charCodeAt(f),o<55296||o>56319||f+1===a||(u=c.charCodeAt(f+1))<56320||u>57343?t?c.charAt(f):o:t?c.slice(f,f+2):u-56320+(o-55296<<10)+65536)}}},function(t,n,r){var e=r(122),i=r(46);t.exports=function(t,n,r){if(e(n))throw TypeError("String#"+r+" doesn't accept regex!");return String(i(t))}},function(t,n,r){"use strict";var e=r(67),i=r(46);t.exports=function(t){var n=String(i(this)),r="",o=e(t);if(o<0||o==1/0)throw RangeError("Count can't be negative");for(;o>0;(o>>>=1)&&(n+=n))1&o&&(r+=n);return r}},function(t,n){t.exports="\t\n\v\f\r   ᠎             　\u2028\u2029\ufeff"},function(t,n,r){var e,i,o,u=r(53),c=r(121),f=r(135),a=r(132),s=r(3),l=s.process,h=s.setImmediate,v=s.clearImmediate,p=s.MessageChannel,d=0,y={},g="onreadystatechange",b=function(){var t=+this;if(y.hasOwnProperty(t)){var n=y[t];delete y[t],n()}},m=function(t){b.call(t.data)};h&&v||(h=function(t){for(var n=[],r=1;arguments.length>r;)n.push(arguments[r++]);return y[++d]=function(){c("function"==typeof t?t:Function(t),n)},e(d),d},v=function(t){delete y[t]},"process"==r(45)(l)?e=function(t){l.nextTick(u(b,t,1))}:p?(i=new p,o=i.port2,i.port1.onmessage=m,e=u(o.postMessage,o,1)):s.addEventListener&&"function"==typeof postMessage&&!s.importScripts?(e=function(t){s.postMessage(t+"","*")},s.addEventListener("message",m,!1)):e=g in a("script")?function(t){f.appendChild(a("script"))[g]=function(){f.removeChild(this),b.call(t)}}:function(t){setTimeout(u(b,t,1),0)}),t.exports={set:h,clear:v}},function(t,n,r){"use strict";var e=r(3),i=r(10),o=r(69),u=r(127),c=r(27),f=r(73),a=r(4),s=r(68),l=r(67),h=r(16),v=r(71).f,p=r(11).f,d=r(130),y=r(81),g="ArrayBuffer",b="DataView",m="prototype",x="Wrong length!",w="Wrong index!",S=e[g],_=e[b],O=e.Math,E=e.RangeError,P=e.Infinity,j=S,F=O.abs,M=O.pow,A=O.floor,N=O.log,T=O.LN2,I="buffer",k="byteLength",L="byteOffset",R=i?"_b":I,C=i?"_l":k,D=i?"_o":L,U=function(t,n,r){var e,i,o,u=Array(r),c=8*r-n-1,f=(1<<c)-1,a=f>>1,s=23===n?M(2,-24)-M(2,-77):0,l=0,h=t<0||0===t&&1/t<0?1:0;for(t=F(t),t!=t||t===P?(i=t!=t?1:0,e=f):(e=A(N(t)/T),t*(o=M(2,-e))<1&&(e--,o*=2),t+=e+a>=1?s/o:s*M(2,1-a),t*o>=2&&(e++,o/=2),e+a>=f?(i=0,e=f):e+a>=1?(i=(t*o-1)*M(2,n),e+=a):(i=t*M(2,a-1)*M(2,n),e=0));n>=8;u[l++]=255&i,i/=256,n-=8);for(e=e<<n|i,c+=n;c>0;u[l++]=255&e,e/=256,c-=8);return u[--l]|=128*h,u},W=function(t,n,r){var e,i=8*r-n-1,o=(1<<i)-1,u=o>>1,c=i-7,f=r-1,a=t[f--],s=127&a;for(a>>=7;c>0;s=256*s+t[f],f--,c-=8);for(e=s&(1<<-c)-1,s>>=-c,c+=n;c>0;e=256*e+t[f],f--,c-=8);if(0===s)s=1-u;else{if(s===o)return e?NaN:a?-P:P;e+=M(2,n),s-=u}return(a?-1:1)*e*M(2,s-n)},G=function(t){return t[3]<<24|t[2]<<16|t[1]<<8|t[0]},B=function(t){return[255&t]},V=function(t){return[255&t,t>>8&255]},z=function(t){return[255&t,t>>8&255,t>>16&255,t>>24&255]},q=function(t){return U(t,52,8)},K=function(t){return U(t,23,4)},J=function(t,n,r){p(t[m],n,{get:function(){return this[r]}})},Y=function(t,n,r,e){var i=+r,o=l(i);if(i!=o||o<0||o+n>t[C])throw E(w);var u=t[R]._b,c=o+t[D],f=u.slice(c,c+n);return e?f:f.reverse()},H=function(t,n,r,e,i,o){var u=+r,c=l(u);if(u!=c||c<0||c+n>t[C])throw E(w);for(var f=t[R]._b,a=c+t[D],s=e(+i),h=0;h<n;h++)f[a+h]=s[o?h:n-h-1]},$=function(t,n){s(t,S,g);var r=+n,e=h(r);if(r!=e)throw E(x);return e};if(u.ABV){if(!a(function(){new S})||!a(function(){new S(.5)})){S=function(t){return new j($(this,t))};for(var X,Q=S[m]=j[m],Z=v(j),tt=0;Z.length>tt;)(X=Z[tt++])in S||c(S,X,j[X]);o||(Q.constructor=S)}var nt=new _(new S(2)),rt=_[m].setInt8;nt.setInt8(0,2147483648),nt.setInt8(1,2147483649),!nt.getInt8(0)&&nt.getInt8(1)||f(_[m],{setInt8:function(t,n){rt.call(this,t,n<<24>>24)},setUint8:function(t,n){rt.call(this,t,n<<24>>24)}},!0)}else S=function(t){var n=$(this,t);this._b=d.call(Array(n),0),this[C]=n},_=function(t,n,r){s(this,_,b),s(t,S,b);var e=t[C],i=l(n);if(i<0||i>e)throw E("Wrong offset!");if(r=void 0===r?e-i:h(r),i+r>e)throw E(x);this[R]=t,this[D]=i,this[C]=r},i&&(J(S,k,"_l"),J(_,I,"_b"),J(_,k,"_l"),J(_,L,"_o")),f(_[m],{getInt8:function(t){return Y(this,1,t)[0]<<24>>24},getUint8:function(t){return Y(this,1,t)[0]},getInt16:function(t){var n=Y(this,2,t,arguments[1]);return(n[1]<<8|n[0])<<16>>16},getUint16:function(t){var n=Y(this,2,t,arguments[1]);return n[1]<<8|n[0]},getInt32:function(t){return G(Y(this,4,t,arguments[1]))},getUint32:function(t){return G(Y(this,4,t,arguments[1]))>>>0},getFloat32:function(t){return W(Y(this,4,t,arguments[1]),23,4)},getFloat64:function(t){return W(Y(this,8,t,arguments[1]),52,8)},setInt8:function(t,n){H(this,1,t,B,n)},setUint8:function(t,n){H(this,1,t,B,n)},setInt16:function(t,n){H(this,2,t,V,n,arguments[2])},setUint16:function(t,n){H(this,2,t,V,n,arguments[2])},setInt32:function(t,n){H(this,4,t,z,n,arguments[2])},setUint32:function(t,n){H(this,4,t,z,n,arguments[2])},setFloat32:function(t,n){H(this,4,t,K,n,arguments[2])},setFloat64:function(t,n){H(this,8,t,q,n,arguments[2])}});y(S,g),y(_,b),c(_[m],u.VIEW,!0),n[g]=S,n[b]=_},function(t,n,r){var e=r(3),i=r(52),o=r(69),u=r(182),c=r(11).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){var e=r(114),i=r(7)("iterator"),o=r(80);t.exports=r(52).getIteratorMethod=function(t){if(void 0!=t)return t[i]||t["@@iterator"]||o[e(t)]}},function(t,n,r){"use strict";var e=r(78),i=r(170),o=r(80),u=r(30);t.exports=r(140)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):"keys"==n?i(0,r):"values"==n?i(0,t[r]):i(0,[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){function r(t,n){t.classList?t.classList.add(n):t.className+=" "+n}t.exports=r},function(t,n){function r(t,n){if(t.classList)t.classList.remove(n);else{var r=new RegExp("(^|\\b)"+n.split(" ").join("|")+"(\\b|$)","gi");t.className=t.className.replace(r," ")}}t.exports=r},function(t,n){function r(){throw new Error("setTimeout has not been defined")}function e(){throw new Error("clearTimeout has not been defined")}function i(t){if(s===setTimeout)return setTimeout(t,0);if((s===r||!s)&&setTimeout)return s=setTimeout,setTimeout(t,0);try{return s(t,0)}catch(n){try{return s.call(null,t,0)}catch(n){return s.call(this,t,0)}}}function o(t){if(l===clearTimeout)return clearTimeout(t);if((l===e||!l)&&clearTimeout)return l=clearTimeout,clearTimeout(t);try{return l(t)}catch(n){try{return l.call(null,t)}catch(n){return l.call(this,t)}}}function u(){d&&v&&(d=!1,v.length?p=v.concat(p):y=-1,p.length&&c())}function c(){if(!d){var t=i(u);d=!0;for(var n=p.length;n;){for(v=p,p=[];++y<n;)v&&v[y].run();y=-1,n=p.length}v=null,d=!1,o(t)}}function f(t,n){this.fun=t,this.array=n}function a(){}var s,l,h=t.exports={};!function(){try{s="function"==typeof setTimeout?setTimeout:r}catch(t){s=r}try{l="function"==typeof clearTimeout?clearTimeout:e}catch(t){l=e}}();var v,p=[],d=!1,y=-1;h.nextTick=function(t){var n=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)n[r-1]=arguments[r];p.push(new f(t,n)),1!==p.length||d||i(c)},f.prototype.run=function(){this.fun.apply(null,this.array)},h.title="browser",h.browser=!0,h.env={},h.argv=[],h.version="",h.versions={},h.on=a,h.addListener=a,h.once=a,h.off=a,h.removeListener=a,h.removeAllListeners=a,h.emit=a,h.prependListener=a,h.prependOnceListener=a,h.listeners=function(t){return[]},h.binding=function(t){throw new Error("process.binding is not supported")},h.cwd=function(){return"/"},h.chdir=function(t){throw new Error("process.chdir is not supported")},h.umask=function(){return 0}},function(t,n,r){var e=r(45);t.exports=function(t,n){if("number"!=typeof t&&"Number"!=e(t))throw TypeError(n);return+t}},function(t,n,r){"use strict";var e=r(17),i=r(75),o=r(16);t.exports=[].copyWithin||function(t,n){var r=e(this),u=o(r.length),c=i(t,u),f=i(n,u),a=arguments.length>2?arguments[2]:void 0,s=Math.min((void 0===a?u:i(a,u))-f,u-c),l=1;for(f<c&&c<f+s&&(l=-1,f+=s-1,c+=s-1);s-- >0;)f in r?r[c]=r[f]:delete r[c],c+=l,f+=l;return r}},function(t,n,r){var e=r(79);t.exports=function(t,n){var r=[];return e(t,!1,r.push,r,n),r}},function(t,n,r){var e=r(26),i=r(17),o=r(115),u=r(16);t.exports=function(t,n,r,c,f){e(n);var a=i(t),s=o(a),l=u(a.length),h=f?l-1:0,v=f?-1:1;if(r<2)for(;;){if(h in s){c=s[h],h+=v;break}if(h+=v,f?h<0:l<=h)throw TypeError("Reduce of empty array with no initial value")}for(;f?h>=0:l>h;h+=v)h in s&&(c=n(c,s[h],h,a));return c}},function(t,n,r){"use strict";var e=r(26),i=r(6),o=r(121),u=[].slice,c={},f=function(t,n,r){if(!(n in c)){for(var e=[],i=0;i<n;i++)e[i]="a["+i+"]";c[n]=Function("F,a","return new F("+e.join(",")+")")}return c[n](t,r)};t.exports=Function.bind||function(t){var n=e(this),r=u.call(arguments,1),c=function(){var e=r.concat(u.call(arguments));return this instanceof c?f(n,e.length,e):o(n,e,t)};return i(n.prototype)&&(c.prototype=n.prototype),c}},function(t,n,r){"use strict";var e=r(11).f,i=r(70),o=r(73),u=r(53),c=r(68),f=r(46),a=r(79),s=r(140),l=r(170),h=r(74),v=r(10),p=r(65).fastKey,d=v?"_s":"size",y=function(t,n){var r,e=p(n);if("F"!==e)return t._i[e];for(r=t._f;r;r=r.n)if(r.k==n)return r};t.exports={getConstructor:function(t,n,r,s){var l=t(function(t,e){c(t,l,n,"_i"),t._i=i(null),t._f=void 0,t._l=void 0,t[d]=0,void 0!=e&&a(e,r,t[s],t)});return o(l.prototype,{clear:function(){for(var t=this,n=t._i,r=t._f;r;r=r.n)r.r=!0,r.p&&(r.p=r.p.n=void 0),delete n[r.i];t._f=t._l=void 0,t[d]=0},delete:function(t){var n=this,r=y(n,t);if(r){var e=r.n,i=r.p;delete n._i[r.i],r.r=!0,i&&(i.n=e),e&&(e.p=i),n._f==r&&(n._f=e),n._l==r&&(n._l=i),n[d]--}return!!r},forEach:function(t){c(this,l,"forEach");for(var n,r=u(t,arguments.length>1?arguments[1]:void 0,3);n=n?n.n:this._f;)for(r(n.v,n.k,this);n&&n.r;)n=n.p},has:function(t){return!!y(this,t)}}),v&&e(l.prototype,"size",{get:function(){return f(this[d])}}),l},def:function(t,n,r){var e,i,o=y(t,n);return o?o.v=r:(t._l=o={i:i=p(n,!0),k:n,v:r,p:e=t._l,n:void 0,r:!1},t._f||(t._f=o),e&&(e.n=o),t[d]++,"F"!==i&&(t._i[i]=o)),t},getEntry:y,setStrong:function(t,n,r){s(t,n,function(t,n){this._t=t,this._k=n,this._l=void 0},function(){for(var t=this,n=t._k,r=t._l;r&&r.r;)r=r.p;return t._t&&(t._l=r=r?r.n:t._t._f)?"keys"==n?l(0,r.k):"values"==n?l(0,r.v):l(0,[r.k,r.v]):(t._t=void 0,l(1))},r?"entries":"values",!r,!0),h(n)}}},function(t,n,r){var e=r(114),i=r(161);t.exports=function(t){return function(){if(e(this)!=t)throw TypeError(t+"#toJSON isn't generic");return i(this)}}},function(t,n,r){"use strict";var e=r(73),i=r(65).getWeak,o=r(2),u=r(6),c=r(68),f=r(79),a=r(48),s=r(24),l=a(5),h=a(6),v=0,p=function(t){return t._l||(t._l=new d)},d=function(){this.a=[]},y=function(t,n){return l(t.a,function(t){return t[0]===n})};d.prototype={get:function(t){var n=y(this,t);if(n)return n[1]},has:function(t){return!!y(this,t)},set:function(t,n){var r=y(this,t);r?r[1]=n:this.a.push([t,n])},delete:function(t){var n=h(this.a,function(n){return n[0]===t});return~n&&this.a.splice(n,1),!!~n}},t.exports={getConstructor:function(t,n,r,o){var a=t(function(t,e){c(t,a,n,"_i"),t._i=v++,t._l=void 0,void 0!=e&&f(e,r,t[o],t)});return e(a.prototype,{delete:function(t){if(!u(t))return!1;var n=i(t);return!0===n?p(this).delete(t):n&&s(n,this._i)&&delete n[this._i]},has:function(t){if(!u(t))return!1;var n=i(t);return!0===n?p(this).has(t):n&&s(n,this._i)}}),a},def:function(t,n,r){var e=i(o(n),!0);return!0===e?p(t).set(n,r):e[t._i]=r,t},ufstore:p}},function(t,n,r){t.exports=!r(10)&&!r(4)(function(){return 7!=Object.defineProperty(r(132)("div"),"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(6),i=Math.floor;t.exports=function(t){return!e(t)&&isFinite(t)&&i(t)===t}},function(t,n,r){var e=r(2);t.exports=function(t,n,r,i){try{return i?n(e(r)[0],r[1]):n(r)}catch(n){var o=t.return;throw void 0!==o&&e(o.call(t)),n}}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n){t.exports=Math.log1p||function(t){return(t=+t)>-1e-8&&t<1e-8?t-t*t/2:Math.log(1+t)}},function(t,n,r){"use strict";var e=r(72),i=r(125),o=r(116),u=r(17),c=r(115),f=Object.assign;t.exports=!f||r(4)(function(){var t={},n={},r=Symbol(),e="abcdefghijklmnopqrst";return t[r]=7,e.split("").forEach(function(t){n[t]=t}),7!=f({},t)[r]||Object.keys(f({},n)).join("")!=e})?function(t,n){for(var r=u(t),f=arguments.length,a=1,s=i.f,l=o.f;f>a;)for(var h,v=c(arguments[a++]),p=s?e(v).concat(s(v)):e(v),d=p.length,y=0;d>y;)l.call(v,h=p[y++])&&(r[h]=v[h]);return r}:f},function(t,n,r){var e=r(11),i=r(2),o=r(72);t.exports=r(10)?Object.defineProperties:function(t,n){i(t);for(var r,u=o(n),c=u.length,f=0;c>f;)e.f(t,r=u[f++],n[r]);return t}},function(t,n,r){var e=r(30),i=r(71).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],c=function(t){try{return i(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?c(t):i(e(t))}},function(t,n,r){var e=r(24),i=r(30),o=r(117)(!1),u=r(145)("IE_PROTO");t.exports=function(t,n){var r,c=i(t),f=0,a=[];for(r in c)r!=u&&e(c,r)&&a.push(r);for(;n.length>f;)e(c,r=n[f++])&&(~o(a,r)||a.push(r));return a}},function(t,n,r){var e=r(72),i=r(30),o=r(116).f;t.exports=function(t){return function(n){for(var r,u=i(n),c=e(u),f=c.length,a=0,s=[];f>a;)o.call(u,r=c[a++])&&s.push(t?[r,u[r]]:u[r]);return s}}},function(t,n,r){var e=r(71),i=r(125),o=r(2),u=r(3).Reflect;t.exports=u&&u.ownKeys||function(t){var n=e.f(o(t)),r=i.f;return r?n.concat(r(t)):n}},function(t,n,r){var e=r(3).parseFloat,i=r(82).trim;t.exports=1/e(r(150)+"-0")!=-1/0?function(t){var n=i(String(t),3),r=e(n);return 0===r&&"-"==n.charAt(0)?-0:r}:e},function(t,n,r){var e=r(3).parseInt,i=r(82).trim,o=r(150),u=/^[\-+]?0[xX]/;t.exports=8!==e(o+"08")||22!==e(o+"0x16")?function(t,n){var r=i(String(t),3);return e(r,n>>>0||(u.test(r)?16:10))}:e},function(t,n){t.exports=Object.is||function(t,n){return t===n?0!==t||1/t==1/n:t!=t&&n!=n}},function(t,n,r){var e=r(16),i=r(149),o=r(46);t.exports=function(t,n,r,u){var c=String(o(t)),f=c.length,a=void 0===r?" ":String(r),s=e(n);if(s<=f||""==a)return c;var l=s-f,h=i.call(a,Math.ceil(l/a.length));return h.length>l&&(h=h.slice(0,l)),u?h+c:c+h}},function(t,n,r){n.f=r(7)},function(t,n,r){"use strict";var e=r(164);t.exports=r(118)("Map",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{get:function(t){var n=e.getEntry(this,t);return n&&n.v},set:function(t,n){return e.def(this,0===t?0:t,n)}},e,!0)},function(t,n,r){r(10)&&"g"!=/./g.flags&&r(11).f(RegExp.prototype,"flags",{configurable:!0,get:r(120)})},function(t,n,r){"use strict";var e=r(164);t.exports=r(118)("Set",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function(t){return e.def(this,t=0===t?0:t,t)}},e)},function(t,n,r){"use strict";var e,i=r(48)(0),o=r(28),u=r(65),c=r(172),f=r(166),a=r(6),s=u.getWeak,l=Object.isExtensible,h=f.ufstore,v={},p=function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},d={get:function(t){if(a(t)){var n=s(t);return!0===n?h(this).get(t):n?n[this._i]:void 0}},set:function(t,n){return f.def(this,t,n)}},y=t.exports=r(118)("WeakMap",p,d,f,!0,!0);7!=(new y).set((Object.freeze||Object)(v),7).get(v)&&(e=f.getConstructor(p),c(e.prototype,d),u.NEED=!0,i(["delete","has","get","set"],function(t){var n=y.prototype,r=n[t];o(n,t,function(n,i){if(a(n)&&!l(n)){this._f||(this._f=new e);var o=this._f[t](n,i);return"set"==t?this:o}return r.call(this,n,i)})}))},,,,function(t,n){"use strict";function r(){var t=document.querySelector("#page-nav");if(t&&!document.querySelector("#page-nav .extend.prev")&&(t.innerHTML='<a class="extend prev disabled" rel="prev">&laquo; Prev</a>'+t.innerHTML),t&&!document.querySelector("#page-nav .extend.next")&&(t.innerHTML=t.innerHTML+'<a class="extend next disabled" rel="next">Next &raquo;</a>'),yiliaConfig&&yiliaConfig.open_in_new){document.querySelectorAll(".article-entry a:not(.article-more-a)").forEach(function(t){var n=t.getAttribute("target");n&&""!==n||t.setAttribute("target","_blank")})}if(yiliaConfig&&yiliaConfig.toc_hide_index){document.querySelectorAll(".toc-number").forEach(function(t){t.style.display="none"})}var n=document.querySelector("#js-aboutme");n&&0!==n.length&&(n.innerHTML=n.innerText)}t.exports={init:r}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}function i(t,n){var r=/\/|index.html/g;return t.replace(r,"")===n.replace(r,"")}function o(){for(var t=document.querySelectorAll(".js-header-menu li a"),n=window.location.pathname,r=0,e=t.length;r<e;r++){var o=t[r];i(n,o.getAttribute("href"))&&(0,h.default)(o,"active")}}function u(t){for(var n=t.offsetLeft,r=t.offsetParent;null!==r;)n+=r.offsetLeft,r=r.offsetParent;return n}function c(t){for(var n=t.offsetTop,r=t.offsetParent;null!==r;)n+=r.offsetTop,r=r.offsetParent;return n}function f(t,n,r,e,i){var o=u(t),f=c(t)-n;if(f-r<=i){var a=t.$newDom;a||(a=t.cloneNode(!0),(0,d.default)(t,a),t.$newDom=a,a.style.position="fixed",a.style.top=(r||f)+"px",a.style.left=o+"px",a.style.zIndex=e||2,a.style.width="100%",a.style.color="#fff"),a.style.visibility="visible",t.style.visibility="hidden"}else{t.style.visibility="visible";var s=t.$newDom;s&&(s.style.visibility="hidden")}}function a(){var t=document.querySelector(".js-overlay"),n=document.querySelector(".js-header-menu");f(t,document.body.scrollTop,-63,2,0),f(n,document.body.scrollTop,1,3,0)}function s(){document.querySelector("#container").addEventListener("scroll",function(t){a()}),window.addEventListener("scroll",function(t){a()}),a()}var l=r(156),h=e(l),v=r(157),p=(e(v),r(382)),d=e(p),y=r(128),g=e(y),b=r(190),m=e(b),x=r(129);(function(){g.default.versions.mobile&&window.screen.width<800&&(o(),s())})(),(0,x.addLoadEvent)(function(){m.default.init()}),t.exports={}},,,,function(t,n,r){(function(t){"use strict";function n(t,n,r){t[n]||Object[e](t,n,{writable:!0,configurable:!0,value:r})}if(r(381),r(391),r(198),t._babelPolyfill)throw new Error("only one instance of babel-polyfill is allowed");t._babelPolyfill=!0;var e="defineProperty";n(String.prototype,"padLeft","".padStart),n(String.prototype,"padRight","".padEnd),"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function(t){[][t]&&n(Array,t,Function.call.bind([][t]))})}).call(n,function(){return this}())},,,function(t,n,r){r(210),t.exports=r(52).RegExp.escape},,,,function(t,n,r){var e=r(6),i=r(138),o=r(7)("species");t.exports=function(t){var n;return i(t)&&(n=t.constructor,"function"!=typeof n||n!==Array&&!i(n.prototype)||(n=void 0),e(n)&&null===(n=n[o])&&(n=void 0)),void 0===n?Array:n}},function(t,n,r){var e=r(202);t.exports=function(t,n){return new(e(t))(n)}},function(t,n,r){"use strict";var e=r(2),i=r(50),o="number";t.exports=function(t){if("string"!==t&&t!==o&&"default"!==t)throw TypeError("Incorrect hint");return i(e(this),t!=o)}},function(t,n,r){var e=r(72),i=r(125),o=r(116);t.exports=function(t){var n=e(t),r=i.f;if(r)for(var u,c=r(t),f=o.f,a=0;c.length>a;)f.call(t,u=c[a++])&&n.push(u);return n}},function(t,n,r){var e=r(72),i=r(30);t.exports=function(t,n){for(var r,o=i(t),u=e(o),c=u.length,f=0;c>f;)if(o[r=u[f++]]===n)return r}},function(t,n,r){"use strict";var e=r(208),i=r(121),o=r(26);t.exports=function(){for(var t=o(this),n=arguments.length,r=Array(n),u=0,c=e._,f=!1;n>u;)(r[u]=arguments[u++])===c&&(f=!0);return function(){var e,o=this,u=arguments.length,a=0,s=0;if(!f&&!u)return i(t,r,o);if(e=r.slice(),f)for(;n>a;a++)e[a]===c&&(e[a]=arguments[s++]);for(;u>s;)e.push(arguments[s++]);return i(t,e,o)}}},function(t,n,r){t.exports=r(3)},function(t,n){t.exports=function(t,n){var r=n===Object(n)?function(t){return n[t]}:n;return function(n){return String(n).replace(t,r)}}},function(t,n,r){var e=r(1),i=r(209)(/[\\^$*+?.()|[\]{}]/g,"\\$&");e(e.S,"RegExp",{escape:function(t){return i(t)}})},function(t,n,r){var e=r(1);e(e.P,"Array",{copyWithin:r(160)}),r(78)("copyWithin")},function(t,n,r){"use strict";var e=r(1),i=r(48)(4);e(e.P+e.F*!r(47)([].every,!0),"Array",{every:function(t){return i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.P,"Array",{fill:r(130)}),r(78)("fill")},function(t,n,r){"use strict";var e=r(1),i=r(48)(2);e(e.P+e.F*!r(47)([].filter,!0),"Array",{filter:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(6),o="findIndex",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{findIndex:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)(o)},function(t,n,r){"use strict";var e=r(1),i=r(48)(5),o="find",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{find:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)(o)},function(t,n,r){"use strict";var e=r(1),i=r(48)(0),o=r(47)([].forEach,!0);e(e.P+e.F*!o,"Array",{forEach:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(53),i=r(1),o=r(17),u=r(169),c=r(137),f=r(16),a=r(131),s=r(154);i(i.S+i.F*!r(123)(function(t){Array.from(t)}),"Array",{from:function(t){var n,r,i,l,h=o(t),v="function"==typeof this?this:Array,p=arguments.length,d=p>1?arguments[1]:void 0,y=void 0!==d,g=0,b=s(h);if(y&&(d=e(d,p>2?arguments[2]:void 0,2)),void 0==b||v==Array&&c(b))for(n=f(h.length),r=new v(n);n>g;g++)a(r,g,y?d(h[g],g):h[g]);else for(l=b.call(h),r=new v;!(i=l.next()).done;g++)a(r,g,y?u(l,d,[i.value,g],!0):i.value);return r.length=g,r}})},function(t,n,r){"use strict";var e=r(1),i=r(117)(!1),o=[].indexOf,u=!!o&&1/[1].indexOf(1,-0)<0;e(e.P+e.F*(u||!r(47)(o)),"Array",{indexOf:function(t){return u?o.apply(this,arguments)||0:i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.S,"Array",{isArray:r(138)})},function(t,n,r){"use strict";var e=r(1),i=r(30),o=[].join;e(e.P+e.F*(r(115)!=Object||!r(47)(o)),"Array",{join:function(t){return o.call(i(this),void 0===t?",":t)}})},function(t,n,r){"use strict";var e=r(1),i=r(30),o=r(67),u=r(16),c=[].lastIndexOf,f=!!c&&1/[1].lastIndexOf(1,-0)<0;e(e.P+e.F*(f||!r(47)(c)),"Array",{lastIndexOf:function(t){if(f)return c.apply(this,arguments)||0;var n=i(this),r=u(n.length),e=r-1;for(arguments.length>1&&(e=Math.min(e,o(arguments[1]))),e<0&&(e=r+e);e>=0;e--)if(e in n&&n[e]===t)return e||0;return-1}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(1);e(e.P+e.F*!r(47)([].map,!0),"Array",{map:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(131);e(e.S+e.F*r(4)(function(){function t(){}return!(Array.of.call(t)instanceof t)}),"Array",{of:function(){for(var t=0,n=arguments.length,r=new("function"==typeof this?this:Array)(n);n>t;)i(r,t,arguments[t++]);return r.length=n,r}})},function(t,n,r){"use strict";var e=r(1),i=r(162);e(e.P+e.F*!r(47)([].reduceRight,!0),"Array",{reduceRight:function(t){return i(this,t,arguments.length,arguments[1],!0)}})},function(t,n,r){"use strict";var e=r(1),i=r(162);e(e.P+e.F*!r(47)([].reduce,!0),"Array",{reduce:function(t){return i(this,t,arguments.length,arguments[1],!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(135),o=r(45),u=r(75),c=r(16),f=[].slice;e(e.P+e.F*r(4)(function(){i&&f.call(i)}),"Array",{slice:function(t,n){var r=c(this.length),e=o(this);if(n=void 0===n?r:n,"Array"==e)return f.call(this,t,n);for(var i=u(t,r),a=u(n,r),s=c(a-i),l=Array(s),h=0;h<s;h++)l[h]="String"==e?this.charAt(i+h):this[i+h];return l}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(3);e(e.P+e.F*!r(47)([].some,!0),"Array",{some:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(26),o=r(17),u=r(4),c=[].sort,f=[1,2,3];e(e.P+e.F*(u(function(){f.sort(void 0)})||!u(function(){f.sort(null)})||!r(47)(c)),"Array",{sort:function(t){return void 0===t?c.call(o(this)):c.call(o(this),i(t))}})},function(t,n,r){r(74)("Array")},function(t,n,r){var e=r(1);e(e.S,"Date",{now:function(){return(new Date).getTime()}})},function(t,n,r){"use strict";var e=r(1),i=r(4),o=Date.prototype.getTime,u=function(t){return t>9?t:"0"+t};e(e.P+e.F*(i(function(){return"0385-07-25T07:06:39.999Z"!=new Date(-5e13-1).toISOString()})||!i(function(){new Date(NaN).toISOString()})),"Date",{toISOString:function(){
if(!isFinite(o.call(this)))throw RangeError("Invalid time value");var t=this,n=t.getUTCFullYear(),r=t.getUTCMilliseconds(),e=n<0?"-":n>9999?"+":"";return e+("00000"+Math.abs(n)).slice(e?-6:-4)+"-"+u(t.getUTCMonth()+1)+"-"+u(t.getUTCDate())+"T"+u(t.getUTCHours())+":"+u(t.getUTCMinutes())+":"+u(t.getUTCSeconds())+"."+(r>99?r:"0"+u(r))+"Z"}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50);e(e.P+e.F*r(4)(function(){return null!==new Date(NaN).toJSON()||1!==Date.prototype.toJSON.call({toISOString:function(){return 1}})}),"Date",{toJSON:function(t){var n=i(this),r=o(n);return"number"!=typeof r||isFinite(r)?n.toISOString():null}})},function(t,n,r){var e=r(7)("toPrimitive"),i=Date.prototype;e in i||r(27)(i,e,r(204))},function(t,n,r){var e=Date.prototype,i="Invalid Date",o="toString",u=e[o],c=e.getTime;new Date(NaN)+""!=i&&r(28)(e,o,function(){var t=c.call(this);return t===t?u.call(this):i})},function(t,n,r){var e=r(1);e(e.P,"Function",{bind:r(163)})},function(t,n,r){"use strict";var e=r(6),i=r(32),o=r(7)("hasInstance"),u=Function.prototype;o in u||r(11).f(u,o,{value:function(t){if("function"!=typeof this||!e(t))return!1;if(!e(this.prototype))return t instanceof this;for(;t=i(t);)if(this.prototype===t)return!0;return!1}})},function(t,n,r){var e=r(11).f,i=r(66),o=r(24),u=Function.prototype,c="name",f=Object.isExtensible||function(){return!0};c in u||r(10)&&e(u,c,{configurable:!0,get:function(){try{var t=this,n=(""+t).match(/^\s*function ([^ (]*)/)[1];return o(t,c)||!f(t)||e(t,c,i(5,n)),n}catch(t){return""}}})},function(t,n,r){var e=r(1),i=r(171),o=Math.sqrt,u=Math.acosh;e(e.S+e.F*!(u&&710==Math.floor(u(Number.MAX_VALUE))&&u(1/0)==1/0),"Math",{acosh:function(t){return(t=+t)<1?NaN:t>94906265.62425156?Math.log(t)+Math.LN2:i(t-1+o(t-1)*o(t+1))}})},function(t,n,r){function e(t){return isFinite(t=+t)&&0!=t?t<0?-e(-t):Math.log(t+Math.sqrt(t*t+1)):t}var i=r(1),o=Math.asinh;i(i.S+i.F*!(o&&1/o(0)>0),"Math",{asinh:e})},function(t,n,r){var e=r(1),i=Math.atanh;e(e.S+e.F*!(i&&1/i(-0)<0),"Math",{atanh:function(t){return 0==(t=+t)?t:Math.log((1+t)/(1-t))/2}})},function(t,n,r){var e=r(1),i=r(142);e(e.S,"Math",{cbrt:function(t){return i(t=+t)*Math.pow(Math.abs(t),1/3)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{clz32:function(t){return(t>>>=0)?31-Math.floor(Math.log(t+.5)*Math.LOG2E):32}})},function(t,n,r){var e=r(1),i=Math.exp;e(e.S,"Math",{cosh:function(t){return(i(t=+t)+i(-t))/2}})},function(t,n,r){var e=r(1),i=r(141);e(e.S+e.F*(i!=Math.expm1),"Math",{expm1:i})},function(t,n,r){var e=r(1),i=r(142),o=Math.pow,u=o(2,-52),c=o(2,-23),f=o(2,127)*(2-c),a=o(2,-126),s=function(t){return t+1/u-1/u};e(e.S,"Math",{fround:function(t){var n,r,e=Math.abs(t),o=i(t);return e<a?o*s(e/a/c)*a*c:(n=(1+c/u)*e,r=n-(n-e),r>f||r!=r?o*(1/0):o*r)}})},function(t,n,r){var e=r(1),i=Math.abs;e(e.S,"Math",{hypot:function(t,n){for(var r,e,o=0,u=0,c=arguments.length,f=0;u<c;)r=i(arguments[u++]),f<r?(e=f/r,o=o*e*e+1,f=r):r>0?(e=r/f,o+=e*e):o+=r;return f===1/0?1/0:f*Math.sqrt(o)}})},function(t,n,r){var e=r(1),i=Math.imul;e(e.S+e.F*r(4)(function(){return-5!=i(4294967295,5)||2!=i.length}),"Math",{imul:function(t,n){var r=65535,e=+t,i=+n,o=r&e,u=r&i;return 0|o*u+((r&e>>>16)*u+o*(r&i>>>16)<<16>>>0)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log10:function(t){return Math.log(t)/Math.LN10}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log1p:r(171)})},function(t,n,r){var e=r(1);e(e.S,"Math",{log2:function(t){return Math.log(t)/Math.LN2}})},function(t,n,r){var e=r(1);e(e.S,"Math",{sign:r(142)})},function(t,n,r){var e=r(1),i=r(141),o=Math.exp;e(e.S+e.F*r(4)(function(){return-2e-17!=!Math.sinh(-2e-17)}),"Math",{sinh:function(t){return Math.abs(t=+t)<1?(i(t)-i(-t))/2:(o(t-1)-o(-t-1))*(Math.E/2)}})},function(t,n,r){var e=r(1),i=r(141),o=Math.exp;e(e.S,"Math",{tanh:function(t){var n=i(t=+t),r=i(-t);return n==1/0?1:r==1/0?-1:(n-r)/(o(t)+o(-t))}})},function(t,n,r){var e=r(1);e(e.S,"Math",{trunc:function(t){return(t>0?Math.floor:Math.ceil)(t)}})},function(t,n,r){"use strict";var e=r(3),i=r(24),o=r(45),u=r(136),c=r(50),f=r(4),a=r(71).f,s=r(31).f,l=r(11).f,h=r(82).trim,v="Number",p=e[v],d=p,y=p.prototype,g=o(r(70)(y))==v,b="trim"in String.prototype,m=function(t){var n=c(t,!1);if("string"==typeof n&&n.length>2){n=b?n.trim():h(n,3);var r,e,i,o=n.charCodeAt(0);if(43===o||45===o){if(88===(r=n.charCodeAt(2))||120===r)return NaN}else if(48===o){switch(n.charCodeAt(1)){case 66:case 98:e=2,i=49;break;case 79:case 111:e=8,i=55;break;default:return+n}for(var u,f=n.slice(2),a=0,s=f.length;a<s;a++)if((u=f.charCodeAt(a))<48||u>i)return NaN;return parseInt(f,e)}}return+n};if(!p(" 0o1")||!p("0b1")||p("+0x1")){p=function(t){var n=arguments.length<1?0:t,r=this;return r instanceof p&&(g?f(function(){y.valueOf.call(r)}):o(r)!=v)?u(new d(m(n)),r,p):m(n)};for(var x,w=r(10)?a(d):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","),S=0;w.length>S;S++)i(d,x=w[S])&&!i(p,x)&&l(p,x,s(d,x));p.prototype=y,y.constructor=p,r(28)(e,v,p)}},function(t,n,r){var e=r(1);e(e.S,"Number",{EPSILON:Math.pow(2,-52)})},function(t,n,r){var e=r(1),i=r(3).isFinite;e(e.S,"Number",{isFinite:function(t){return"number"==typeof t&&i(t)}})},function(t,n,r){var e=r(1);e(e.S,"Number",{isInteger:r(168)})},function(t,n,r){var e=r(1);e(e.S,"Number",{isNaN:function(t){return t!=t}})},function(t,n,r){var e=r(1),i=r(168),o=Math.abs;e(e.S,"Number",{isSafeInteger:function(t){return i(t)&&o(t)<=9007199254740991}})},function(t,n,r){var e=r(1);e(e.S,"Number",{MAX_SAFE_INTEGER:9007199254740991})},function(t,n,r){var e=r(1);e(e.S,"Number",{MIN_SAFE_INTEGER:-9007199254740991})},function(t,n,r){var e=r(1),i=r(178);e(e.S+e.F*(Number.parseFloat!=i),"Number",{parseFloat:i})},function(t,n,r){var e=r(1),i=r(179);e(e.S+e.F*(Number.parseInt!=i),"Number",{parseInt:i})},function(t,n,r){"use strict";var e=r(1),i=r(67),o=r(159),u=r(149),c=1..toFixed,f=Math.floor,a=[0,0,0,0,0,0],s="Number.toFixed: incorrect invocation!",l="0",h=function(t,n){for(var r=-1,e=n;++r<6;)e+=t*a[r],a[r]=e%1e7,e=f(e/1e7)},v=function(t){for(var n=6,r=0;--n>=0;)r+=a[n],a[n]=f(r/t),r=r%t*1e7},p=function(){for(var t=6,n="";--t>=0;)if(""!==n||0===t||0!==a[t]){var r=String(a[t]);n=""===n?r:n+u.call(l,7-r.length)+r}return n},d=function(t,n,r){return 0===n?r:n%2==1?d(t,n-1,r*t):d(t*t,n/2,r)},y=function(t){for(var n=0,r=t;r>=4096;)n+=12,r/=4096;for(;r>=2;)n+=1,r/=2;return n};e(e.P+e.F*(!!c&&("0.000"!==8e-5.toFixed(3)||"1"!==.9.toFixed(0)||"1.25"!==1.255.toFixed(2)||"1000000000000000128"!==(0xde0b6b3a7640080).toFixed(0))||!r(4)(function(){c.call({})})),"Number",{toFixed:function(t){var n,r,e,c,f=o(this,s),a=i(t),g="",b=l;if(a<0||a>20)throw RangeError(s);if(f!=f)return"NaN";if(f<=-1e21||f>=1e21)return String(f);if(f<0&&(g="-",f=-f),f>1e-21)if(n=y(f*d(2,69,1))-69,r=n<0?f*d(2,-n,1):f/d(2,n,1),r*=4503599627370496,(n=52-n)>0){for(h(0,r),e=a;e>=7;)h(1e7,0),e-=7;for(h(d(10,e,1),0),e=n-1;e>=23;)v(1<<23),e-=23;v(1<<e),h(1,1),v(2),b=p()}else h(0,r),h(1<<-n,0),b=p()+u.call(l,a);return a>0?(c=b.length,b=g+(c<=a?"0."+u.call(l,a-c)+b:b.slice(0,c-a)+"."+b.slice(c-a))):b=g+b,b}})},function(t,n,r){"use strict";var e=r(1),i=r(4),o=r(159),u=1..toPrecision;e(e.P+e.F*(i(function(){return"1"!==u.call(1,void 0)})||!i(function(){u.call({})})),"Number",{toPrecision:function(t){var n=o(this,"Number#toPrecision: incorrect invocation!");return void 0===t?u.call(n):u.call(n,t)}})},function(t,n,r){var e=r(1);e(e.S+e.F,"Object",{assign:r(172)})},function(t,n,r){var e=r(1);e(e.S,"Object",{create:r(70)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(10),"Object",{defineProperties:r(173)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(10),"Object",{defineProperty:r(11).f})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("freeze",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(30),i=r(31).f;r(49)("getOwnPropertyDescriptor",function(){return function(t,n){return i(e(t),n)}})},function(t,n,r){r(49)("getOwnPropertyNames",function(){return r(174).f})},function(t,n,r){var e=r(17),i=r(32);r(49)("getPrototypeOf",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(6);r(49)("isExtensible",function(t){return function(n){return!!e(n)&&(!t||t(n))}})},function(t,n,r){var e=r(6);r(49)("isFrozen",function(t){return function(n){return!e(n)||!!t&&t(n)}})},function(t,n,r){var e=r(6);r(49)("isSealed",function(t){return function(n){return!e(n)||!!t&&t(n)}})},function(t,n,r){var e=r(1);e(e.S,"Object",{is:r(180)})},function(t,n,r){var e=r(17),i=r(72);r(49)("keys",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("preventExtensions",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("seal",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(1);e(e.S,"Object",{setPrototypeOf:r(144).set})},function(t,n,r){"use strict";var e=r(114),i={};i[r(7)("toStringTag")]="z",i+""!="[object z]"&&r(28)(Object.prototype,"toString",function(){return"[object "+e(this)+"]"},!0)},function(t,n,r){var e=r(1),i=r(178);e(e.G+e.F*(parseFloat!=i),{parseFloat:i})},function(t,n,r){var e=r(1),i=r(179);e(e.G+e.F*(parseInt!=i),{parseInt:i})},function(t,n,r){"use strict";var e,i,o,u=r(69),c=r(3),f=r(53),a=r(114),s=r(1),l=r(6),h=r(26),v=r(68),p=r(79),d=r(146),y=r(151).set,g=r(143)(),b="Promise",m=c.TypeError,x=c.process,w=c[b],x=c.process,S="process"==a(x),_=function(){},O=!!function(){try{var t=w.resolve(1),n=(t.constructor={})[r(7)("species")]=function(t){t(_,_)};return(S||"function"==typeof PromiseRejectionEvent)&&t.then(_)instanceof n}catch(t){}}(),E=function(t,n){return t===n||t===w&&n===o},P=function(t){var n;return!(!l(t)||"function"!=typeof(n=t.then))&&n},j=function(t){return E(w,t)?new F(t):new i(t)},F=i=function(t){var n,r;this.promise=new t(function(t,e){if(void 0!==n||void 0!==r)throw m("Bad Promise constructor");n=t,r=e}),this.resolve=h(n),this.reject=h(r)},M=function(t){try{t()}catch(t){return{error:t}}},A=function(t,n){if(!t._n){t._n=!0;var r=t._c;g(function(){for(var e=t._v,i=1==t._s,o=0;r.length>o;)!function(n){var r,o,u=i?n.ok:n.fail,c=n.resolve,f=n.reject,a=n.domain;try{u?(i||(2==t._h&&I(t),t._h=1),!0===u?r=e:(a&&a.enter(),r=u(e),a&&a.exit()),r===n.promise?f(m("Promise-chain cycle")):(o=P(r))?o.call(r,c,f):c(r)):f(e)}catch(t){f(t)}}(r[o++]);t._c=[],t._n=!1,n&&!t._h&&N(t)})}},N=function(t){y.call(c,function(){var n,r,e,i=t._v;if(T(t)&&(n=M(function(){S?x.emit("unhandledRejection",i,t):(r=c.onunhandledrejection)?r({promise:t,reason:i}):(e=c.console)&&e.error&&e.error("Unhandled promise rejection",i)}),t._h=S||T(t)?2:1),t._a=void 0,n)throw n.error})},T=function(t){if(1==t._h)return!1;for(var n,r=t._a||t._c,e=0;r.length>e;)if(n=r[e++],n.fail||!T(n.promise))return!1;return!0},I=function(t){y.call(c,function(){var n;S?x.emit("rejectionHandled",t):(n=c.onrejectionhandled)&&n({promise:t,reason:t._v})})},k=function(t){var n=this;n._d||(n._d=!0,n=n._w||n,n._v=t,n._s=2,n._a||(n._a=n._c.slice()),A(n,!0))},L=function(t){var n,r=this;if(!r._d){r._d=!0,r=r._w||r;try{if(r===t)throw m("Promise can't be resolved itself");(n=P(t))?g(function(){var e={_w:r,_d:!1};try{n.call(t,f(L,e,1),f(k,e,1))}catch(t){k.call(e,t)}}):(r._v=t,r._s=1,A(r,!1))}catch(t){k.call({_w:r,_d:!1},t)}}};O||(w=function(t){v(this,w,b,"_h"),h(t),e.call(this);try{t(f(L,this,1),f(k,this,1))}catch(t){k.call(this,t)}},e=function(t){this._c=[],this._a=void 0,this._s=0,this._d=!1,this._v=void 0,this._h=0,this._n=!1},e.prototype=r(73)(w.prototype,{then:function(t,n){var r=j(d(this,w));return r.ok="function"!=typeof t||t,r.fail="function"==typeof n&&n,r.domain=S?x.domain:void 0,this._c.push(r),this._a&&this._a.push(r),this._s&&A(this,!1),r.promise},catch:function(t){return this.then(void 0,t)}}),F=function(){var t=new e;this.promise=t,this.resolve=f(L,t,1),this.reject=f(k,t,1)}),s(s.G+s.W+s.F*!O,{Promise:w}),r(81)(w,b),r(74)(b),o=r(52)[b],s(s.S+s.F*!O,b,{reject:function(t){var n=j(this);return(0,n.reject)(t),n.promise}}),s(s.S+s.F*(u||!O),b,{resolve:function(t){if(t instanceof w&&E(t.constructor,this))return t;var n=j(this);return(0,n.resolve)(t),n.promise}}),s(s.S+s.F*!(O&&r(123)(function(t){w.all(t).catch(_)})),b,{all:function(t){var n=this,r=j(n),e=r.resolve,i=r.reject,o=M(function(){var r=[],o=0,u=1;p(t,!1,function(t){var c=o++,f=!1;r.push(void 0),u++,n.resolve(t).then(function(t){f||(f=!0,r[c]=t,--u||e(r))},i)}),--u||e(r)});return o&&i(o.error),r.promise},race:function(t){var n=this,r=j(n),e=r.reject,i=M(function(){p(t,!1,function(t){n.resolve(t).then(r.resolve,e)})});return i&&e(i.error),r.promise}})},function(t,n,r){var e=r(1),i=r(26),o=r(2),u=(r(3).Reflect||{}).apply,c=Function.apply;e(e.S+e.F*!r(4)(function(){u(function(){})}),"Reflect",{apply:function(t,n,r){var e=i(t),f=o(r);return u?u(e,n,f):c.call(e,n,f)}})},function(t,n,r){var e=r(1),i=r(70),o=r(26),u=r(2),c=r(6),f=r(4),a=r(163),s=(r(3).Reflect||{}).construct,l=f(function(){function t(){}return!(s(function(){},[],t)instanceof t)}),h=!f(function(){s(function(){})});e(e.S+e.F*(l||h),"Reflect",{construct:function(t,n){o(t),u(n);var r=arguments.length<3?t:o(arguments[2]);if(h&&!l)return s(t,n,r);if(t==r){switch(n.length){case 0:return new t;case 1:return new t(n[0]);case 2:return new t(n[0],n[1]);case 3:return new t(n[0],n[1],n[2]);case 4:return new t(n[0],n[1],n[2],n[3])}var e=[null];return e.push.apply(e,n),new(a.apply(t,e))}var f=r.prototype,v=i(c(f)?f:Object.prototype),p=Function.apply.call(t,v,n);return c(p)?p:v}})},function(t,n,r){var e=r(11),i=r(1),o=r(2),u=r(50);i(i.S+i.F*r(4)(function(){Reflect.defineProperty(e.f({},1,{value:1}),1,{value:2})}),"Reflect",{defineProperty:function(t,n,r){o(t),n=u(n,!0),o(r);try{return e.f(t,n,r),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(31).f,o=r(2);e(e.S,"Reflect",{deleteProperty:function(t,n){var r=i(o(t),n);return!(r&&!r.configurable)&&delete t[n]}})},function(t,n,r){"use strict";var e=r(1),i=r(2),o=function(t){this._t=i(t),this._i=0;var n,r=this._k=[];for(n in t)r.push(n)};r(139)(o,"Object",function(){var t,n=this,r=n._k;do{if(n._i>=r.length)return{value:void 0,done:!0}}while(!((t=r[n._i++])in n._t));return{value:t,done:!1}}),e(e.S,"Reflect",{enumerate:function(t){return new o(t)}})},function(t,n,r){var e=r(31),i=r(1),o=r(2);i(i.S,"Reflect",{getOwnPropertyDescriptor:function(t,n){return e.f(o(t),n)}})},function(t,n,r){var e=r(1),i=r(32),o=r(2);e(e.S,"Reflect",{getPrototypeOf:function(t){return i(o(t))}})},function(t,n,r){function e(t,n){var r,c,s=arguments.length<3?t:arguments[2];return a(t)===s?t[n]:(r=i.f(t,n))?u(r,"value")?r.value:void 0!==r.get?r.get.call(s):void 0:f(c=o(t))?e(c,n,s):void 0}var i=r(31),o=r(32),u=r(24),c=r(1),f=r(6),a=r(2);c(c.S,"Reflect",{get:e})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{has:function(t,n){return n in t}})},function(t,n,r){var e=r(1),i=r(2),o=Object.isExtensible;e(e.S,"Reflect",{isExtensible:function(t){return i(t),!o||o(t)}})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{ownKeys:r(177)})},function(t,n,r){var e=r(1),i=r(2),o=Object.preventExtensions;e(e.S,"Reflect",{preventExtensions:function(t){i(t);try{return o&&o(t),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(144);i&&e(e.S,"Reflect",{setPrototypeOf:function(t,n){i.check(t,n);try{return i.set(t,n),!0}catch(t){return!1}}})},function(t,n,r){function e(t,n,r){var f,h,v=arguments.length<4?t:arguments[3],p=o.f(s(t),n);if(!p){if(l(h=u(t)))return e(h,n,r,v);p=a(0)}return c(p,"value")?!(!1===p.writable||!l(v)||(f=o.f(v,n)||a(0),f.value=r,i.f(v,n,f),0)):void 0!==p.set&&(p.set.call(v,r),!0)}var i=r(11),o=r(31),u=r(32),c=r(24),f=r(1),a=r(66),s=r(2),l=r(6);f(f.S,"Reflect",{set:e})},function(t,n,r){var e=r(3),i=r(136),o=r(11).f,u=r(71).f,c=r(122),f=r(120),a=e.RegExp,s=a,l=a.prototype,h=/a/g,v=/a/g,p=new a(h)!==h;if(r(10)&&(!p||r(4)(function(){return v[r(7)("match")]=!1,a(h)!=h||a(v)==v||"/a/i"!=a(h,"i")}))){a=function(t,n){var r=this instanceof a,e=c(t),o=void 0===n;return!r&&e&&t.constructor===a&&o?t:i(p?new s(e&&!o?t.source:t,n):s((e=t instanceof a)?t.source:t,e&&o?f.call(t):n),r?this:l,a)};for(var d=u(s),y=0;d.length>y;)!function(t){t in a||o(a,t,{configurable:!0,get:function(){return s[t]},set:function(n){s[t]=n}})}(d[y++]);l.constructor=a,a.prototype=l,r(28)(e,"RegExp",a)}r(74)("RegExp")},function(t,n,r){r(119)("match",1,function(t,n,r){return[function(r){"use strict";var e=t(this),i=void 0==r?void 0:r[n];return void 0!==i?i.call(r,e):new RegExp(r)[n](String(e))},r]})},function(t,n,r){r(119)("replace",2,function(t,n,r){return[function(e,i){"use strict";var o=t(this),u=void 0==e?void 0:e[n];return void 0!==u?u.call(e,o,i):r.call(String(o),e,i)},r]})},function(t,n,r){r(119)("search",1,function(t,n,r){return[function(r){"use strict";var e=t(this),i=void 0==r?void 0:r[n];return void 0!==i?i.call(r,e):new RegExp(r)[n](String(e))},r]})},function(t,n,r){r(119)("split",2,function(t,n,e){"use strict";var i=r(122),o=e,u=[].push,c="split",f="length",a="lastIndex";if("c"=="abbc"[c](/(b)*/)[1]||4!="test"[c](/(?:)/,-1)[f]||2!="ab"[c](/(?:ab)*/)[f]||4!="."[c](/(.?)(.?)/)[f]||"."[c](/()()/)[f]>1||""[c](/.?/)[f]){var s=void 0===/()??/.exec("")[1];e=function(t,n){var r=String(this);if(void 0===t&&0===n)return[];if(!i(t))return o.call(r,t,n);var e,c,l,h,v,p=[],d=(t.ignoreCase?"i":"")+(t.multiline?"m":"")+(t.unicode?"u":"")+(t.sticky?"y":""),y=0,g=void 0===n?4294967295:n>>>0,b=new RegExp(t.source,d+"g");for(s||(e=new RegExp("^"+b.source+"$(?!\\s)",d));(c=b.exec(r))&&!((l=c.index+c[0][f])>y&&(p.push(r.slice(y,c.index)),!s&&c[f]>1&&c[0].replace(e,function(){for(v=1;v<arguments[f]-2;v++)void 0===arguments[v]&&(c[v]=void 0)}),c[f]>1&&c.index<r[f]&&u.apply(p,c.slice(1)),h=c[0][f],y=l,p[f]>=g));)b[a]===c.index&&b[a]++;return y===r[f]?!h&&b.test("")||p.push(""):p.push(r.slice(y)),p[f]>g?p.slice(0,g):p}}else"0"[c](void 0,0)[f]&&(e=function(t,n){return void 0===t&&0===n?[]:o.call(this,t,n)});return[function(r,i){var o=t(this),u=void 0==r?void 0:r[n];return void 0!==u?u.call(r,o,i):e.call(String(o),r,i)},e]})},function(t,n,r){"use strict";r(184);var e=r(2),i=r(120),o=r(10),u="toString",c=/./[u],f=function(t){r(28)(RegExp.prototype,u,t,!0)};r(4)(function(){return"/a/b"!=c.call({source:"a",flags:"b"})})?f(function(){var t=e(this);return"/".concat(t.source,"/","flags"in t?t.flags:!o&&t instanceof RegExp?i.call(t):void 0)}):c.name!=u&&f(function(){return c.call(this)})},function(t,n,r){"use strict";r(29)("anchor",function(t){return function(n){return t(this,"a","name",n)}})},function(t,n,r){"use strict";r(29)("big",function(t){return function(){return t(this,"big","","")}})},function(t,n,r){"use strict";r(29)("blink",function(t){return function(){return t(this,"blink","","")}})},function(t,n,r){"use strict";r(29)("bold",function(t){return function(){return t(this,"b","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(147)(!1);e(e.P,"String",{codePointAt:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),i=r(16),o=r(148),u="endsWith",c=""[u];e(e.P+e.F*r(134)(u),"String",{endsWith:function(t){var n=o(this,t,u),r=arguments.length>1?arguments[1]:void 0,e=i(n.length),f=void 0===r?e:Math.min(i(r),e),a=String(t);return c?c.call(n,a,f):n.slice(f-a.length,f)===a}})},function(t,n,r){"use strict";r(29)("fixed",function(t){return function(){return t(this,"tt","","")}})},function(t,n,r){"use strict";r(29)("fontcolor",function(t){return function(n){return t(this,"font","color",n)}})},function(t,n,r){"use strict";r(29)("fontsize",function(t){return function(n){return t(this,"font","size",n)}})},function(t,n,r){var e=r(1),i=r(75),o=String.fromCharCode,u=String.fromCodePoint;e(e.S+e.F*(!!u&&1!=u.length),"String",{fromCodePoint:function(t){for(var n,r=[],e=arguments.length,u=0;e>u;){if(n=+arguments[u++],i(n,1114111)!==n)throw RangeError(n+" is not a valid code point");r.push(n<65536?o(n):o(55296+((n-=65536)>>10),n%1024+56320))}return r.join("")}})},function(t,n,r){"use strict";var e=r(1),i=r(148),o="includes";e(e.P+e.F*r(134)(o),"String",{includes:function(t){return!!~i(this,t,o).indexOf(t,arguments.length>1?arguments[1]:void 0)}})},function(t,n,r){"use strict";r(29)("italics",function(t){return function(){return t(this,"i","","")}})},function(t,n,r){"use strict";var e=r(147)(!0);r(140)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";r(29)("link",function(t){return function(n){return t(this,"a","href",n)}})},function(t,n,r){var e=r(1),i=r(30),o=r(16);e(e.S,"String",{raw:function(t){for(var n=i(t.raw),r=o(n.length),e=arguments.length,u=[],c=0;r>c;)u.push(String(n[c++])),c<e&&u.push(String(arguments[c]));return u.join("")}})},function(t,n,r){var e=r(1);e(e.P,"String",{repeat:r(149)})},function(t,n,r){"use strict";r(29)("small",function(t){return function(){return t(this,"small","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(16),o=r(148),u="startsWith",c=""[u];e(e.P+e.F*r(134)(u),"String",{startsWith:function(t){var n=o(this,t,u),r=i(Math.min(arguments.length>1?arguments[1]:void 0,n.length)),e=String(t);return c?c.call(n,e,r):n.slice(r,r+e.length)===e}})},function(t,n,r){"use strict";r(29)("strike",function(t){return function(){return t(this,"strike","","")}})},function(t,n,r){"use strict";r(29)("sub",function(t){return function(){return t(this,"sub","","")}})},function(t,n,r){"use strict";r(29)("sup",function(t){return function(){return t(this,"sup","","")}})},function(t,n,r){"use strict";r(82)("trim",function(t){return function(){return t(this,3)}})},function(t,n,r){"use strict";var e=r(3),i=r(24),o=r(10),u=r(1),c=r(28),f=r(65).KEY,a=r(4),s=r(126),l=r(81),h=r(76),v=r(7),p=r(182),d=r(153),y=r(206),g=r(205),b=r(138),m=r(2),x=r(30),w=r(50),S=r(66),_=r(70),O=r(174),E=r(31),P=r(11),j=r(72),F=E.f,M=P.f,A=O.f,N=e.Symbol,T=e.JSON,I=T&&T.stringify,k="prototype",L=v("_hidden"),R=v("toPrimitive"),C={}.propertyIsEnumerable,D=s("symbol-registry"),U=s("symbols"),W=s("op-symbols"),G=Object[k],B="function"==typeof N,V=e.QObject,z=!V||!V[k]||!V[k].findChild,q=o&&a(function(){return 7!=_(M({},"a",{get:function(){return M(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=F(G,n);e&&delete G[n],M(t,n,r),e&&t!==G&&M(G,n,e)}:M,K=function(t){var n=U[t]=_(N[k]);return n._k=t,n},J=B&&"symbol"==typeof N.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof N},Y=function(t,n,r){return t===G&&Y(W,n,r),m(t),n=w(n,!0),m(r),i(U,n)?(r.enumerable?(i(t,L)&&t[L][n]&&(t[L][n]=!1),r=_(r,{enumerable:S(0,!1)})):(i(t,L)||M(t,L,S(1,{})),t[L][n]=!0),q(t,n,r)):M(t,n,r)},H=function(t,n){m(t);for(var r,e=g(n=x(n)),i=0,o=e.length;o>i;)Y(t,r=e[i++],n[r]);return t},$=function(t,n){return void 0===n?_(t):H(_(t),n)},X=function(t){var n=C.call(this,t=w(t,!0));return!(this===G&&i(U,t)&&!i(W,t))&&(!(n||!i(this,t)||!i(U,t)||i(this,L)&&this[L][t])||n)},Q=function(t,n){if(t=x(t),n=w(n,!0),t!==G||!i(U,n)||i(W,n)){var r=F(t,n);return!r||!i(U,n)||i(t,L)&&t[L][n]||(r.enumerable=!0),r}},Z=function(t){for(var n,r=A(x(t)),e=[],o=0;r.length>o;)i(U,n=r[o++])||n==L||n==f||e.push(n);return e},tt=function(t){for(var n,r=t===G,e=A(r?W:x(t)),o=[],u=0;e.length>u;)!i(U,n=e[u++])||r&&!i(G,n)||o.push(U[n]);return o};B||(N=function(){if(this instanceof N)throw TypeError("Symbol is not a constructor!");var t=h(arguments.length>0?arguments[0]:void 0),n=function(r){this===G&&n.call(W,r),i(this,L)&&i(this[L],t)&&(this[L][t]=!1),q(this,t,S(1,r))};return o&&z&&q(G,t,{configurable:!0,set:n}),K(t)},c(N[k],"toString",function(){return this._k}),E.f=Q,P.f=Y,r(71).f=O.f=Z,r(116).f=X,r(125).f=tt,o&&!r(69)&&c(G,"propertyIsEnumerable",X,!0),p.f=function(t){return K(v(t))}),u(u.G+u.W+u.F*!B,{Symbol:N});for(var nt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),rt=0;nt.length>rt;)v(nt[rt++]);for(var nt=j(v.store),rt=0;nt.length>rt;)d(nt[rt++]);u(u.S+u.F*!B,"Symbol",{for:function(t){return i(D,t+="")?D[t]:D[t]=N(t)},keyFor:function(t){if(J(t))return y(D,t);throw TypeError(t+" is not a symbol!")},useSetter:function(){z=!0},useSimple:function(){z=!1}}),u(u.S+u.F*!B,"Object",{create:$,defineProperty:Y,defineProperties:H,getOwnPropertyDescriptor:Q,getOwnPropertyNames:Z,getOwnPropertySymbols:tt}),T&&u(u.S+u.F*(!B||a(function(){var t=N();return"[null]"!=I([t])||"{}"!=I({a:t})||"{}"!=I(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!J(t)){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);return n=e[1],"function"==typeof n&&(r=n),!r&&b(n)||(n=function(t,n){if(r&&(n=r.call(this,t,n)),!J(n))return n}),e[1]=n,I.apply(T,e)}}}),N[k][R]||r(27)(N[k],R,N[k].valueOf),l(N,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){"use strict";var e=r(1),i=r(127),o=r(152),u=r(2),c=r(75),f=r(16),a=r(6),s=r(3).ArrayBuffer,l=r(146),h=o.ArrayBuffer,v=o.DataView,p=i.ABV&&s.isView,d=h.prototype.slice,y=i.VIEW,g="ArrayBuffer";e(e.G+e.W+e.F*(s!==h),{ArrayBuffer:h}),e(e.S+e.F*!i.CONSTR,g,{isView:function(t){return p&&p(t)||a(t)&&y in t}}),e(e.P+e.U+e.F*r(4)(function(){return!new h(2).slice(1,void 0).byteLength}),g,{slice:function(t,n){if(void 0!==d&&void 0===n)return d.call(u(this),t);for(var r=u(this).byteLength,e=c(t,r),i=c(void 0===n?r:n,r),o=new(l(this,h))(f(i-e)),a=new v(this),s=new v(o),p=0;e<i;)s.setUint8(p++,a.getUint8(e++));return o}}),r(74)(g)},function(t,n,r){var e=r(1);e(e.G+e.W+e.F*!r(127).ABV,{DataView:r(152).DataView})},function(t,n,r){r(55)("Float32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Float64",8,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int16",2,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int8",1,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint16",2,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint8",1,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint8",1,function(t){return function(n,r,e){return t(this,n,r,e)}},!0)},function(t,n,r){"use strict";var e=r(166);r(118)("WeakSet",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function(t){return e.def(this,t,!0)}},e,!1,!0)},function(t,n,r){"use strict";var e=r(1),i=r(117)(!0);e(e.P,"Array",{includes:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)("includes")},function(t,n,r){var e=r(1),i=r(143)(),o=r(3).process,u="process"==r(45)(o);e(e.G,{asap:function(t){var n=u&&o.domain;i(n?n.bind(t):t)}})},function(t,n,r){var e=r(1),i=r(45);e(e.S,"Error",{isError:function(t){return"Error"===i(t)}})},function(t,n,r){var e=r(1);e(e.P+e.R,"Map",{toJSON:r(165)("Map")})},function(t,n,r){var e=r(1);e(e.S,"Math",{iaddh:function(t,n,r,e){var i=t>>>0,o=n>>>0,u=r>>>0;return o+(e>>>0)+((i&u|(i|u)&~(i+u>>>0))>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{imulh:function(t,n){var r=65535,e=+t,i=+n,o=e&r,u=i&r,c=e>>16,f=i>>16,a=(c*u>>>0)+(o*u>>>16);return c*f+(a>>16)+((o*f>>>0)+(a&r)>>16)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{isubh:function(t,n,r,e){var i=t>>>0,o=n>>>0,u=r>>>0;return o-(e>>>0)-((~i&u|~(i^u)&i-u>>>0)>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{umulh:function(t,n){var r=65535,e=+t,i=+n,o=e&r,u=i&r,c=e>>>16,f=i>>>16,a=(c*u>>>0)+(o*u>>>16);return c*f+(a>>>16)+((o*f>>>0)+(a&r)>>>16)}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(26),u=r(11);r(10)&&e(e.P+r(124),"Object",{__defineGetter__:function(t,n){u.f(i(this),t,{get:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(26),u=r(11);r(10)&&e(e.P+r(124),"Object",{__defineSetter__:function(t,n){u.f(i(this),t,{set:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){var e=r(1),i=r(176)(!0);e(e.S,"Object",{entries:function(t){return i(t)}})},function(t,n,r){var e=r(1),i=r(177),o=r(30),u=r(31),c=r(131);e(e.S,"Object",{getOwnPropertyDescriptors:function(t){for(var n,r=o(t),e=u.f,f=i(r),a={},s=0;f.length>s;)c(a,n=f[s++],e(r,n));return a}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50),u=r(32),c=r(31).f;r(10)&&e(e.P+r(124),"Object",{__lookupGetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.get}while(r=u(r))}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50),u=r(32),c=r(31).f;r(10)&&e(e.P+r(124),"Object",{__lookupSetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.set}while(r=u(r))}})},function(t,n,r){var e=r(1),i=r(176)(!1);e(e.S,"Object",{values:function(t){return i(t)}})},function(t,n,r){"use strict";var e=r(1),i=r(3),o=r(52),u=r(143)(),c=r(7)("observable"),f=r(26),a=r(2),s=r(68),l=r(73),h=r(27),v=r(79),p=v.RETURN,d=function(t){return null==t?void 0:f(t)},y=function(t){var n=t._c;n&&(t._c=void 0,n())},g=function(t){return void 0===t._o},b=function(t){g(t)||(t._o=void 0,y(t))},m=function(t,n){a(t),this._c=void 0,this._o=t,t=new x(this);try{var r=n(t),e=r;null!=r&&("function"==typeof r.unsubscribe?r=function(){e.unsubscribe()}:f(r),this._c=r)}catch(n){return void t.error(n)}g(this)&&y(this)};m.prototype=l({},{unsubscribe:function(){b(this)}});var x=function(t){this._s=t};x.prototype=l({},{next:function(t){var n=this._s;if(!g(n)){var r=n._o;try{var e=d(r.next);if(e)return e.call(r,t)}catch(t){try{b(n)}finally{throw t}}}},error:function(t){var n=this._s;if(g(n))throw t;var r=n._o;n._o=void 0;try{var e=d(r.error);if(!e)throw t;t=e.call(r,t)}catch(t){try{y(n)}finally{throw t}}return y(n),t},complete:function(t){var n=this._s;if(!g(n)){var r=n._o;n._o=void 0;try{var e=d(r.complete);t=e?e.call(r,t):void 0}catch(t){try{y(n)}finally{throw t}}return y(n),t}}});var w=function(t){s(this,w,"Observable","_f")._f=f(t)};l(w.prototype,{subscribe:function(t){return new m(t,this._f)},forEach:function(t){var n=this;return new(o.Promise||i.Promise)(function(r,e){f(t);var i=n.subscribe({next:function(n){try{return t(n)}catch(t){e(t),i.unsubscribe()}},error:e,complete:r})})}}),l(w,{from:function(t){var n="function"==typeof this?this:w,r=d(a(t)[c]);if(r){var e=a(r.call(t));return e.constructor===n?e:new n(function(t){return e.subscribe(t)})}return new n(function(n){var r=!1;return u(function(){if(!r){try{if(v(t,!1,function(t){if(n.next(t),r)return p})===p)return}catch(t){if(r)throw t;return void n.error(t)}n.complete()}}),function(){r=!0}})},of:function(){for(var t=0,n=arguments.length,r=Array(n);t<n;)r[t]=arguments[t++];return new("function"==typeof this?this:w)(function(t){var n=!1;return u(function(){if(!n){for(var e=0;e<r.length;++e)if(t.next(r[e]),n)return;t.complete()}}),function(){n=!0}})}}),h(w.prototype,c,function(){return this}),e(e.G,{Observable:w}),r(74)("Observable")},function(t,n,r){var e=r(54),i=r(2),o=e.key,u=e.set;e.exp({defineMetadata:function(t,n,r,e){u(t,n,i(r),o(e))}})},function(t,n,r){var e=r(54),i=r(2),o=e.key,u=e.map,c=e.store;e.exp({deleteMetadata:function(t,n){var r=arguments.length<3?void 0:o(arguments[2]),e=u(i(n),r,!1);if(void 0===e||!e.delete(t))return!1;if(e.size)return!0;var f=c.get(n);return f.delete(r),!!f.size||c.delete(n)}})},function(t,n,r){var e=r(185),i=r(161),o=r(54),u=r(2),c=r(32),f=o.keys,a=o.key,s=function(t,n){var r=f(t,n),o=c(t);if(null===o)return r;var u=s(o,n);return u.length?r.length?i(new e(r.concat(u))):u:r};o.exp({getMetadataKeys:function(t){return s(u(t),arguments.length<2?void 0:a(arguments[1]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(32),u=e.has,c=e.get,f=e.key,a=function(t,n,r){if(u(t,n,r))return c(t,n,r);var e=o(n);return null!==e?a(t,e,r):void 0};e.exp({getMetadata:function(t,n){return a(t,i(n),arguments.length<3?void 0:f(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.keys,u=e.key;e.exp({getOwnMetadataKeys:function(t){
return o(i(t),arguments.length<2?void 0:u(arguments[1]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.get,u=e.key;e.exp({getOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(32),u=e.has,c=e.key,f=function(t,n,r){if(u(t,n,r))return!0;var e=o(n);return null!==e&&f(t,e,r)};e.exp({hasMetadata:function(t,n){return f(t,i(n),arguments.length<3?void 0:c(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.has,u=e.key;e.exp({hasOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(26),u=e.key,c=e.set;e.exp({metadata:function(t,n){return function(r,e){c(t,n,(void 0!==e?i:o)(r),u(e))}}})},function(t,n,r){var e=r(1);e(e.P+e.R,"Set",{toJSON:r(165)("Set")})},function(t,n,r){"use strict";var e=r(1),i=r(147)(!0);e(e.P,"String",{at:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),i=r(46),o=r(16),u=r(122),c=r(120),f=RegExp.prototype,a=function(t,n){this._r=t,this._s=n};r(139)(a,"RegExp String",function(){var t=this._r.exec(this._s);return{value:t,done:null===t}}),e(e.P,"String",{matchAll:function(t){if(i(this),!u(t))throw TypeError(t+" is not a regexp!");var n=String(this),r="flags"in f?String(t.flags):c.call(t),e=new RegExp(t.source,~r.indexOf("g")?r:"g"+r);return e.lastIndex=o(t.lastIndex),new a(e,n)}})},function(t,n,r){"use strict";var e=r(1),i=r(181);e(e.P,"String",{padEnd:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0,!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(181);e(e.P,"String",{padStart:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0,!0)}})},function(t,n,r){"use strict";r(82)("trimLeft",function(t){return function(){return t(this,1)}},"trimStart")},function(t,n,r){"use strict";r(82)("trimRight",function(t){return function(){return t(this,2)}},"trimEnd")},function(t,n,r){r(153)("asyncIterator")},function(t,n,r){r(153)("observable")},function(t,n,r){var e=r(1);e(e.S,"System",{global:r(3)})},function(t,n,r){for(var e=r(155),i=r(28),o=r(3),u=r(27),c=r(80),f=r(7),a=f("iterator"),s=f("toStringTag"),l=c.Array,h=["NodeList","DOMTokenList","MediaList","StyleSheetList","CSSRuleList"],v=0;v<5;v++){var p,d=h[v],y=o[d],g=y&&y.prototype;if(g){g[a]||u(g,a,l),g[s]||u(g,s,d),c[d]=l;for(p in e)g[p]||i(g,p,e[p],!0)}}},function(t,n,r){var e=r(1),i=r(151);e(e.G+e.B,{setImmediate:i.set,clearImmediate:i.clear})},function(t,n,r){var e=r(3),i=r(1),o=r(121),u=r(207),c=e.navigator,f=!!c&&/MSIE .\./.test(c.userAgent),a=function(t){return f?function(n,r){return t(o(u,[].slice.call(arguments,2),"function"==typeof n?n:Function(n)),r)}:t};i(i.G+i.B+i.F*f,{setTimeout:a(e.setTimeout),setInterval:a(e.setInterval)})},function(t,n,r){r(330),r(269),r(271),r(270),r(273),r(275),r(280),r(274),r(272),r(282),r(281),r(277),r(278),r(276),r(268),r(279),r(283),r(284),r(236),r(238),r(237),r(286),r(285),r(256),r(266),r(267),r(257),r(258),r(259),r(260),r(261),r(262),r(263),r(264),r(265),r(239),r(240),r(241),r(242),r(243),r(244),r(245),r(246),r(247),r(248),r(249),r(250),r(251),r(252),r(253),r(254),r(255),r(317),r(322),r(329),r(320),r(312),r(313),r(318),r(323),r(325),r(308),r(309),r(310),r(311),r(314),r(315),r(316),r(319),r(321),r(324),r(326),r(327),r(328),r(231),r(233),r(232),r(235),r(234),r(220),r(218),r(224),r(221),r(227),r(229),r(217),r(223),r(214),r(228),r(212),r(226),r(225),r(219),r(222),r(211),r(213),r(216),r(215),r(230),r(155),r(302),r(307),r(184),r(303),r(304),r(305),r(306),r(287),r(183),r(185),r(186),r(342),r(331),r(332),r(337),r(340),r(341),r(335),r(338),r(336),r(339),r(333),r(334),r(288),r(289),r(290),r(291),r(292),r(295),r(293),r(294),r(296),r(297),r(298),r(299),r(301),r(300),r(343),r(369),r(372),r(371),r(373),r(374),r(370),r(375),r(376),r(354),r(357),r(353),r(351),r(352),r(355),r(356),r(346),r(368),r(377),r(345),r(347),r(349),r(348),r(350),r(359),r(360),r(362),r(361),r(364),r(363),r(365),r(366),r(367),r(344),r(358),r(380),r(379),r(378),t.exports=r(52)},function(t,n){function r(t,n){if("string"==typeof n)return t.insertAdjacentHTML("afterend",n);var r=t.nextSibling;return r?t.parentNode.insertBefore(n,r):t.parentNode.appendChild(n)}t.exports=r},,,,,,,,,function(t,n,r){(function(n,r){!function(n){"use strict";function e(t,n,r,e){var i=n&&n.prototype instanceof o?n:o,u=Object.create(i.prototype),c=new p(e||[]);return u._invoke=s(t,r,c),u}function i(t,n,r){try{return{type:"normal",arg:t.call(n,r)}}catch(t){return{type:"throw",arg:t}}}function o(){}function u(){}function c(){}function f(t){["next","throw","return"].forEach(function(n){t[n]=function(t){return this._invoke(n,t)}})}function a(t){function n(r,e,o,u){var c=i(t[r],t,e);if("throw"!==c.type){var f=c.arg,a=f.value;return a&&"object"==typeof a&&m.call(a,"__await")?Promise.resolve(a.__await).then(function(t){n("next",t,o,u)},function(t){n("throw",t,o,u)}):Promise.resolve(a).then(function(t){f.value=t,o(f)},u)}u(c.arg)}function e(t,r){function e(){return new Promise(function(e,i){n(t,r,e,i)})}return o=o?o.then(e,e):e()}"object"==typeof r&&r.domain&&(n=r.domain.bind(n));var o;this._invoke=e}function s(t,n,r){var e=P;return function(o,u){if(e===F)throw new Error("Generator is already running");if(e===M){if("throw"===o)throw u;return y()}for(r.method=o,r.arg=u;;){var c=r.delegate;if(c){var f=l(c,r);if(f){if(f===A)continue;return f}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if(e===P)throw e=M,r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);e=F;var a=i(t,n,r);if("normal"===a.type){if(e=r.done?M:j,a.arg===A)continue;return{value:a.arg,done:r.done}}"throw"===a.type&&(e=M,r.method="throw",r.arg=a.arg)}}}function l(t,n){var r=t.iterator[n.method];if(r===g){if(n.delegate=null,"throw"===n.method){if(t.iterator.return&&(n.method="return",n.arg=g,l(t,n),"throw"===n.method))return A;n.method="throw",n.arg=new TypeError("The iterator does not provide a 'throw' method")}return A}var e=i(r,t.iterator,n.arg);if("throw"===e.type)return n.method="throw",n.arg=e.arg,n.delegate=null,A;var o=e.arg;return o?o.done?(n[t.resultName]=o.value,n.next=t.nextLoc,"return"!==n.method&&(n.method="next",n.arg=g),n.delegate=null,A):o:(n.method="throw",n.arg=new TypeError("iterator result is not an object"),n.delegate=null,A)}function h(t){var n={tryLoc:t[0]};1 in t&&(n.catchLoc=t[1]),2 in t&&(n.finallyLoc=t[2],n.afterLoc=t[3]),this.tryEntries.push(n)}function v(t){var n=t.completion||{};n.type="normal",delete n.arg,t.completion=n}function p(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(h,this),this.reset(!0)}function d(t){if(t){var n=t[w];if(n)return n.call(t);if("function"==typeof t.next)return t;if(!isNaN(t.length)){var r=-1,e=function n(){for(;++r<t.length;)if(m.call(t,r))return n.value=t[r],n.done=!1,n;return n.value=g,n.done=!0,n};return e.next=e}}return{next:y}}function y(){return{value:g,done:!0}}var g,b=Object.prototype,m=b.hasOwnProperty,x="function"==typeof Symbol?Symbol:{},w=x.iterator||"@@iterator",S=x.asyncIterator||"@@asyncIterator",_=x.toStringTag||"@@toStringTag",O="object"==typeof t,E=n.regeneratorRuntime;if(E)return void(O&&(t.exports=E));E=n.regeneratorRuntime=O?t.exports:{},E.wrap=e;var P="suspendedStart",j="suspendedYield",F="executing",M="completed",A={},N={};N[w]=function(){return this};var T=Object.getPrototypeOf,I=T&&T(T(d([])));I&&I!==b&&m.call(I,w)&&(N=I);var k=c.prototype=o.prototype=Object.create(N);u.prototype=k.constructor=c,c.constructor=u,c[_]=u.displayName="GeneratorFunction",E.isGeneratorFunction=function(t){var n="function"==typeof t&&t.constructor;return!!n&&(n===u||"GeneratorFunction"===(n.displayName||n.name))},E.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,c):(t.__proto__=c,_ in t||(t[_]="GeneratorFunction")),t.prototype=Object.create(k),t},E.awrap=function(t){return{__await:t}},f(a.prototype),a.prototype[S]=function(){return this},E.AsyncIterator=a,E.async=function(t,n,r,i){var o=new a(e(t,n,r,i));return E.isGeneratorFunction(n)?o:o.next().then(function(t){return t.done?t.value:o.next()})},f(k),k[_]="Generator",k.toString=function(){return"[object Generator]"},E.keys=function(t){var n=[];for(var r in t)n.push(r);return n.reverse(),function r(){for(;n.length;){var e=n.pop();if(e in t)return r.value=e,r.done=!1,r}return r.done=!0,r}},E.values=d,p.prototype={constructor:p,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=g,this.done=!1,this.delegate=null,this.method="next",this.arg=g,this.tryEntries.forEach(v),!t)for(var n in this)"t"===n.charAt(0)&&m.call(this,n)&&!isNaN(+n.slice(1))&&(this[n]=g)},stop:function(){this.done=!0;var t=this.tryEntries[0],n=t.completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(t){function n(n,e){return o.type="throw",o.arg=t,r.next=n,e&&(r.method="next",r.arg=g),!!e}if(this.done)throw t;for(var r=this,e=this.tryEntries.length-1;e>=0;--e){var i=this.tryEntries[e],o=i.completion;if("root"===i.tryLoc)return n("end");if(i.tryLoc<=this.prev){var u=m.call(i,"catchLoc"),c=m.call(i,"finallyLoc");if(u&&c){if(this.prev<i.catchLoc)return n(i.catchLoc,!0);if(this.prev<i.finallyLoc)return n(i.finallyLoc)}else if(u){if(this.prev<i.catchLoc)return n(i.catchLoc,!0)}else{if(!c)throw new Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return n(i.finallyLoc)}}}},abrupt:function(t,n){for(var r=this.tryEntries.length-1;r>=0;--r){var e=this.tryEntries[r];if(e.tryLoc<=this.prev&&m.call(e,"finallyLoc")&&this.prev<e.finallyLoc){var i=e;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=n&&n<=i.finallyLoc&&(i=null);var o=i?i.completion:{};return o.type=t,o.arg=n,i?(this.method="next",this.next=i.finallyLoc,A):this.complete(o)},complete:function(t,n){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&n&&(this.next=n),A},finish:function(t){for(var n=this.tryEntries.length-1;n>=0;--n){var r=this.tryEntries[n];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),v(r),A}},catch:function(t){for(var n=this.tryEntries.length-1;n>=0;--n){var r=this.tryEntries[n];if(r.tryLoc===t){var e=r.completion;if("throw"===e.type){var i=e.arg;v(r)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(t,n,r){return this.delegate={iterator:d(t),resultName:n,nextLoc:r},"next"===this.method&&(this.arg=g),A}}}("object"==typeof n?n:"object"==typeof window?window:"object"==typeof self?self:this)}).call(n,function(){return this}(),r(158))}])</script><script src="/./main.0cf68a.js"></script><script>!function(){!function(e){var t=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(t),t.setAttribute("src",e)}("/slider.e37972.js")}()</script>


    
<div class="tools-col" q-class="show:isShow,hide:isShow|isFalse" q-on="click:stop(e)">
  <div class="tools-nav header-menu">
    
    
      
      
      
    
      
      
      
    
      
      
      
    
    

    <ul style="width: 70%">
    
    
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'innerArchive')"><a href="javascript:void(0)" q-class="active:innerArchive">所有文章</a></li>
      
        
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'friends')"><a href="javascript:void(0)" q-class="active:friends">友链</a></li>
      
        
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'aboutme')"><a href="javascript:void(0)" q-class="active:aboutme">关于我</a></li>
      
        
    </ul>
  </div>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all" q-show="innerArchive">
        <div class="search-wrap">
          <input class="search-ipt" q-model="search" type="text" placeholder="find something…">
          <i class="icon-search icon" q-show="search|isEmptyStr"></i>
          <i class="icon-close icon" q-show="search|isNotEmptyStr" q-on="click:clearChose(e)"></i>
        </div>
        <div class="widget tagcloud search-tag">
          <p class="search-tag-wording">tag:</p>
          <label class="search-switch">
            <input type="checkbox" q-on="click:toggleTag(e)" q-attr="checked:showTags">
          </label>
          <ul class="article-tag-list" q-show="showTags">
            
            <div class="clearfix"></div>
          </ul>
        </div>
        <ul class="search-ul">
          <p q-show="jsonFail" style="padding: 20px; font-size: 12px;">
            缺失模块。<br/>1、请确保node版本大于6.2<br/>2、在博客根目录（注意不是yilia根目录）执行以下命令：<br/> npm i hexo-generator-json-content --save<br/><br/>
            3、在根目录_config.yml里添加配置：
<pre style="font-size: 12px;" q-show="jsonFail">
  jsonContent:
    meta: false
    pages: false
    posts:
      title: true
      date: true
      path: true
      text: false
      raw: false
      content: false
      slug: false
      updated: false
      comments: false
      link: false
      permalink: false
      excerpt: false
      categories: false
      tags: true
</pre>
          </p>
          <li class="search-li" q-repeat="items" q-show="isShow">
            <a q-attr="href:path|urlformat" class="search-title"><i class="icon-quo-left icon"></i><span q-text="title"></span></a>
            <p class="search-time">
              <i class="icon-calendar icon"></i>
              <span q-text="date|dateformat"></span>
            </p>
            <p class="search-tag">
              <i class="icon-price-tags icon"></i>
              <span q-repeat="tags" q-on="click:choseTag(e, name)" q-text="name|tagformat"></span>
            </p>
          </li>
        </ul>
    	</section>
    

    
    	<section class="tools-section tools-section-friends" q-show="friends">
  		
        <ul class="search-ul">
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接1</a>
            </li>
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接2</a>
            </li>
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接3</a>
            </li>
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接4</a>
            </li>
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接5</a>
            </li>
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接6</a>
            </li>
          
        </ul>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me" q-show="aboutme">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">很惭愧&lt;br&gt;&lt;br&gt;只做了一点微小的工作&lt;br&gt;谢谢大家</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>